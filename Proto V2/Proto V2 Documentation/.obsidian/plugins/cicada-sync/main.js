/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (b.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@kwsites/file-exists/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_browser());
    var log = debug_1.default("@kwsites/file-exists");
    function check(path, isFile, isDirectory) {
      log(`checking %s`, path);
      try {
        const stat = fs_1.statSync(path);
        if (stat.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists2(path, type = exports.READABLE) {
      return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    exports.exists = exists2;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    function __export3(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export3(require_src());
  }
});

// node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CicadaPlugin
});
module.exports = __toCommonJS(main_exports);

// src/utils/constants.ts
var PLUGIN_NAME = "CI-SYNC";

// node_modules/consola/dist/core.mjs
var LogLevels = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
var LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};
function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isObject(value) && isObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu = createDefu();
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}
var paused = false;
var queue = [];
var Consola = class {
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(
        defaults,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  get level() {
    return this.options.level;
  }
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i >= 0) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  pauseLogs() {
    paused = true;
  }
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch (e) {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
};
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== void 0) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola(options = {}) {
  return new Consola(options);
}

// node_modules/consola/dist/browser.mjs
var BrowserReporter = class {
  constructor(options) {
    this.options = { ...options };
    this.defaultColor = "#7f8c8d";
    this.levelColorMap = {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    };
    this.typeColorMap = {
      success: "#2ecc71"
      // Green
    };
  }
  _getLogFn(level) {
    if (level < 1) {
      return console.__error || console.error;
    }
    if (level === 1) {
      return console.__warn || console.warn;
    }
    return console.__log || console.log;
  }
  log(logObj) {
    const consoleLogFn = this._getLogFn(logObj.level);
    const type = logObj.type === "log" ? "" : logObj.type;
    const tag = logObj.tag || "";
    const color = this.typeColorMap[logObj.type] || this.levelColorMap[logObj.level] || this.defaultColor;
    const style = `
      background: ${color};
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `;
    const badge = `%c${[tag, type].filter(Boolean).join(":")}`;
    if (typeof logObj.args[0] === "string") {
      consoleLogFn(
        `${badge}%c ${logObj.args[0]}`,
        style,
        // Empty string as style resets to default console style
        "",
        ...logObj.args.slice(1)
      );
    } else {
      consoleLogFn(badge, style, ...logObj.args);
    }
  }
};
function createConsola2(options = {}) {
  const consola2 = createConsola({
    reporters: options.reporters || [new BrowserReporter({})],
    prompt(message, options2 = {}) {
      if (options2.type === "confirm") {
        return Promise.resolve(confirm(message));
      }
      return Promise.resolve(prompt(message));
    },
    ...options
  });
  return consola2;
}
var consola = createConsola2();

// src/utils/logger.ts
var logger = consola.create({ level: LogLevels.debug }).withTag(PLUGIN_NAME);
var logger_default = logger;

// src/utils/notifier.ts
var import_obsidian = require("obsidian");
var notifyUserAboutFailure = (message) => new import_obsidian.Notice(`FATAL: ${message}`);

// src/controllers/syncController.ts
var import_obsidian2 = require("obsidian");
var SyncController = class {
  constructor(gitService, gitignoreService) {
    this.gitService = gitService;
    this.gitignoreService = gitignoreService;
    logger_default.debug("Initialized sync controller.");
  }
  async createVaultBackup() {
    if (await this.gitService.unstagedChangesExist()) {
      await this.handleUnstagedChanges();
    } else {
      logger_default.info("No changes in vault detected for backup/sync.");
      try {
        await this.gitService.gitPushUpstream();
        try {
          await this.gitService.gitPull();
        } catch (e) {
          logger_default.error("Pull failed.");
        }
      } catch (error) {
        logger_default.warn("Failed to push branch upstream");
        try {
          await this.gitService.gitPull();
          await this.gitService.gitPushUpstream();
          logger_default.success("Synced local and remote.");
        } catch (e) {
          notifyUserAboutFailure("Failed to sync with remote");
          logger_default.error("Pull and upstream failed.");
        }
      }
    }
    if (await this.gitService.isLocalAhead()) {
      await this.handleLocalAhead();
    }
  }
  async handleLocalAhead() {
    try {
      await this.gitService.gitPush();
      this.notifyUserAboutBackup();
    } catch (e) {
      logger_default.warn("Remote and local have conflicting changes!");
      logger_default.info("Starting rebase process...");
      try {
        await this.gitService.gitPullWithRebase();
        await this.gitService.gitPush();
        this.notifyUserAboutBackup();
        logger_default.success("Created vault sync.");
      } catch (e2) {
        this.notifyUserAboutConflicts();
        logger_default.error("Automatic rebasing failed.");
      }
    }
  }
  async handleUnstagedChanges() {
    logger_default.info("Unstaged changes detected. Syncronizing...");
    await this.gitService.gitStageAll();
    await this.gitService.gitCommit();
  }
  notifyUserAboutBackup() {
    new import_obsidian2.Notice("Successfully synced up vault!");
  }
  notifyUserAboutConflicts() {
    new import_obsidian2.Notice(
      "Your local and remote repositories had conflicting changes."
    );
    new import_obsidian2.Notice(
      "Please fix the changes and then click the sync button again."
    );
  }
  async sync() {
    if (await this.gitService.isRepo()) {
      logger_default.debug("Vault is initialized as a Git repository.");
    } else {
      logger_default.fatal("Vault is not initialized as a Git repository.");
      notifyUserAboutFailure("Vault is not a Git repository.");
      return;
    }
    if (await this.gitService.isRemoteConfigured()) {
      logger_default.debug("Remote repository is configured.");
    } else {
      logger_default.fatal("Remote repository is not configured.");
      notifyUserAboutFailure("Remote repository is not configured.");
      return;
    }
    if (await this.gitService.isRebasing()) {
      logger_default.debug("Stopping in progress rebase.");
      await this.gitService.stopRebasing();
    }
    await this.createVaultBackup();
  }
};

// src/services/gitService.ts
var import_dayjs = __toESM(require_dayjs_min());

// node_modules/simple-git/dist/esm/index.js
var import_file_exists = __toESM(require_dist(), 1);
var import_debug = __toESM(require_browser(), 1);
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_promise_deferred2 = __toESM(require_dist2(), 1);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS2 = /* @__PURE__ */ ((cache2) => {
  return (module2, temp) => {
    return cache2 && cache2.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache2 && cache2.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path) {
  return path instanceof String && cache.has(path);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path) {
  return (0, import_file_exists.exists)(path, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));
}
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(__spreadValues({ baseDir }, defaultOptions), ...options.filter((o) => typeof o === "object" && o));
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser3, streams) {
  return parser3(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser3) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser3
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(addConfigTask(key, value, rest[0] === true, asConfigScope(
        rest[1],
        "local"
        /* local */
      )), trailingFunctionArgument(arguments));
    },
    getConfig(key, scope) {
      return this._runTask(getConfigTask(key, asConfigScope(scope, void 0)), trailingFunctionArgument(arguments));
    },
    listConfig(...rest) {
      return this._runTask(listConfigTask(asConfigScope(rest[0], void 0)), trailingFunctionArgument(arguments));
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask({
        commands,
        format: "utf-8",
        parser(stdOut) {
          return parseGrep(stdOut);
        }
      }, then);
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger2 = createLogger(this.logLabel, name);
        return {
          task,
          logger: logger2,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger: logger2 }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger2.info(`Failed %o`, err);
            logger2(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
          } else {
            logger2.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger2) {
  return (err) => {
    logger2(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger2, output) {
  return (buffer) => {
    logger2(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get binary() {
        return this._executor.binary;
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger: logger2 } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger2) : this.attemptRemoteTask(task, logger2);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger2) {
        return __async(this, null, function* () {
          const args = this._plugins.exec("spawn.args", [...task.commands], pluginContext(task, task.commands));
          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger2.step("SPAWN"));
          const outputStreams = yield this.handleTaskData(task, args, raw, logger2.step("HANDLE"));
          logger2(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger2) {
        return __async(this, null, function* () {
          logger2(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger2) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger2(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec("task.error", { error: rejection }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));
          if (error && task.onError) {
            logger2.info(`exitCode=%s handling with custom error handler`);
            return task.onError(result, error, (newStdOut) => {
              logger2.info(`custom error handler treated as success`);
              logger2(`custom error returned a %s`, objectToString(newStdOut));
              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
            }, fail);
          }
          if (error) {
            logger2.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
            return fail(error);
          }
          logger2.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger2) {
        return __async(this, null, function* () {
          const outputLogger = logger2.sibling("output");
          const spawnOptions = this._plugins.exec("spawn.options", {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          }, pluginContext(task, task.commands));
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger2.info(`%s %o`, command, args);
            logger2("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on("data", onDataReceived(stdOut, "stdOut", logger2, outputLogger.step("stdOut")));
            spawned.stderr.on("data", onDataReceived(stdErr, "stdErr", logger2, outputLogger.step("stdErr")));
            spawned.on("error", onErrorReceived(stdErr, logger2));
            if (outputHandler) {
              logger2(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    init_git_executor_chain();
    GitExecutor = class {
      constructor(binary = "git", cwd, _scheduler, _plugins) {
        this.binary = binary;
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void 0);
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(checkoutTask(getTrailingOptions(arguments, 1)), trailingFunctionArgument(arguments));
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    init_utils();
    init_task();
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(/(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g, (result, [changes, insertions, deletions]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        result.summary.insertions = parseInt(insertions, 10) || 0;
        result.summary.deletions = parseInt(deletions, 10) || 0;
      }),
      new LineParser(/^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
        result.summary.changes = parseInt(changes, 10) || 0;
        const count = parseInt(lines, 10) || 0;
        if (direction === "-") {
          result.summary.deletions = count;
        } else if (direction === "+") {
          result.summary.insertions = count;
        }
      })
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[0], filterStringOrStringArray, [])), [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]);
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true), trailingFunctionArgument(arguments));
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    init_task();
  }
});
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser3 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
        result.files.push({
          file: file.trim(),
          changes: asNumber(changes),
          insertions: alterations.replace(/[^+]/g, "").length,
          deletions: alterations.replace(/[^-]/g, "").length,
          binary: false
        });
      }),
      new LineParser(/(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
        result.files.push({
          file: file.trim(),
          before: asNumber(before),
          after: asNumber(after),
          binary: true
        });
      }),
      new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
        const inserted = /(\d+) i/.exec(summary);
        const deleted = /(\d+) d/.exec(summary);
        result.changed = asNumber(changed);
        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
      })
    ];
    numStatParser = [
      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
        const insertions = asNumber(changesInsert);
        const deletions = asNumber(changesDelete);
        result.changed++;
        result.insertions += insertions;
        result.deletions += deletions;
        result.files.push({
          file,
          changes: insertions + deletions,
          insertions,
          deletions,
          binary: false
        });
      }),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(/([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/, (result, [status, _similarity, from, _to, to]) => {
        result.changed++;
        result.files.push({
          file: to != null ? to : from,
          changes: 0,
          status: orVoid(isDiffNameStatus(status) && status),
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce((line, field, index) => {
    line[field] = tokens[index] || "";
    return line;
  }, /* @__PURE__ */ Object.create({ diff: null }));
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
      const lineDetail = item.trim().split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser3
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
        const objects = objectEnumerationResult(result.remoteMessages);
        objects.total = asObjectCount(total);
        objects.reused = asObjectCount(reused);
        objects.packReused = asNumber(packReused);
      })
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
        result.remoteMessages.pullRequestUrl = pullRequestUrl;
      }),
      new RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
        result.remoteMessages.vulnerabilities = {
          count: asNumber(count),
          summary,
          url
        };
      })
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(/([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
        result.branch.local = branchLocal;
        result.hash.local = hashLocal;
        result.branch.remote = branchRemote;
        result.hash.remote = hashRemote;
      })
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
      }),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
        result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
          local,
          remote,
          remoteName
        });
      }),
      new LineParser(/^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {
        result.update = {
          head: {
            local,
            remote
          },
          hash: {
            from,
            to
          }
        };
      })
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(straightThroughBufferTask(commands), trailingFunctionArgument(arguments));
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(straightThroughStringTask(commands), trailingFunctionArgument(arguments));
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    fromPathRegex = /^(.+) -> (.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index + working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[1] || "";
          this.path = detail[2] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser2(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser2(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path.replace(/\0.+$/, ""), index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser2(" ", "A", (result, file) => append(result.created, file)),
      parser2(" ", "D", (result, file) => append(result.deleted, file)),
      parser2(" ", "M", (result, file) => append(result.modified, file)),
      parser2("A", " ", (result, file) => append(result.created, file) && append(result.staged, file)),
      parser2("A", "M", (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)),
      parser2("D", " ", (result, file) => append(result.deleted, file) && append(result.staged, file)),
      parser2("M", " ", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("M", "M", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser2("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser2("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser2("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser2("?", "?", (result, file) => append(result.not_added, file)),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty({
    major,
    minor,
    patch,
    agent,
    installed
  }, "toString", {
    value() {
      return `${this.major}.${this.minor}.${this.patch}`;
    },
    configurable: false,
    enumerable: false
  });
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(/version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));
      }),
      new LineParser(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
      })
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(straightThroughStringTask(["add", ...asArray(files)]), trailingFunctionArgument(arguments));
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void 0), next);
        }
        return this._runTask(configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"), next);
      }
      hashObject(path, write) {
        return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));
      }
      init(bare) {
        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      merge() {
        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
        }
        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask({
          remote: filterType(arguments[0], filterString),
          branch: filterType(arguments[1], filterString)
        }, getTrailingOptions(arguments));
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
      }
      status() {
        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
    };
    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), first_commit_default(), grep_default(), log_default(), show_default(), version_default());
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), true, name, commit, label);
      }),
      new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), false, name, commit, label);
      })
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser3 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser3
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(/\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/, (result, [from, to, name, tracking]) => {
        result.updated.push({
          name,
          tracking,
          to,
          from
        });
      })
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs = []) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser3
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module2) {
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS2(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS2(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS2(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS2(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS2(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS2(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS2(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS2(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS2(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS2(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS2(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS2(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS2(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS2(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS2(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS2(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS2(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS2(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS2(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS2(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS2(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS2(task_exports));
    function Git2(options, plugins) {
      this._executor = new GitExecutor2(options.binary, options.baseDir, new Scheduler2(options.maxConcurrentProcesses), plugins);
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._executor.binary = command;
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(stashListTask2(trailingOptionsArgument2(arguments) || {}, filterArray2(options) && options || []), trailingFunctionArgument2(arguments));
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(createCloneTask("clone", cloneTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.mirror = function() {
      return this._runTask(createCloneTask("mirror", cloneMirrorTask2, ...arguments), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(pullTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(fetchTask2(filterType2(remote, filterString2), filterType2(branch, filterString2), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.silent = function(silence) {
      console.warn("simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3");
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(tagListTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rebase = function() {
      return this._runTask(straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]), next);
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(addAnnotatedTagTask2(tagName, tagMessage), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(branchTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(configurationErrorTask2("Raw: must supply one or more command to execute"), next);
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(updateSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(initSubModuleTask2(getTrailingOptions2(arguments, true)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(subModuleTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(listRemotesTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(remoteTask2(getTrailingOptions2(arguments)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(straightThroughStringTask2(["update-server-info"]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2({ remote: filterType2(remote, filterString2) }, getTrailingOptions2(arguments));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "-f", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"), handler);
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2("git.diff: supplying options as a single string is no longer supported, switch to an array of strings") : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(diffSummaryTask2(getTrailingOptions2(arguments, 1)), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(straightThroughStringTask2(commands, true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(cleanWithOptionsTask2(cleanMode, customArgs), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(checkIsRepoTask2(filterType2(checkType, filterString2)), trailingFunctionArgument2(arguments));
    };
    module2.exports = Git2;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(void 0, "unsafe", "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol");
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(void 0, "unsafe", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a2, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a2 = spawned.stdout) == null ? void 0 : _a2.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item));
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config = createInstanceConfig(baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {}, options);
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  return new Git(config, plugins);
}
init_git_response_error();
var esm_default = gitInstanceFactory;

// src/services/gitService.ts
var DEFAULT_REMOTE = "origin";
var CURRENT_TIME = () => (0, import_dayjs.default)().format("YYYY-MM-DDTHH:mm");
var COMMIT_MESSAGE = (deviceName) => `chore: vault backup from ${deviceName} at ${CURRENT_TIME()}`;
var SimpleGitService = class {
  constructor(repoPath, settings) {
    this.settings = settings;
    __publicField(this, "gitProvider");
    logger_default.debug("Initializing SimpleGitService...");
    this.gitProvider = esm_default(repoPath);
    logger_default.debug("SimpleGitService initialized.");
  }
  async gitCommit(message = COMMIT_MESSAGE(this.settings.deviceName)) {
    logger_default.info(`Committing... ${message}`);
    await this.gitProvider.commit(message);
  }
  async gitPullWithRebase() {
    await this.gitProvider.pull(["--rebase"]);
  }
  async gitPull(branch = this.settings.branchName) {
    await this.gitProvider.pull(DEFAULT_REMOTE, branch, ["--rebase"]);
  }
  async gitPushUpstream(branch = this.settings.branchName) {
    await this.gitProvider.push(DEFAULT_REMOTE, branch, [
      "--set-upstream",
      "--force"
    ]);
    logger_default.info(`Pushed branch upstream to ${DEFAULT_REMOTE}/${branch}.`);
  }
  async gitPush(forcePush = false, branch = this.settings.branchName) {
    const options = forcePush ? ["-f"] : [];
    await this.gitProvider.push(DEFAULT_REMOTE, branch, options);
    logger_default.info(`Pushed changes to ${DEFAULT_REMOTE}/${branch}.`);
  }
  async gitStage(...files) {
    await Promise.all(files.map((file) => this.gitProvider.add(file)));
  }
  async gitStageAll() {
    await this.gitProvider.add("./*");
  }
  async isLocalAhead() {
    return this.gitProvider.status().then((status) => status.ahead > 0);
  }
  async isRebasing() {
    return this.gitProvider.raw(["status"]).then((status) => status.includes("rebase"));
  }
  async isRemoteConfigured() {
    let remoteConfigured = false;
    try {
      const remotes = await this.gitProvider.listRemote(["--get-url"]);
      remoteConfigured = !!remotes;
    } catch (e) {
      remoteConfigured = false;
    }
    return remoteConfigured;
  }
  async isRepo() {
    return this.gitProvider.checkIsRepo();
  }
  async getConflictingFiles() {
    return this.gitProvider.status().then((status) => status.conflicted);
  }
  async stopRebasing() {
    process.env.GIT_EDITOR = "true";
    await this.gitStageAll();
    await this.gitProvider.rebase(["--continue"]);
    await this.gitPush();
    process.env.GIT_EDITOR = void 0;
  }
  async unstagedChangesExist() {
    return this.gitProvider.status().then(
      (status) => status.files.length > 0 || status.not_added.length > 0
    );
  }
};

// src/services/gitignoreService.ts
var import_path = require("path");
var GITIGNORE_FILE_NAME = ".gitignore";
var GitignoreService = class {
  constructor(basePath, gitService) {
    this.gitService = gitService;
    __publicField(this, "gitignorePath");
    logger_default.debug("Initializing GitignoreService...");
    this.gitignorePath = (0, import_path.resolve)(basePath, GITIGNORE_FILE_NAME);
    logger_default.debug("GitignoreService initialized.");
  }
  async stageCommitAndPushGitignore(message) {
    await this.gitService.gitStage(GITIGNORE_FILE_NAME);
    await this.gitService.gitCommit(message);
    await this.gitService.gitPush();
  }
};

// src/views/modals/unmergedFilesView.ts
var import_obsidian3 = require("obsidian");
var UnmergedFilesView = class extends import_obsidian3.Modal {
  constructor(app, gitService) {
    super(app);
    this.gitService = gitService;
  }
  onOpen() {
    var _a2;
    this.contentEl.empty();
    this.contentEl.createEl("h3", {
      text: "Loading...",
      cls: "sync-title"
    });
    (_a2 = this.gitService) == null ? void 0 : _a2.getConflictingFiles().then((files) => {
      this.contentEl.empty();
      if (files.length > 0) {
        this.contentEl.createEl("h3", {
          text: "Please resolve the conflicts in the following files:",
          cls: "sync-title"
        });
        const list = this.contentEl.createEl("ul");
        files.forEach(
          (file) => list.createEl("li").createEl("strong", {
            text: file,
            cls: "sync-conflicting-files"
          })
        );
      } else {
        this.contentEl.createEl("h3", {
          text: "No unmerged files to show!",
          cls: "sync-title"
        });
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/views/settingsTab.ts
var import_obsidian4 = require("obsidian");
var import_os = __toESM(require("os"));
var GITHUB_ISSUE_LINK = "https://github.com/adapole/cicada-sync/issues/new/choose";
var SAMPLE_REPO = "git@github.com:adapole/obsidian-yaos.git";
var DEFAULT_YAOS_SETTINGS = {
  deviceName: import_os.default.hostname(),
  remoteRepo: SAMPLE_REPO,
  basePath: __dirname,
  branchName: "main",
  syncImages: false,
  syncAudio: false,
  syncVideos: false,
  syncPdfs: false,
  syncOtherFiles: false,
  syncMainSettings: false,
  syncAppearanceSettings: false,
  syncThemesAndSnippets: false,
  syncHotkeys: false,
  syncCorePluginSettings: false,
  syncCommunityPluginSettings: false
};
var YaosSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    __publicField(this, "gitProvider");
    this.plugin = plugin;
    this.gitProvider = esm_default();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.addGeneralSection(containerEl);
    this.addGitSetup(containerEl);
  }
  addGeneralSection(containerEl) {
    new import_obsidian4.Setting(containerEl).setName("General").setHeading();
    this.addDeviceNameSetting(containerEl);
    this.addCreateIssueSetting(containerEl);
  }
  addGitSetup(containerEl) {
    new import_obsidian4.Setting(containerEl).setName("Setup Git").setHeading();
    this.addBranchName(containerEl);
    this.addRemoteRepoURL(containerEl);
  }
  addDeviceNameSetting(el) {
    new import_obsidian4.Setting(el).setName("Device name").setDesc(
      "This name will be displayed in the commit messages to indicate the sync source. Leave empty to use the default name."
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_YAOS_SETTINGS.deviceName).setValue(this.plugin.settings.deviceName).onChange(async (deviceName) => {
        this.plugin.settings.deviceName = deviceName;
        await this.plugin.saveSettings();
      })
    );
  }
  addCreateIssueSetting(el) {
    new import_obsidian4.Setting(el).setName("Contact support").setDesc(
      "If you run into any issues working with this plugin, please let us know by creating an issue on our GitHub page."
    ).addButton(
      (button) => button.setButtonText("Create issue").setTooltip("Create an issue on GitHub").setCta().onClick(
        () => self.open(GITHUB_ISSUE_LINK, "_blank", "norefferrer")
      )
    );
  }
  addRemoteRepoURL(el) {
    new import_obsidian4.Setting(el).setName("Import repository").setDesc(
      "If you want to import a vault from a remote repository, add the URL and Import to the directory you want."
    ).addText(
      (text) => text.setPlaceholder(SAMPLE_REPO).setValue(this.plugin.settings.remoteRepo).onChange(async (remoteRepo) => {
        this.plugin.settings.remoteRepo = remoteRepo;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(el).setDesc("The local vault directory to link the remote repository.").addText(
      (text) => text.setPlaceholder("C:/Users/").setValue(this.plugin.settings.basePath).onChange(async (basePath) => {
        this.plugin.settings.basePath = basePath;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(el).addButton(
      (button) => button.setButtonText("Import").setTooltip("Import a remote repository").setCta().onClick(async () => {
        try {
          const remoteRepo = `${this.plugin.settings.remoteRepo}`;
          await this.gitProvider.clone(
            remoteRepo,
            `${this.plugin.settings.basePath}`
          ).fetch();
        } catch (error) {
          console.error(error);
        }
      })
    );
  }
  addBranchName(el) {
    new import_obsidian4.Setting(el).setName("Select branch").setDesc("Set the working branch.").addText(
      (text) => text.setPlaceholder("main").setValue(this.plugin.settings.branchName).onChange(async (branchName) => {
        this.plugin.settings.branchName = branchName;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(el).addButton(
      (button) => button.setButtonText("Switch").setTooltip("Switch to this branch").setCta().onClick(async () => {
        let git = esm_default(this.plugin.settings.basePath);
        try {
          await git.checkoutBranch(
            `${this.plugin.settings.branchName}`,
            "HEAD"
          );
        } catch (error) {
          await git.checkout(
            `${this.plugin.settings.branchName}`
          );
        }
      })
    );
  }
};

// src/main.ts
var import_obsidian5 = require("obsidian");
var PLUGIN_ICON = "sync";
var CicadaPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "gitService");
    __publicField(this, "gitignoreService");
    __publicField(this, "syncController");
    __publicField(this, "settings", DEFAULT_YAOS_SETTINGS);
  }
  async onload() {
    logger_default.debug("Initializing plugin...");
    try {
      await this.loadSettings();
      logger_default.info("Loaded settings.");
    } catch (e) {
      logger_default.error("Failed to load settings.");
    }
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian5.FileSystemAdapter) {
      const basePath = adapter.getBasePath();
      this.gitService = new SimpleGitService(basePath, this.settings);
      this.gitignoreService = new GitignoreService(
        basePath,
        this.gitService
      );
      this.syncController = new SyncController(
        this.gitService,
        this.gitignoreService
      );
      this.addCommand({
        id: "show-unmerged",
        name: "Show unmerged/conflicting files",
        callback: () => new UnmergedFilesView(this.app, this.gitService).open()
      });
      this.addCommand({
        id: "sync",
        name: "Sync your vault",
        callback: async () => {
          await this.syncVault();
        }
      });
      this.addRibbonIcon(
        PLUGIN_ICON,
        PLUGIN_NAME,
        this.syncVault.bind(this)
      );
      this.addSettingTab(new YaosSettingTab(this.app, this));
      logger_default.debug("Plugin initialized.");
    } else {
      notifyUserAboutFailure("Adapter type is not recognized.");
      logger_default.fatal("Logger type was not FileSystemAdapter.");
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_YAOS_SETTINGS,
      await this.loadData()
    );
    if (this.settings.deviceName === "")
      this.settings.deviceName = DEFAULT_YAOS_SETTINGS.deviceName;
  }
  async saveSettings(settings = this.settings) {
    await this.saveData(settings);
  }
  async syncVault(_evt) {
    if (!this.gitService || !this.gitignoreService) {
      logger_default.fatal("Services were not initialized.");
    } else if (!this.syncController) {
      logger_default.fatal("Sync controller was not initialized.");
    } else {
      try {
        await this.syncController.sync();
      } catch (e) {
        new import_obsidian5.Notice("Unknown error occurred. Please create an issue.");
        logger_default.fatal("Unknown error:", e);
      }
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2RheWpzL2RheWpzLm1pbi5qcyIsICJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCAibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9maWxlLWV4aXN0cy9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0Brd3NpdGVzL2ZpbGUtZXhpc3RzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkL3NyYy9pbmRleC50cyIsICJzcmMvbWFpbi50cyIsICJzcmMvdXRpbHMvY29uc3RhbnRzLnRzIiwgIm5vZGVfbW9kdWxlcy9jb25zb2xhL2Rpc3QvY29yZS5tanMiLCAibm9kZV9tb2R1bGVzL2NvbnNvbGEvZGlzdC9icm93c2VyLm1qcyIsICJzcmMvdXRpbHMvbG9nZ2VyLnRzIiwgInNyYy91dGlscy9ub3RpZmllci50cyIsICJzcmMvY29udHJvbGxlcnMvc3luY0NvbnRyb2xsZXIudHMiLCAic3JjL3NlcnZpY2VzL2dpdFNlcnZpY2UudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcmdzL3BhdGhzcGVjLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL2dpdC1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2FyZ3VtZW50LWZpbHRlcnMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9leGl0LWNvZGVzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvZ2l0LW91dHB1dC1zdHJlYW1zLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvbGluZS1wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9zaW1wbGUtZ2l0LW9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy90YXNrLW9wdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy90YXNrLXBhcnNlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2hlY2staXMtcmVwby50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9DbGVhblN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy90YXNrLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2xlYW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQ29uZmlnTGlzdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NvbmZpZy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9ncmVwLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcmVzZXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9naXQtbG9nZ2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy90YXNrcy1wZW5kaW5nLXF1ZXVlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3ItY2hhaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2stY2FsbGJhY2sudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVja291dC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtY29tbWl0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY29tbWl0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZmlyc3QtY29tbWl0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvaGFzaC1vYmplY3QudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvSW5pdFN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9pbml0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvYXJncy9sb2ctZm9ybWF0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0RpZmZTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1kaWZmLXN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWxpc3QtbG9nLXN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9kaWZmLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvbG9nLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL01lcmdlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW9iamVjdHMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1tZXNzYWdlcy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVsbC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbWVyZ2UudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9tZXJnZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVzaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3B1c2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zaG93LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0ZpbGVTdGF0dXNTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL1N0YXR1c1N1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zdGF0dXMudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy92ZXJzaW9uLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvc2ltcGxlLWdpdC1hcGkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9ydW5uZXJzL3NjaGVkdWxlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2FwcGx5LXBhdGNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvYnJhbmNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0NoZWNrSWdub3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2hlY2staWdub3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2xvbmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWZldGNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLW1vdmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9tb3ZlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcHVsbC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9HZXRSZW1vdGVTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcmVtb3RlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3Mvc3Rhc2gtbGlzdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3N1Yi1tb2R1bGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvVGFnTGlzdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3RhZy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvZ2l0LmpzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvYXBpLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL2dpdC1jb25zdHJ1Y3QtZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvYWJvcnQtcGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9ibG9jay11bnNhZmUtb3BlcmF0aW9ucy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2NvbW1hbmQtY29uZmlnLXByZWZpeGluZy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2NvbXBsZXRpb24tZGV0ZWN0aW9uLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvZXJyb3ItZGV0ZWN0aW9uLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvcGx1Z2luLXN0b3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9wcm9ncmVzcy1tb25pdG9yLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvc3Bhd24tb3B0aW9ucy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3RpbW91dC1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9naXQtZmFjdG9yeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvcHJvbWlzZS13cmFwcGVkLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9lc20ubWpzIiwgInNyYy9zZXJ2aWNlcy9naXRpZ25vcmVTZXJ2aWNlLnRzIiwgInNyYy92aWV3cy9tb2RhbHMvdW5tZXJnZWRGaWxlc1ZpZXcudHMiLCAic3JjL3ZpZXdzL3NldHRpbmdzVGFiLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD0xZTMsZT02ZTQsbj0zNmU1LHI9XCJtaWxsaXNlY29uZFwiLGk9XCJzZWNvbmRcIixzPVwibWludXRlXCIsdT1cImhvdXJcIixhPVwiZGF5XCIsbz1cIndlZWtcIixjPVwibW9udGhcIixmPVwicXVhcnRlclwiLGg9XCJ5ZWFyXCIsZD1cImRhdGVcIixsPVwiSW52YWxpZCBEYXRlXCIsJD0vXihcXGR7NH0pWy0vXT8oXFxkezEsMn0pP1stL10/KFxcZHswLDJ9KVtUdFxcc10qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pP1suOl0/KFxcZCspPyQvLHk9L1xcWyhbXlxcXV0rKV18WXsxLDR9fE17MSw0fXxEezEsMn18ZHsxLDR9fEh7MSwyfXxoezEsMn18YXxBfG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nLE09e25hbWU6XCJlblwiLHdlZWtkYXlzOlwiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXlcIi5zcGxpdChcIl9cIiksbW9udGhzOlwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKSxvcmRpbmFsOmZ1bmN0aW9uKHQpe3ZhciBlPVtcInRoXCIsXCJzdFwiLFwibmRcIixcInJkXCJdLG49dCUxMDA7cmV0dXJuXCJbXCIrdCsoZVsobi0yMCklMTBdfHxlW25dfHxlWzBdKStcIl1cIn19LG09ZnVuY3Rpb24odCxlLG4pe3ZhciByPVN0cmluZyh0KTtyZXR1cm4hcnx8ci5sZW5ndGg+PWU/dDpcIlwiK0FycmF5KGUrMS1yLmxlbmd0aCkuam9pbihuKSt0fSx2PXtzOm0sejpmdW5jdGlvbih0KXt2YXIgZT0tdC51dGNPZmZzZXQoKSxuPU1hdGguYWJzKGUpLHI9TWF0aC5mbG9vcihuLzYwKSxpPW4lNjA7cmV0dXJuKGU8PTA/XCIrXCI6XCItXCIpK20ociwyLFwiMFwiKStcIjpcIittKGksMixcIjBcIil9LG06ZnVuY3Rpb24gdChlLG4pe2lmKGUuZGF0ZSgpPG4uZGF0ZSgpKXJldHVybi10KG4sZSk7dmFyIHI9MTIqKG4ueWVhcigpLWUueWVhcigpKSsobi5tb250aCgpLWUubW9udGgoKSksaT1lLmNsb25lKCkuYWRkKHIsYykscz1uLWk8MCx1PWUuY2xvbmUoKS5hZGQocisocz8tMToxKSxjKTtyZXR1cm4rKC0ocisobi1pKS8ocz9pLXU6dS1pKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24odCl7cmV0dXJue006Yyx5OmgsdzpvLGQ6YSxEOmQsaDp1LG06cyxzOmksbXM6cixROmZ9W3RdfHxTdHJpbmcodHx8XCJcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9zJC8sXCJcIil9LHU6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXR9fSxnPVwiZW5cIixEPXt9O0RbZ109TTt2YXIgcD1cIiRpc0RheWpzT2JqZWN0XCIsUz1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIF98fCEoIXR8fCF0W3BdKX0sdz1mdW5jdGlvbiB0KGUsbixyKXt2YXIgaTtpZighZSlyZXR1cm4gZztpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIHM9ZS50b0xvd2VyQ2FzZSgpO0Rbc10mJihpPXMpLG4mJihEW3NdPW4saT1zKTt2YXIgdT1lLnNwbGl0KFwiLVwiKTtpZighaSYmdS5sZW5ndGg+MSlyZXR1cm4gdCh1WzBdKX1lbHNle3ZhciBhPWUubmFtZTtEW2FdPWUsaT1hfXJldHVybiFyJiZpJiYoZz1pKSxpfHwhciYmZ30sTz1mdW5jdGlvbih0LGUpe2lmKFModCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyBfKG4pfSxiPXY7Yi5sPXcsYi5pPVMsYi53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE8odCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUseDplLiR4LCRvZmZzZXQ6ZS4kb2Zmc2V0fSl9O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTSh0KXt0aGlzLiRMPXcodC5sb2NhbGUsbnVsbCwhMCksdGhpcy5wYXJzZSh0KSx0aGlzLiR4PXRoaXMuJHh8fHQueHx8e30sdGhpc1twXT0hMH12YXIgbT1NLnByb3RvdHlwZTtyZXR1cm4gbS5wYXJzZT1mdW5jdGlvbih0KXt0aGlzLiRkPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0ZSxuPXQudXRjO2lmKG51bGw9PT1lKXJldHVybiBuZXcgRGF0ZShOYU4pO2lmKGIudShlKSlyZXR1cm4gbmV3IERhdGU7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIG5ldyBEYXRlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYhL1okL2kudGVzdChlKSl7dmFyIHI9ZS5tYXRjaCgkKTtpZihyKXt2YXIgaT1yWzJdLTF8fDAscz0ocls3XXx8XCIwXCIpLnN1YnN0cmluZygwLDMpO3JldHVybiBuP25ldyBEYXRlKERhdGUuVVRDKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpKTpuZXcgRGF0ZShyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxzKX19cmV0dXJuIG5ldyBEYXRlKGUpfSh0KSx0aGlzLmluaXQoKX0sbS5pbml0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kZDt0aGlzLiR5PXQuZ2V0RnVsbFllYXIoKSx0aGlzLiRNPXQuZ2V0TW9udGgoKSx0aGlzLiREPXQuZ2V0RGF0ZSgpLHRoaXMuJFc9dC5nZXREYXkoKSx0aGlzLiRIPXQuZ2V0SG91cnMoKSx0aGlzLiRtPXQuZ2V0TWludXRlcygpLHRoaXMuJHM9dC5nZXRTZWNvbmRzKCksdGhpcy4kbXM9dC5nZXRNaWxsaXNlY29uZHMoKX0sbS4kdXRpbHM9ZnVuY3Rpb24oKXtyZXR1cm4gYn0sbS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLiRkLnRvU3RyaW5nKCk9PT1sKX0sbS5pc1NhbWU9ZnVuY3Rpb24odCxlKXt2YXIgbj1PKHQpO3JldHVybiB0aGlzLnN0YXJ0T2YoZSk8PW4mJm48PXRoaXMuZW5kT2YoZSl9LG0uaXNBZnRlcj1mdW5jdGlvbih0LGUpe3JldHVybiBPKHQpPHRoaXMuc3RhcnRPZihlKX0sbS5pc0JlZm9yZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuZE9mKGUpPE8odCl9LG0uJGc9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBiLnUodCk/dGhpc1tlXTp0aGlzLnNldChuLHQpfSxtLnVuaXg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKS8xZTMpfSxtLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC5nZXRUaW1lKCl9LG0uc3RhcnRPZj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMscj0hIWIudShlKXx8ZSxmPWIucCh0KSxsPWZ1bmN0aW9uKHQsZSl7dmFyIGk9Yi53KG4uJHU/RGF0ZS5VVEMobi4keSxlLHQpOm5ldyBEYXRlKG4uJHksZSx0KSxuKTtyZXR1cm4gcj9pOmkuZW5kT2YoYSl9LCQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYi53KG4udG9EYXRlKClbdF0uYXBwbHkobi50b0RhdGUoXCJzXCIpLChyP1swLDAsMCwwXTpbMjMsNTksNTksOTk5XSkuc2xpY2UoZSkpLG4pfSx5PXRoaXMuJFcsTT10aGlzLiRNLG09dGhpcy4kRCx2PVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKTtzd2l0Y2goZil7Y2FzZSBoOnJldHVybiByP2woMSwwKTpsKDMxLDExKTtjYXNlIGM6cmV0dXJuIHI/bCgxLE0pOmwoMCxNKzEpO2Nhc2Ugbzp2YXIgZz10aGlzLiRsb2NhbGUoKS53ZWVrU3RhcnR8fDAsRD0oeTxnP3krNzp5KS1nO3JldHVybiBsKHI/bS1EOm0rKDYtRCksTSk7Y2FzZSBhOmNhc2UgZDpyZXR1cm4gJCh2K1wiSG91cnNcIiwwKTtjYXNlIHU6cmV0dXJuICQoditcIk1pbnV0ZXNcIiwxKTtjYXNlIHM6cmV0dXJuICQoditcIlNlY29uZHNcIiwyKTtjYXNlIGk6cmV0dXJuICQoditcIk1pbGxpc2Vjb25kc1wiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LG0uZW5kT2Y9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnRPZih0LCExKX0sbS4kc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG4sbz1iLnAodCksZj1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIiksbD0obj17fSxuW2FdPWYrXCJEYXRlXCIsbltkXT1mK1wiRGF0ZVwiLG5bY109ZitcIk1vbnRoXCIsbltoXT1mK1wiRnVsbFllYXJcIixuW3VdPWYrXCJIb3Vyc1wiLG5bc109ZitcIk1pbnV0ZXNcIixuW2ldPWYrXCJTZWNvbmRzXCIsbltyXT1mK1wiTWlsbGlzZWNvbmRzXCIsbilbb10sJD1vPT09YT90aGlzLiREKyhlLXRoaXMuJFcpOmU7aWYobz09PWN8fG89PT1oKXt2YXIgeT10aGlzLmNsb25lKCkuc2V0KGQsMSk7eS4kZFtsXSgkKSx5LmluaXQoKSx0aGlzLiRkPXkuc2V0KGQsTWF0aC5taW4odGhpcy4kRCx5LmRheXNJbk1vbnRoKCkpKS4kZH1lbHNlIGwmJnRoaXMuJGRbbF0oJCk7cmV0dXJuIHRoaXMuaW5pdCgpLHRoaXN9LG0uc2V0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS4kc2V0KHQsZSl9LG0uZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzW2IucCh0KV0oKX0sbS5hZGQ9ZnVuY3Rpb24ocixmKXt2YXIgZCxsPXRoaXM7cj1OdW1iZXIocik7dmFyICQ9Yi5wKGYpLHk9ZnVuY3Rpb24odCl7dmFyIGU9TyhsKTtyZXR1cm4gYi53KGUuZGF0ZShlLmRhdGUoKStNYXRoLnJvdW5kKHQqcikpLGwpfTtpZigkPT09YylyZXR1cm4gdGhpcy5zZXQoYyx0aGlzLiRNK3IpO2lmKCQ9PT1oKXJldHVybiB0aGlzLnNldChoLHRoaXMuJHkrcik7aWYoJD09PWEpcmV0dXJuIHkoMSk7aWYoJD09PW8pcmV0dXJuIHkoNyk7dmFyIE09KGQ9e30sZFtzXT1lLGRbdV09bixkW2ldPXQsZClbJF18fDEsbT10aGlzLiRkLmdldFRpbWUoKStyKk07cmV0dXJuIGIudyhtLHRoaXMpfSxtLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYWRkKC0xKnQsZSl9LG0uZm9ybWF0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLiRsb2NhbGUoKTtpZighdGhpcy5pc1ZhbGlkKCkpcmV0dXJuIG4uaW52YWxpZERhdGV8fGw7dmFyIHI9dHx8XCJZWVlZLU1NLUREVEhIOm1tOnNzWlwiLGk9Yi56KHRoaXMpLHM9dGhpcy4kSCx1PXRoaXMuJG0sYT10aGlzLiRNLG89bi53ZWVrZGF5cyxjPW4ubW9udGhzLGY9bi5tZXJpZGllbSxoPWZ1bmN0aW9uKHQsbixpLHMpe3JldHVybiB0JiYodFtuXXx8dChlLHIpKXx8aVtuXS5zbGljZSgwLHMpfSxkPWZ1bmN0aW9uKHQpe3JldHVybiBiLnMocyUxMnx8MTIsdCxcIjBcIil9LCQ9Znx8ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQ8MTI/XCJBTVwiOlwiUE1cIjtyZXR1cm4gbj9yLnRvTG93ZXJDYXNlKCk6cn07cmV0dXJuIHIucmVwbGFjZSh5LChmdW5jdGlvbih0LHIpe3JldHVybiByfHxmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwiWVlcIjpyZXR1cm4gU3RyaW5nKGUuJHkpLnNsaWNlKC0yKTtjYXNlXCJZWVlZXCI6cmV0dXJuIGIucyhlLiR5LDQsXCIwXCIpO2Nhc2VcIk1cIjpyZXR1cm4gYSsxO2Nhc2VcIk1NXCI6cmV0dXJuIGIucyhhKzEsMixcIjBcIik7Y2FzZVwiTU1NXCI6cmV0dXJuIGgobi5tb250aHNTaG9ydCxhLGMsMyk7Y2FzZVwiTU1NTVwiOnJldHVybiBoKGMsYSk7Y2FzZVwiRFwiOnJldHVybiBlLiREO2Nhc2VcIkREXCI6cmV0dXJuIGIucyhlLiRELDIsXCIwXCIpO2Nhc2VcImRcIjpyZXR1cm4gU3RyaW5nKGUuJFcpO2Nhc2VcImRkXCI6cmV0dXJuIGgobi53ZWVrZGF5c01pbixlLiRXLG8sMik7Y2FzZVwiZGRkXCI6cmV0dXJuIGgobi53ZWVrZGF5c1Nob3J0LGUuJFcsbywzKTtjYXNlXCJkZGRkXCI6cmV0dXJuIG9bZS4kV107Y2FzZVwiSFwiOnJldHVybiBTdHJpbmcocyk7Y2FzZVwiSEhcIjpyZXR1cm4gYi5zKHMsMixcIjBcIik7Y2FzZVwiaFwiOnJldHVybiBkKDEpO2Nhc2VcImhoXCI6cmV0dXJuIGQoMik7Y2FzZVwiYVwiOnJldHVybiAkKHMsdSwhMCk7Y2FzZVwiQVwiOnJldHVybiAkKHMsdSwhMSk7Y2FzZVwibVwiOnJldHVybiBTdHJpbmcodSk7Y2FzZVwibW1cIjpyZXR1cm4gYi5zKHUsMixcIjBcIik7Y2FzZVwic1wiOnJldHVybiBTdHJpbmcoZS4kcyk7Y2FzZVwic3NcIjpyZXR1cm4gYi5zKGUuJHMsMixcIjBcIik7Y2FzZVwiU1NTXCI6cmV0dXJuIGIucyhlLiRtcywzLFwiMFwiKTtjYXNlXCJaXCI6cmV0dXJuIGl9cmV0dXJuIG51bGx9KHQpfHxpLnJlcGxhY2UoXCI6XCIsXCJcIil9KSl9LG0udXRjT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE1Ki1NYXRoLnJvdW5kKHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSl9LG0uZGlmZj1mdW5jdGlvbihyLGQsbCl7dmFyICQseT10aGlzLE09Yi5wKGQpLG09TyhyKSx2PShtLnV0Y09mZnNldCgpLXRoaXMudXRjT2Zmc2V0KCkpKmUsZz10aGlzLW0sRD1mdW5jdGlvbigpe3JldHVybiBiLm0oeSxtKX07c3dpdGNoKE0pe2Nhc2UgaDokPUQoKS8xMjticmVhaztjYXNlIGM6JD1EKCk7YnJlYWs7Y2FzZSBmOiQ9RCgpLzM7YnJlYWs7Y2FzZSBvOiQ9KGctdikvNjA0OGU1O2JyZWFrO2Nhc2UgYTokPShnLXYpLzg2NGU1O2JyZWFrO2Nhc2UgdTokPWcvbjticmVhaztjYXNlIHM6JD1nL2U7YnJlYWs7Y2FzZSBpOiQ9Zy90O2JyZWFrO2RlZmF1bHQ6JD1nfXJldHVybiBsPyQ6Yi5hKCQpfSxtLmRheXNJbk1vbnRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kT2YoYykuJER9LG0uJGxvY2FsZT1mdW5jdGlvbigpe3JldHVybiBEW3RoaXMuJExdfSxtLmxvY2FsZT1mdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybiB0aGlzLiRMO3ZhciBuPXRoaXMuY2xvbmUoKSxyPXcodCxlLCEwKTtyZXR1cm4gciYmKG4uJEw9ciksbn0sbS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBiLncodGhpcy4kZCx0aGlzKX0sbS50b0RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpfSxtLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzVmFsaWQoKT90aGlzLnRvSVNPU3RyaW5nKCk6bnVsbH0sbS50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvSVNPU3RyaW5nKCl9LG0udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b1VUQ1N0cmluZygpfSxNfSgpLGs9Xy5wcm90b3R5cGU7cmV0dXJuIE8ucHJvdG90eXBlPWssW1tcIiRtc1wiLHJdLFtcIiRzXCIsaV0sW1wiJG1cIixzXSxbXCIkSFwiLHVdLFtcIiRXXCIsYV0sW1wiJE1cIixjXSxbXCIkeVwiLGhdLFtcIiREXCIsZF1dLmZvckVhY2goKGZ1bmN0aW9uKHQpe2tbdFsxXV09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuJGcoZSx0WzBdLHRbMV0pfX0pKSxPLmV4dGVuZD1mdW5jdGlvbih0LGUpe3JldHVybiB0LiRpfHwodChlLF8sTyksdC4kaT0hMCksT30sTy5sb2NhbGU9dyxPLmlzRGF5anM9UyxPLnVuaXg9ZnVuY3Rpb24odCl7cmV0dXJuIE8oMWUzKnQpfSxPLmVuPURbZ10sTy5Mcz1ELE8ucD17fSxPfSkpOyIsICIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsICJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0IFN5bmNDb250cm9sbGVyIGZyb20gXCJAL2NvbnRyb2xsZXJzL3N5bmNDb250cm9sbGVyXCI7XHJcbmltcG9ydCB7IEdpdFNlcnZpY2UsIFNpbXBsZUdpdFNlcnZpY2UgfSBmcm9tIFwiQC9zZXJ2aWNlcy9naXRTZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEdpdGlnbm9yZVNlcnZpY2UgfSBmcm9tIFwiQC9zZXJ2aWNlcy9naXRpZ25vcmVTZXJ2aWNlXCI7XHJcblxyXG5pbXBvcnQgeyBQTFVHSU5fTkFNRSB9IGZyb20gXCJAL3V0aWxzL2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgbG9nZ2VyIGZyb20gXCJAL3V0aWxzL2xvZ2dlclwiO1xyXG5pbXBvcnQgeyBub3RpZnlVc2VyQWJvdXRGYWlsdXJlIH0gZnJvbSBcIkAvdXRpbHMvbm90aWZpZXJcIjtcclxuXHJcbmltcG9ydCBVbm1lcmdlZEZpbGVzVmlldyBmcm9tIFwiQC92aWV3cy9tb2RhbHMvdW5tZXJnZWRGaWxlc1ZpZXdcIjtcclxuaW1wb3J0IFlhb3NTZXR0aW5nVGFiLCB7XHJcblx0REVGQVVMVF9ZQU9TX1NFVFRJTkdTLFxyXG5cdFlhb3NTZXR0aW5ncyxcclxufSBmcm9tIFwiQC92aWV3cy9zZXR0aW5nc1RhYlwiO1xyXG5cclxuaW1wb3J0IHsgRmlsZVN5c3RlbUFkYXB0ZXIsIE5vdGljZSwgUGx1Z2luIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5jb25zdCBQTFVHSU5fSUNPTiA9IFwic3luY1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2ljYWRhUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRwcml2YXRlIGdpdFNlcnZpY2U/OiBHaXRTZXJ2aWNlO1xyXG5cdHByaXZhdGUgZ2l0aWdub3JlU2VydmljZT86IEdpdGlnbm9yZVNlcnZpY2U7XHJcblx0cHJpdmF0ZSBzeW5jQ29udHJvbGxlcj86IFN5bmNDb250cm9sbGVyO1xyXG5cclxuXHRzZXR0aW5nczogWWFvc1NldHRpbmdzID0gREVGQVVMVF9ZQU9TX1NFVFRJTkdTO1xyXG5cclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRsb2dnZXIuZGVidWcoXCJJbml0aWFsaXppbmcgcGx1Z2luLi4uXCIpO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0XHRsb2dnZXIuaW5mbyhcIkxvYWRlZCBzZXR0aW5ncy5cIik7XHJcblx0XHR9IGNhdGNoIHtcclxuXHRcdFx0bG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc2V0dGluZ3MuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xyXG5cclxuXHRcdGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcclxuXHRcdFx0Y29uc3QgYmFzZVBhdGggPSBhZGFwdGVyLmdldEJhc2VQYXRoKCk7XHJcblxyXG5cdFx0XHR0aGlzLmdpdFNlcnZpY2UgPSBuZXcgU2ltcGxlR2l0U2VydmljZShiYXNlUGF0aCwgdGhpcy5zZXR0aW5ncyk7XHJcblx0XHRcdHRoaXMuZ2l0aWdub3JlU2VydmljZSA9IG5ldyBHaXRpZ25vcmVTZXJ2aWNlKFxyXG5cdFx0XHRcdGJhc2VQYXRoLFxyXG5cdFx0XHRcdHRoaXMuZ2l0U2VydmljZVxyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLnN5bmNDb250cm9sbGVyID0gbmV3IFN5bmNDb250cm9sbGVyKFxyXG5cdFx0XHRcdHRoaXMuZ2l0U2VydmljZSxcclxuXHRcdFx0XHR0aGlzLmdpdGlnbm9yZVNlcnZpY2VcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdFx0aWQ6IFwic2hvdy11bm1lcmdlZFwiLFxyXG5cdFx0XHRcdG5hbWU6IFwiU2hvdyB1bm1lcmdlZC9jb25mbGljdGluZyBmaWxlc1wiLFxyXG5cdFx0XHRcdGNhbGxiYWNrOiAoKSA9PlxyXG5cdFx0XHRcdFx0bmV3IFVubWVyZ2VkRmlsZXNWaWV3KHRoaXMuYXBwLCB0aGlzLmdpdFNlcnZpY2UpLm9wZW4oKSxcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdFx0aWQ6IFwic3luY1wiLFxyXG5cdFx0XHRcdG5hbWU6IFwiU3luYyB5b3VyIHZhdWx0XCIsXHJcblx0XHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuc3luY1ZhdWx0KCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuYWRkUmliYm9uSWNvbihcclxuXHRcdFx0XHRQTFVHSU5fSUNPTixcclxuXHRcdFx0XHRQTFVHSU5fTkFNRSxcclxuXHRcdFx0XHR0aGlzLnN5bmNWYXVsdC5iaW5kKHRoaXMpXHJcblx0XHRcdCk7XHJcblx0XHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgWWFvc1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcclxuXHJcblx0XHRcdGxvZ2dlci5kZWJ1ZyhcIlBsdWdpbiBpbml0aWFsaXplZC5cIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRub3RpZnlVc2VyQWJvdXRGYWlsdXJlKFwiQWRhcHRlciB0eXBlIGlzIG5vdCByZWNvZ25pemVkLlwiKTtcclxuXHJcblx0XHRcdGxvZ2dlci5mYXRhbChcIkxvZ2dlciB0eXBlIHdhcyBub3QgRmlsZVN5c3RlbUFkYXB0ZXIuXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXHJcblx0XHRcdHt9LFxyXG5cdFx0XHRERUZBVUxUX1lBT1NfU0VUVElOR1MsXHJcblx0XHRcdGF3YWl0IHRoaXMubG9hZERhdGEoKVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5kZXZpY2VOYW1lID09PSBcIlwiKVxyXG5cdFx0XHR0aGlzLnNldHRpbmdzLmRldmljZU5hbWUgPSBERUZBVUxUX1lBT1NfU0VUVElOR1MuZGV2aWNlTmFtZTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncyhzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MpIHtcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEoc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzeW5jVmF1bHQoX2V2dD86IE1vdXNlRXZlbnQpIHtcclxuXHRcdGlmICghdGhpcy5naXRTZXJ2aWNlIHx8ICF0aGlzLmdpdGlnbm9yZVNlcnZpY2UpIHtcclxuXHRcdFx0bG9nZ2VyLmZhdGFsKFwiU2VydmljZXMgd2VyZSBub3QgaW5pdGlhbGl6ZWQuXCIpO1xyXG5cdFx0fSBlbHNlIGlmICghdGhpcy5zeW5jQ29udHJvbGxlcikge1xyXG5cdFx0XHRsb2dnZXIuZmF0YWwoXCJTeW5jIGNvbnRyb2xsZXIgd2FzIG5vdCBpbml0aWFsaXplZC5cIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc3luY0NvbnRyb2xsZXIuc3luYygpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIlVua25vd24gZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSBjcmVhdGUgYW4gaXNzdWUuXCIpO1xyXG5cclxuXHRcdFx0XHRsb2dnZXIuZmF0YWwoXCJVbmtub3duIGVycm9yOlwiLCBlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCAiZXhwb3J0IGNvbnN0IFBMVUdJTl9OQU1FID0gXCJDSS1TWU5DXCI7XHJcbiIsICJjb25zdCBMb2dMZXZlbHMgPSB7XG4gIHNpbGVudDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICBmYXRhbDogMCxcbiAgZXJyb3I6IDAsXG4gIHdhcm46IDEsXG4gIGxvZzogMixcbiAgaW5mbzogMyxcbiAgc3VjY2VzczogMyxcbiAgZmFpbDogMyxcbiAgcmVhZHk6IDMsXG4gIHN0YXJ0OiAzLFxuICBib3g6IDMsXG4gIGRlYnVnOiA0LFxuICB0cmFjZTogNSxcbiAgdmVyYm9zZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG59O1xuY29uc3QgTG9nVHlwZXMgPSB7XG4gIC8vIFNpbGVudFxuICBzaWxlbnQ6IHtcbiAgICBsZXZlbDogLTFcbiAgfSxcbiAgLy8gTGV2ZWwgMFxuICBmYXRhbDoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMuZmF0YWxcbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmVycm9yXG4gIH0sXG4gIC8vIExldmVsIDFcbiAgd2Fybjoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMud2FyblxuICB9LFxuICAvLyBMZXZlbCAyXG4gIGxvZzoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMubG9nXG4gIH0sXG4gIC8vIExldmVsIDNcbiAgaW5mbzoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMuaW5mb1xuICB9LFxuICBzdWNjZXNzOiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5zdWNjZXNzXG4gIH0sXG4gIGZhaWw6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmZhaWxcbiAgfSxcbiAgcmVhZHk6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmluZm9cbiAgfSxcbiAgc3RhcnQ6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmluZm9cbiAgfSxcbiAgYm94OiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5pbmZvXG4gIH0sXG4gIC8vIExldmVsIDRcbiAgZGVidWc6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmRlYnVnXG4gIH0sXG4gIC8vIExldmVsIDVcbiAgdHJhY2U6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLnRyYWNlXG4gIH0sXG4gIC8vIFZlcmJvc2VcbiAgdmVyYm9zZToge1xuICAgIGxldmVsOiBMb2dMZXZlbHMudmVyYm9zZVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gX2RlZnUoYmFzZU9iamVjdCwgZGVmYXVsdHMsIG5hbWVzcGFjZSA9IFwiLlwiLCBtZXJnZXIpIHtcbiAgaWYgKCFpc09iamVjdChkZWZhdWx0cykpIHtcbiAgICByZXR1cm4gX2RlZnUoYmFzZU9iamVjdCwge30sIG5hbWVzcGFjZSwgbWVyZ2VyKTtcbiAgfVxuICBjb25zdCBvYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIGZvciAoY29uc3Qga2V5IGluIGJhc2VPYmplY3QpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IGtleSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBiYXNlT2JqZWN0W2tleV07XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWVyZ2VyICYmIG1lcmdlcihvYmplY3QsIGtleSwgdmFsdWUsIG5hbWVzcGFjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShvYmplY3Rba2V5XSkpIHtcbiAgICAgIG9iamVjdFtrZXldID0gWy4uLnZhbHVlLCAuLi5vYmplY3Rba2V5XV07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3Qob2JqZWN0W2tleV0pKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IF9kZWZ1KFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb2JqZWN0W2tleV0sXG4gICAgICAgIChuYW1lc3BhY2UgPyBgJHtuYW1lc3BhY2V9LmAgOiBcIlwiKSArIGtleS50b1N0cmluZygpLFxuICAgICAgICBtZXJnZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZ1KG1lcmdlcikge1xuICByZXR1cm4gKC4uLmFyZ3VtZW50c18pID0+IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1hcnJheS1yZWR1Y2VcbiAgICBhcmd1bWVudHNfLnJlZHVjZSgocCwgYykgPT4gX2RlZnUocCwgYywgXCJcIiwgbWVyZ2VyKSwge30pXG4gICk7XG59XG5jb25zdCBkZWZ1ID0gY3JlYXRlRGVmdSgpO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc0xvZ09iaihhcmcpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFhcmcubWVzc2FnZSAmJiAhYXJnLmFyZ3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFyZy5zdGFjaykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubGV0IHBhdXNlZCA9IGZhbHNlO1xuY29uc3QgcXVldWUgPSBbXTtcbmNsYXNzIENvbnNvbGEge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0eXBlcyA9IG9wdGlvbnMudHlwZXMgfHwgTG9nVHlwZXM7XG4gICAgdGhpcy5vcHRpb25zID0gZGVmdShcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdHM6IHsgLi4ub3B0aW9ucy5kZWZhdWx0cyB9LFxuICAgICAgICBsZXZlbDogX25vcm1hbGl6ZUxvZ0xldmVsKG9wdGlvbnMubGV2ZWwsIHR5cGVzKSxcbiAgICAgICAgcmVwb3J0ZXJzOiBbLi4ub3B0aW9ucy5yZXBvcnRlcnMgfHwgW11dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlczogTG9nVHlwZXMsXG4gICAgICAgIHRocm90dGxlOiAxZTMsXG4gICAgICAgIHRocm90dGxlTWluOiA1LFxuICAgICAgICBmb3JtYXRPcHRpb25zOiB7XG4gICAgICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgICAgICBjb2xvcnM6IGZhbHNlLFxuICAgICAgICAgIGNvbXBhY3Q6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHR5cGVzKSB7XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAuLi50eXBlc1t0eXBlXVxuICAgICAgfTtcbiAgICAgIHRoaXNbdHlwZV0gPSB0aGlzLl93cmFwTG9nRm4oZGVmYXVsdHMpO1xuICAgICAgdGhpc1t0eXBlXS5yYXcgPSB0aGlzLl93cmFwTG9nRm4oXG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm1vY2tGbikge1xuICAgICAgdGhpcy5tb2NrVHlwZXMoKTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdExvZyA9IHt9O1xuICB9XG4gIGdldCBsZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVsO1xuICB9XG4gIHNldCBsZXZlbChsZXZlbCkge1xuICAgIHRoaXMub3B0aW9ucy5sZXZlbCA9IF9ub3JtYWxpemVMb2dMZXZlbChcbiAgICAgIGxldmVsLFxuICAgICAgdGhpcy5vcHRpb25zLnR5cGVzLFxuICAgICAgdGhpcy5vcHRpb25zLmxldmVsXG4gICAgKTtcbiAgfVxuICBwcm9tcHQobWVzc2FnZSwgb3B0cykge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnByb21wdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvbXB0IGlzIG5vdCBzdXBwb3J0ZWQhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByb21wdChtZXNzYWdlLCBvcHRzKTtcbiAgfVxuICBjcmVhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENvbnNvbGEoe1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9tb2NrRm4pIHtcbiAgICAgIGluc3RhbmNlLm1vY2tUeXBlcyh0aGlzLl9tb2NrRm4pO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgd2l0aERlZmF1bHRzKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgLi4uZGVmYXVsdHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3aXRoVGFnKHRhZykge1xuICAgIHJldHVybiB0aGlzLndpdGhEZWZhdWx0cyh7XG4gICAgICB0YWc6IHRoaXMub3B0aW9ucy5kZWZhdWx0cy50YWcgPyB0aGlzLm9wdGlvbnMuZGVmYXVsdHMudGFnICsgXCI6XCIgKyB0YWcgOiB0YWdcbiAgICB9KTtcbiAgfVxuICBhZGRSZXBvcnRlcihyZXBvcnRlcikge1xuICAgIHRoaXMub3B0aW9ucy5yZXBvcnRlcnMucHVzaChyZXBvcnRlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlUmVwb3J0ZXIocmVwb3J0ZXIpIHtcbiAgICBpZiAocmVwb3J0ZXIpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzLmluZGV4T2YocmVwb3J0ZXIpO1xuICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlcG9ydGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXBvcnRlcnMuc3BsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRSZXBvcnRlcnMocmVwb3J0ZXJzKSB7XG4gICAgdGhpcy5vcHRpb25zLnJlcG9ydGVycyA9IEFycmF5LmlzQXJyYXkocmVwb3J0ZXJzKSA/IHJlcG9ydGVycyA6IFtyZXBvcnRlcnNdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHdyYXBBbGwoKSB7XG4gICAgdGhpcy53cmFwQ29uc29sZSgpO1xuICAgIHRoaXMud3JhcFN0ZCgpO1xuICB9XG4gIHJlc3RvcmVBbGwoKSB7XG4gICAgdGhpcy5yZXN0b3JlQ29uc29sZSgpO1xuICAgIHRoaXMucmVzdG9yZVN0ZCgpO1xuICB9XG4gIHdyYXBDb25zb2xlKCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLm9wdGlvbnMudHlwZXMpIHtcbiAgICAgIGlmICghY29uc29sZVtcIl9fXCIgKyB0eXBlXSkge1xuICAgICAgICBjb25zb2xlW1wiX19cIiArIHR5cGVdID0gY29uc29sZVt0eXBlXTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbdHlwZV0gPSB0aGlzW3R5cGVdLnJhdztcbiAgICB9XG4gIH1cbiAgcmVzdG9yZUNvbnNvbGUoKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRoaXMub3B0aW9ucy50eXBlcykge1xuICAgICAgaWYgKGNvbnNvbGVbXCJfX1wiICsgdHlwZV0pIHtcbiAgICAgICAgY29uc29sZVt0eXBlXSA9IGNvbnNvbGVbXCJfX1wiICsgdHlwZV07XG4gICAgICAgIGRlbGV0ZSBjb25zb2xlW1wiX19cIiArIHR5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3cmFwU3RkKCkge1xuICAgIHRoaXMuX3dyYXBTdHJlYW0odGhpcy5vcHRpb25zLnN0ZG91dCwgXCJsb2dcIik7XG4gICAgdGhpcy5fd3JhcFN0cmVhbSh0aGlzLm9wdGlvbnMuc3RkZXJyLCBcImxvZ1wiKTtcbiAgfVxuICBfd3JhcFN0cmVhbShzdHJlYW0sIHR5cGUpIHtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXN0cmVhbS5fX3dyaXRlKSB7XG4gICAgICBzdHJlYW0uX193cml0ZSA9IHN0cmVhbS53cml0ZTtcbiAgICB9XG4gICAgc3RyZWFtLndyaXRlID0gKGRhdGEpID0+IHtcbiAgICAgIHRoaXNbdHlwZV0ucmF3KFN0cmluZyhkYXRhKS50cmltKCkpO1xuICAgIH07XG4gIH1cbiAgcmVzdG9yZVN0ZCgpIHtcbiAgICB0aGlzLl9yZXN0b3JlU3RyZWFtKHRoaXMub3B0aW9ucy5zdGRvdXQpO1xuICAgIHRoaXMuX3Jlc3RvcmVTdHJlYW0odGhpcy5vcHRpb25zLnN0ZGVycik7XG4gIH1cbiAgX3Jlc3RvcmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5fX3dyaXRlKSB7XG4gICAgICBzdHJlYW0ud3JpdGUgPSBzdHJlYW0uX193cml0ZTtcbiAgICAgIGRlbGV0ZSBzdHJlYW0uX193cml0ZTtcbiAgICB9XG4gIH1cbiAgcGF1c2VMb2dzKCkge1xuICAgIHBhdXNlZCA9IHRydWU7XG4gIH1cbiAgcmVzdW1lTG9ncygpIHtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBjb25zdCBfcXVldWUgPSBxdWV1ZS5zcGxpY2UoMCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIF9xdWV1ZSkge1xuICAgICAgaXRlbVswXS5fbG9nRm4oaXRlbVsxXSwgaXRlbVsyXSk7XG4gICAgfVxuICB9XG4gIG1vY2tUeXBlcyhtb2NrRm4pIHtcbiAgICBjb25zdCBfbW9ja0ZuID0gbW9ja0ZuIHx8IHRoaXMub3B0aW9ucy5tb2NrRm47XG4gICAgdGhpcy5fbW9ja0ZuID0gX21vY2tGbjtcbiAgICBpZiAodHlwZW9mIF9tb2NrRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdGhpcy5vcHRpb25zLnR5cGVzKSB7XG4gICAgICB0aGlzW3R5cGVdID0gX21vY2tGbih0eXBlLCB0aGlzLm9wdGlvbnMudHlwZXNbdHlwZV0pIHx8IHRoaXNbdHlwZV07XG4gICAgICB0aGlzW3R5cGVdLnJhdyA9IHRoaXNbdHlwZV07XG4gICAgfVxuICB9XG4gIF93cmFwTG9nRm4oZGVmYXVsdHMsIGlzUmF3KSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goW3RoaXMsIGRlZmF1bHRzLCBhcmdzLCBpc1Jhd10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9nRm4oZGVmYXVsdHMsIGFyZ3MsIGlzUmF3KTtcbiAgICB9O1xuICB9XG4gIF9sb2dGbihkZWZhdWx0cywgYXJncywgaXNSYXcpIHtcbiAgICBpZiAoKGRlZmF1bHRzLmxldmVsIHx8IDApID4gdGhpcy5sZXZlbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsb2dPYmogPSB7XG4gICAgICBkYXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIGFyZ3M6IFtdLFxuICAgICAgLi4uZGVmYXVsdHMsXG4gICAgICBsZXZlbDogX25vcm1hbGl6ZUxvZ0xldmVsKGRlZmF1bHRzLmxldmVsLCB0aGlzLm9wdGlvbnMudHlwZXMpXG4gICAgfTtcbiAgICBpZiAoIWlzUmF3ICYmIGFyZ3MubGVuZ3RoID09PSAxICYmIGlzTG9nT2JqKGFyZ3NbMF0pKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGxvZ09iaiwgYXJnc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ09iai5hcmdzID0gWy4uLmFyZ3NdO1xuICAgIH1cbiAgICBpZiAobG9nT2JqLm1lc3NhZ2UpIHtcbiAgICAgIGxvZ09iai5hcmdzLnVuc2hpZnQobG9nT2JqLm1lc3NhZ2UpO1xuICAgICAgZGVsZXRlIGxvZ09iai5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAobG9nT2JqLmFkZGl0aW9uYWwpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsb2dPYmouYWRkaXRpb25hbCkpIHtcbiAgICAgICAgbG9nT2JqLmFkZGl0aW9uYWwgPSBsb2dPYmouYWRkaXRpb25hbC5zcGxpdChcIlxcblwiKTtcbiAgICAgIH1cbiAgICAgIGxvZ09iai5hcmdzLnB1c2goXCJcXG5cIiArIGxvZ09iai5hZGRpdGlvbmFsLmpvaW4oXCJcXG5cIikpO1xuICAgICAgZGVsZXRlIGxvZ09iai5hZGRpdGlvbmFsO1xuICAgIH1cbiAgICBsb2dPYmoudHlwZSA9IHR5cGVvZiBsb2dPYmoudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGxvZ09iai50eXBlLnRvTG93ZXJDYXNlKCkgOiBcImxvZ1wiO1xuICAgIGxvZ09iai50YWcgPSB0eXBlb2YgbG9nT2JqLnRhZyA9PT0gXCJzdHJpbmdcIiA/IGxvZ09iai50YWcgOiBcIlwiO1xuICAgIGNvbnN0IHJlc29sdmVMb2cgPSAobmV3TG9nID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHJlcGVhdGVkID0gKHRoaXMuX2xhc3RMb2cuY291bnQgfHwgMCkgLSB0aGlzLm9wdGlvbnMudGhyb3R0bGVNaW47XG4gICAgICBpZiAodGhpcy5fbGFzdExvZy5vYmplY3QgJiYgcmVwZWF0ZWQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MyID0gWy4uLnRoaXMuX2xhc3RMb2cub2JqZWN0LmFyZ3NdO1xuICAgICAgICBpZiAocmVwZWF0ZWQgPiAxKSB7XG4gICAgICAgICAgYXJnczIucHVzaChgKHJlcGVhdGVkICR7cmVwZWF0ZWR9IHRpbWVzKWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZyh7IC4uLnRoaXMuX2xhc3RMb2cub2JqZWN0LCBhcmdzOiBhcmdzMiB9KTtcbiAgICAgICAgdGhpcy5fbGFzdExvZy5jb3VudCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAobmV3TG9nKSB7XG4gICAgICAgIHRoaXMuX2xhc3RMb2cub2JqZWN0ID0gbG9nT2JqO1xuICAgICAgICB0aGlzLl9sb2cobG9nT2JqKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9sYXN0TG9nLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpZmZUaW1lID0gdGhpcy5fbGFzdExvZy50aW1lICYmIGxvZ09iai5kYXRlID8gbG9nT2JqLmRhdGUuZ2V0VGltZSgpIC0gdGhpcy5fbGFzdExvZy50aW1lLmdldFRpbWUoKSA6IDA7XG4gICAgdGhpcy5fbGFzdExvZy50aW1lID0gbG9nT2JqLmRhdGU7XG4gICAgaWYgKGRpZmZUaW1lIDwgdGhpcy5vcHRpb25zLnRocm90dGxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkTG9nID0gSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgIGxvZ09iai50eXBlLFxuICAgICAgICAgIGxvZ09iai50YWcsXG4gICAgICAgICAgbG9nT2JqLmFyZ3NcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGlzU2FtZUxvZyA9IHRoaXMuX2xhc3RMb2cuc2VyaWFsaXplZCA9PT0gc2VyaWFsaXplZExvZztcbiAgICAgICAgdGhpcy5fbGFzdExvZy5zZXJpYWxpemVkID0gc2VyaWFsaXplZExvZztcbiAgICAgICAgaWYgKGlzU2FtZUxvZykge1xuICAgICAgICAgIHRoaXMuX2xhc3RMb2cuY291bnQgPSAodGhpcy5fbGFzdExvZy5jb3VudCB8fCAwKSArIDE7XG4gICAgICAgICAgaWYgKHRoaXMuX2xhc3RMb2cuY291bnQgPiB0aGlzLm9wdGlvbnMudGhyb3R0bGVNaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RMb2cudGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgIHJlc29sdmVMb2csXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aHJvdHRsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlTG9nKHRydWUpO1xuICB9XG4gIF9sb2cobG9nT2JqKSB7XG4gICAgZm9yIChjb25zdCByZXBvcnRlciBvZiB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzKSB7XG4gICAgICByZXBvcnRlci5sb2cobG9nT2JqLCB7XG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplTG9nTGV2ZWwoaW5wdXQsIHR5cGVzID0ge30sIGRlZmF1bHRMZXZlbCA9IDMpIHtcbiAgaWYgKGlucHV0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZGVmYXVsdExldmVsO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cbiAgaWYgKHR5cGVzW2lucHV0XSAmJiB0eXBlc1tpbnB1dF0ubGV2ZWwgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0eXBlc1tpbnB1dF0ubGV2ZWw7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbn1cbkNvbnNvbGEucHJvdG90eXBlLmFkZCA9IENvbnNvbGEucHJvdG90eXBlLmFkZFJlcG9ydGVyO1xuQ29uc29sYS5wcm90b3R5cGUucmVtb3ZlID0gQ29uc29sYS5wcm90b3R5cGUucmVtb3ZlUmVwb3J0ZXI7XG5Db25zb2xhLnByb3RvdHlwZS5jbGVhciA9IENvbnNvbGEucHJvdG90eXBlLnJlbW92ZVJlcG9ydGVyO1xuQ29uc29sYS5wcm90b3R5cGUud2l0aFNjb3BlID0gQ29uc29sYS5wcm90b3R5cGUud2l0aFRhZztcbkNvbnNvbGEucHJvdG90eXBlLm1vY2sgPSBDb25zb2xhLnByb3RvdHlwZS5tb2NrVHlwZXM7XG5Db25zb2xhLnByb3RvdHlwZS5wYXVzZSA9IENvbnNvbGEucHJvdG90eXBlLnBhdXNlTG9ncztcbkNvbnNvbGEucHJvdG90eXBlLnJlc3VtZSA9IENvbnNvbGEucHJvdG90eXBlLnJlc3VtZUxvZ3M7XG5mdW5jdGlvbiBjcmVhdGVDb25zb2xhKG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbmV3IENvbnNvbGEob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IENvbnNvbGEsIExvZ0xldmVscywgTG9nVHlwZXMsIGNyZWF0ZUNvbnNvbGEgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVDb25zb2xhIGFzIGNyZWF0ZUNvbnNvbGEkMSB9IGZyb20gJy4vY29yZS5tanMnO1xuZXhwb3J0IHsgQ29uc29sYSwgTG9nTGV2ZWxzLCBMb2dUeXBlcyB9IGZyb20gJy4vY29yZS5tanMnO1xuXG5jbGFzcyBCcm93c2VyUmVwb3J0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgdGhpcy5kZWZhdWx0Q29sb3IgPSBcIiM3ZjhjOGRcIjtcbiAgICB0aGlzLmxldmVsQ29sb3JNYXAgPSB7XG4gICAgICAwOiBcIiNjMDM5MmJcIixcbiAgICAgIC8vIFJlZFxuICAgICAgMTogXCIjZjM5YzEyXCIsXG4gICAgICAvLyBZZWxsb3dcbiAgICAgIDM6IFwiIzAwQkNENFwiXG4gICAgICAvLyBDeWFuXG4gICAgfTtcbiAgICB0aGlzLnR5cGVDb2xvck1hcCA9IHtcbiAgICAgIHN1Y2Nlc3M6IFwiIzJlY2M3MVwiXG4gICAgICAvLyBHcmVlblxuICAgIH07XG4gIH1cbiAgX2dldExvZ0ZuKGxldmVsKSB7XG4gICAgaWYgKGxldmVsIDwgMSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuX19lcnJvciB8fCBjb25zb2xlLmVycm9yO1xuICAgIH1cbiAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLl9fd2FybiB8fCBjb25zb2xlLndhcm47XG4gICAgfVxuICAgIHJldHVybiBjb25zb2xlLl9fbG9nIHx8IGNvbnNvbGUubG9nO1xuICB9XG4gIGxvZyhsb2dPYmopIHtcbiAgICBjb25zdCBjb25zb2xlTG9nRm4gPSB0aGlzLl9nZXRMb2dGbihsb2dPYmoubGV2ZWwpO1xuICAgIGNvbnN0IHR5cGUgPSBsb2dPYmoudHlwZSA9PT0gXCJsb2dcIiA/IFwiXCIgOiBsb2dPYmoudHlwZTtcbiAgICBjb25zdCB0YWcgPSBsb2dPYmoudGFnIHx8IFwiXCI7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLnR5cGVDb2xvck1hcFtsb2dPYmoudHlwZV0gfHwgdGhpcy5sZXZlbENvbG9yTWFwW2xvZ09iai5sZXZlbF0gfHwgdGhpcy5kZWZhdWx0Q29sb3I7XG4gICAgY29uc3Qgc3R5bGUgPSBgXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9yfTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDAuNWVtO1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBwYWRkaW5nOiAycHggMC41ZW07XG4gICAgYDtcbiAgICBjb25zdCBiYWRnZSA9IGAlYyR7W3RhZywgdHlwZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCI6XCIpfWA7XG4gICAgaWYgKHR5cGVvZiBsb2dPYmouYXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc29sZUxvZ0ZuKFxuICAgICAgICBgJHtiYWRnZX0lYyAke2xvZ09iai5hcmdzWzBdfWAsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICAvLyBFbXB0eSBzdHJpbmcgYXMgc3R5bGUgcmVzZXRzIHRvIGRlZmF1bHQgY29uc29sZSBzdHlsZVxuICAgICAgICBcIlwiLFxuICAgICAgICAuLi5sb2dPYmouYXJncy5zbGljZSgxKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZUxvZ0ZuKGJhZGdlLCBzdHlsZSwgLi4ubG9nT2JqLmFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb25zb2xhKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjb25zb2xhMiA9IGNyZWF0ZUNvbnNvbGEkMSh7XG4gICAgcmVwb3J0ZXJzOiBvcHRpb25zLnJlcG9ydGVycyB8fCBbbmV3IEJyb3dzZXJSZXBvcnRlcih7fSldLFxuICAgIHByb21wdChtZXNzYWdlLCBvcHRpb25zMiA9IHt9KSB7XG4gICAgICBpZiAob3B0aW9uczIudHlwZSA9PT0gXCJjb25maXJtXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb25maXJtKG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvbXB0KG1lc3NhZ2UpKTtcbiAgICB9LFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBjb25zb2xhMjtcbn1cbmNvbnN0IGNvbnNvbGEgPSBjcmVhdGVDb25zb2xhKCk7XG5cbmV4cG9ydCB7IGNvbnNvbGEsIGNyZWF0ZUNvbnNvbGEsIGNvbnNvbGEgYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IFBMVUdJTl9OQU1FIH0gZnJvbSBcIkAvdXRpbHMvY29uc3RhbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBMb2dMZXZlbHMsIGNvbnNvbGEgfSBmcm9tIFwiY29uc29sYVwiO1xyXG5cclxuY29uc3QgbG9nZ2VyID0gY29uc29sYS5jcmVhdGUoeyBsZXZlbDogTG9nTGV2ZWxzLmRlYnVnIH0pLndpdGhUYWcoUExVR0lOX05BTUUpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbG9nZ2VyO1xyXG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY29uc3Qgbm90aWZ5VXNlckFib3V0RmFpbHVyZSA9IChtZXNzYWdlOiBzdHJpbmcpID0+XHJcblx0bmV3IE5vdGljZShgRkFUQUw6ICR7bWVzc2FnZX1gKTtcclxuIiwgImltcG9ydCB7IEdpdFNlcnZpY2UgfSBmcm9tIFwiQC9zZXJ2aWNlcy9naXRTZXJ2aWNlXCI7XHJcbmltcG9ydCB7IEdpdGlnbm9yZVNlcnZpY2UgfSBmcm9tIFwiQC9zZXJ2aWNlcy9naXRpZ25vcmVTZXJ2aWNlXCI7XHJcbmltcG9ydCBsb2dnZXIgZnJvbSBcIkAvdXRpbHMvbG9nZ2VyXCI7XHJcbmltcG9ydCB7IG5vdGlmeVVzZXJBYm91dEZhaWx1cmUgfSBmcm9tIFwiQC91dGlscy9ub3RpZmllclwiO1xyXG5cclxuaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW5jQ29udHJvbGxlciB7XHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRwcml2YXRlIGdpdFNlcnZpY2U6IEdpdFNlcnZpY2UsXHJcblx0XHRwcml2YXRlIGdpdGlnbm9yZVNlcnZpY2U6IEdpdGlnbm9yZVNlcnZpY2VcclxuXHQpIHtcclxuXHRcdGxvZ2dlci5kZWJ1ZyhcIkluaXRpYWxpemVkIHN5bmMgY29udHJvbGxlci5cIik7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGNyZWF0ZVZhdWx0QmFja3VwKCkge1xyXG5cdFx0aWYgKGF3YWl0IHRoaXMuZ2l0U2VydmljZS51bnN0YWdlZENoYW5nZXNFeGlzdCgpKSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuaGFuZGxlVW5zdGFnZWRDaGFuZ2VzKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsb2dnZXIuaW5mbyhcIk5vIGNoYW5nZXMgaW4gdmF1bHQgZGV0ZWN0ZWQgZm9yIGJhY2t1cC9zeW5jLlwiKTtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmdpdFNlcnZpY2UuZ2l0UHVzaFVwc3RyZWFtKCk7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuZ2l0U2VydmljZS5naXRQdWxsKCk7XHJcblx0XHRcdFx0fSBjYXRjaCB7XHJcblx0XHRcdFx0XHQvLyBub3RpZnlVc2VyQWJvdXRGYWlsdXJlKFwiRmFpbGVkIHRvIHN5bmMgd2l0aCByZW1vdGVcIik7XHJcblxyXG5cdFx0XHRcdFx0bG9nZ2VyLmVycm9yKFwiUHVsbCBmYWlsZWQuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0XHRsb2dnZXIud2FybihcIkZhaWxlZCB0byBwdXNoIGJyYW5jaCB1cHN0cmVhbVwiKTtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5naXRTZXJ2aWNlLmdpdFB1bGwoKTtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuZ2l0U2VydmljZS5naXRQdXNoVXBzdHJlYW0oKTtcclxuXHJcblx0XHRcdFx0XHQvLyB0aGlzLm5vdGlmeVVzZXJBYm91dEJhY2t1cCgpO1xyXG5cclxuXHRcdFx0XHRcdGxvZ2dlci5zdWNjZXNzKFwiU3luY2VkIGxvY2FsIGFuZCByZW1vdGUuXCIpO1xyXG5cdFx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdFx0bm90aWZ5VXNlckFib3V0RmFpbHVyZShcIkZhaWxlZCB0byBzeW5jIHdpdGggcmVtb3RlXCIpO1xyXG5cclxuXHRcdFx0XHRcdGxvZ2dlci5lcnJvcihcIlB1bGwgYW5kIHVwc3RyZWFtIGZhaWxlZC5cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF3YWl0IHRoaXMuZ2l0U2VydmljZS5pc0xvY2FsQWhlYWQoKSkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmhhbmRsZUxvY2FsQWhlYWQoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgaGFuZGxlTG9jYWxBaGVhZCgpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuZ2l0U2VydmljZS5naXRQdXNoKCk7XHJcblxyXG5cdFx0XHR0aGlzLm5vdGlmeVVzZXJBYm91dEJhY2t1cCgpO1xyXG5cdFx0fSBjYXRjaCB7XHJcblx0XHRcdGxvZ2dlci53YXJuKFwiUmVtb3RlIGFuZCBsb2NhbCBoYXZlIGNvbmZsaWN0aW5nIGNoYW5nZXMhXCIpO1xyXG5cdFx0XHRsb2dnZXIuaW5mbyhcIlN0YXJ0aW5nIHJlYmFzZSBwcm9jZXNzLi4uXCIpO1xyXG5cclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmdpdFNlcnZpY2UuZ2l0UHVsbFdpdGhSZWJhc2UoKTtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmdpdFNlcnZpY2UuZ2l0UHVzaCgpO1xyXG5cclxuXHRcdFx0XHR0aGlzLm5vdGlmeVVzZXJBYm91dEJhY2t1cCgpO1xyXG5cclxuXHRcdFx0XHRsb2dnZXIuc3VjY2VzcyhcIkNyZWF0ZWQgdmF1bHQgc3luYy5cIik7XHJcblx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdHRoaXMubm90aWZ5VXNlckFib3V0Q29uZmxpY3RzKCk7XHJcblxyXG5cdFx0XHRcdGxvZ2dlci5lcnJvcihcIkF1dG9tYXRpYyByZWJhc2luZyBmYWlsZWQuXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZVVuc3RhZ2VkQ2hhbmdlcygpIHtcclxuXHRcdGxvZ2dlci5pbmZvKFwiVW5zdGFnZWQgY2hhbmdlcyBkZXRlY3RlZC4gU3luY3Jvbml6aW5nLi4uXCIpO1xyXG5cclxuXHRcdGF3YWl0IHRoaXMuZ2l0U2VydmljZS5naXRTdGFnZUFsbCgpO1xyXG5cdFx0YXdhaXQgdGhpcy5naXRTZXJ2aWNlLmdpdENvbW1pdCgpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBub3RpZnlVc2VyQWJvdXRCYWNrdXAoKSB7XHJcblx0XHRuZXcgTm90aWNlKFwiU3VjY2Vzc2Z1bGx5IHN5bmNlZCB1cCB2YXVsdCFcIik7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG5vdGlmeVVzZXJBYm91dENvbmZsaWN0cygpIHtcclxuXHRcdG5ldyBOb3RpY2UoXHJcblx0XHRcdFwiWW91ciBsb2NhbCBhbmQgcmVtb3RlIHJlcG9zaXRvcmllcyBoYWQgY29uZmxpY3RpbmcgY2hhbmdlcy5cIlxyXG5cdFx0KTtcclxuXHRcdG5ldyBOb3RpY2UoXHJcblx0XHRcdFwiUGxlYXNlIGZpeCB0aGUgY2hhbmdlcyBhbmQgdGhlbiBjbGljayB0aGUgc3luYyBidXR0b24gYWdhaW4uXCJcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzeW5jKCkge1xyXG5cdFx0aWYgKGF3YWl0IHRoaXMuZ2l0U2VydmljZS5pc1JlcG8oKSkge1xyXG5cdFx0XHRsb2dnZXIuZGVidWcoXCJWYXVsdCBpcyBpbml0aWFsaXplZCBhcyBhIEdpdCByZXBvc2l0b3J5LlwiKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxvZ2dlci5mYXRhbChcIlZhdWx0IGlzIG5vdCBpbml0aWFsaXplZCBhcyBhIEdpdCByZXBvc2l0b3J5LlwiKTtcclxuXHRcdFx0bm90aWZ5VXNlckFib3V0RmFpbHVyZShcIlZhdWx0IGlzIG5vdCBhIEdpdCByZXBvc2l0b3J5LlwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhd2FpdCB0aGlzLmdpdFNlcnZpY2UuaXNSZW1vdGVDb25maWd1cmVkKCkpIHtcclxuXHRcdFx0bG9nZ2VyLmRlYnVnKFwiUmVtb3RlIHJlcG9zaXRvcnkgaXMgY29uZmlndXJlZC5cIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsb2dnZXIuZmF0YWwoXCJSZW1vdGUgcmVwb3NpdG9yeSBpcyBub3QgY29uZmlndXJlZC5cIik7XHJcblx0XHRcdG5vdGlmeVVzZXJBYm91dEZhaWx1cmUoXCJSZW1vdGUgcmVwb3NpdG9yeSBpcyBub3QgY29uZmlndXJlZC5cIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXdhaXQgdGhpcy5naXRTZXJ2aWNlLmlzUmViYXNpbmcoKSkge1xyXG5cdFx0XHRsb2dnZXIuZGVidWcoXCJTdG9wcGluZyBpbiBwcm9ncmVzcyByZWJhc2UuXCIpO1xyXG5cclxuXHRcdFx0YXdhaXQgdGhpcy5naXRTZXJ2aWNlLnN0b3BSZWJhc2luZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGF3YWl0IHRoaXMuY3JlYXRlVmF1bHRCYWNrdXAoKTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCBsb2dnZXIgZnJvbSBcIkAvdXRpbHMvbG9nZ2VyXCI7XHJcbmltcG9ydCB7IFlhb3NTZXR0aW5ncyB9IGZyb20gXCJAL3ZpZXdzL3NldHRpbmdzVGFiXCI7XHJcblxyXG5pbXBvcnQgZGF5anMgZnJvbSBcImRheWpzXCI7XHJcbmltcG9ydCBzaW1wbGVHaXQsIHsgU2ltcGxlR2l0IH0gZnJvbSBcInNpbXBsZS1naXRcIjtcclxuXHJcbmNvbnN0IERFRkFVTFRfUkVNT1RFID0gXCJvcmlnaW5cIjtcclxuXHJcbmNvbnN0IENVUlJFTlRfVElNRSA9ICgpID0+IGRheWpzKCkuZm9ybWF0KFwiWVlZWS1NTS1ERFRISDptbVwiKTtcclxuY29uc3QgQ09NTUlUX01FU1NBR0UgPSAoZGV2aWNlTmFtZTogc3RyaW5nKSA9PlxyXG5cdGBjaG9yZTogdmF1bHQgYmFja3VwIGZyb20gJHtkZXZpY2VOYW1lfSBhdCAke0NVUlJFTlRfVElNRSgpfWA7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdpdFNlcnZpY2Uge1xyXG5cdHNldHRpbmdzOiBZYW9zU2V0dGluZ3M7XHJcblxyXG5cdGdpdENvbW1pdChtZXNzYWdlPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcclxuXHRnaXRQdWxsV2l0aFJlYmFzZSgpOiBQcm9taXNlPHZvaWQ+O1xyXG5cdGdpdFB1bGwoYnJhbmNoPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcclxuXHRnaXRQdXNoVXBzdHJlYW0oYnJhbmNoPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcclxuXHRnaXRQdXNoKGZvcmNlUHVzaD86IGJvb2xlYW4sIGJyYW5jaD86IHN0cmluZyk6IFByb21pc2U8dm9pZD47XHJcblx0Z2l0U3RhZ2UoLi4uZmlsZXM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPjtcclxuXHRnaXRTdGFnZUFsbCgpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuXHRpc0xvY2FsQWhlYWQoKTogUHJvbWlzZTxib29sZWFuPjtcclxuXHRpc1JlYmFzaW5nKCk6IFByb21pc2U8Ym9vbGVhbj47XHJcblx0aXNSZW1vdGVDb25maWd1cmVkKCk6IFByb21pc2U8Ym9vbGVhbj47XHJcblx0aXNSZXBvKCk6IFByb21pc2U8Ym9vbGVhbj47XHJcblxyXG5cdGdldENvbmZsaWN0aW5nRmlsZXMoKTogUHJvbWlzZTxzdHJpbmdbXT47XHJcblx0c3RvcFJlYmFzaW5nKCk6IFByb21pc2U8dm9pZD47XHJcblx0dW5zdGFnZWRDaGFuZ2VzRXhpc3QoKTogUHJvbWlzZTxib29sZWFuPjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNpbXBsZUdpdFNlcnZpY2UgaW1wbGVtZW50cyBHaXRTZXJ2aWNlIHtcclxuXHRwcml2YXRlIGdpdFByb3ZpZGVyOiBTaW1wbGVHaXQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHJlcG9QYXRoOiBzdHJpbmcsIHB1YmxpYyBzZXR0aW5nczogWWFvc1NldHRpbmdzKSB7XHJcblx0XHRsb2dnZXIuZGVidWcoXCJJbml0aWFsaXppbmcgU2ltcGxlR2l0U2VydmljZS4uLlwiKTtcclxuXHRcdHRoaXMuZ2l0UHJvdmlkZXIgPSBzaW1wbGVHaXQocmVwb1BhdGgpO1xyXG5cdFx0bG9nZ2VyLmRlYnVnKFwiU2ltcGxlR2l0U2VydmljZSBpbml0aWFsaXplZC5cIik7XHJcblx0fVxyXG5cclxuXHRhc3luYyBnaXRDb21taXQobWVzc2FnZSA9IENPTU1JVF9NRVNTQUdFKHRoaXMuc2V0dGluZ3MuZGV2aWNlTmFtZSkpIHtcclxuXHRcdGxvZ2dlci5pbmZvKGBDb21taXR0aW5nLi4uICR7bWVzc2FnZX1gKTtcclxuXHJcblx0XHRhd2FpdCB0aGlzLmdpdFByb3ZpZGVyLmNvbW1pdChtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGdpdFB1bGxXaXRoUmViYXNlKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5naXRQcm92aWRlci5wdWxsKFtcIi0tcmViYXNlXCJdKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGdpdFB1bGwoYnJhbmNoID0gdGhpcy5zZXR0aW5ncy5icmFuY2hOYW1lKSB7XHJcblx0XHRhd2FpdCB0aGlzLmdpdFByb3ZpZGVyLnB1bGwoREVGQVVMVF9SRU1PVEUsIGJyYW5jaCwgW1wiLS1yZWJhc2VcIl0pO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgZ2l0UHVzaFVwc3RyZWFtKGJyYW5jaCA9IHRoaXMuc2V0dGluZ3MuYnJhbmNoTmFtZSkge1xyXG5cdFx0YXdhaXQgdGhpcy5naXRQcm92aWRlci5wdXNoKERFRkFVTFRfUkVNT1RFLCBicmFuY2gsIFtcclxuXHRcdFx0XCItLXNldC11cHN0cmVhbVwiLFxyXG5cdFx0XHRcIi0tZm9yY2VcIixcclxuXHRcdF0pO1xyXG5cclxuXHRcdGxvZ2dlci5pbmZvKGBQdXNoZWQgYnJhbmNoIHVwc3RyZWFtIHRvICR7REVGQVVMVF9SRU1PVEV9LyR7YnJhbmNofS5gKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGdpdFB1c2goZm9yY2VQdXNoID0gZmFsc2UsIGJyYW5jaCA9IHRoaXMuc2V0dGluZ3MuYnJhbmNoTmFtZSkge1xyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IGZvcmNlUHVzaCA/IFtcIi1mXCJdIDogW107XHJcblxyXG5cdFx0YXdhaXQgdGhpcy5naXRQcm92aWRlci5wdXNoKERFRkFVTFRfUkVNT1RFLCBicmFuY2gsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGxvZ2dlci5pbmZvKGBQdXNoZWQgY2hhbmdlcyB0byAke0RFRkFVTFRfUkVNT1RFfS8ke2JyYW5jaH0uYCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBnaXRTdGFnZSguLi5maWxlczogc3RyaW5nW10pIHtcclxuXHRcdGF3YWl0IFByb21pc2UuYWxsKGZpbGVzLm1hcCgoZmlsZSkgPT4gdGhpcy5naXRQcm92aWRlci5hZGQoZmlsZSkpKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGdpdFN0YWdlQWxsKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5naXRQcm92aWRlci5hZGQoXCIuLypcIik7XHJcblx0fVxyXG5cclxuXHRhc3luYyBpc0xvY2FsQWhlYWQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5naXRQcm92aWRlci5zdGF0dXMoKS50aGVuKChzdGF0dXMpID0+IHN0YXR1cy5haGVhZCA+IDApO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgaXNSZWJhc2luZygpIHtcclxuXHRcdHJldHVybiB0aGlzLmdpdFByb3ZpZGVyXHJcblx0XHRcdC5yYXcoW1wic3RhdHVzXCJdKVxyXG5cdFx0XHQudGhlbigoc3RhdHVzKSA9PiBzdGF0dXMuaW5jbHVkZXMoXCJyZWJhc2VcIikpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgaXNSZW1vdGVDb25maWd1cmVkKCkge1xyXG5cdFx0bGV0IHJlbW90ZUNvbmZpZ3VyZWQgPSBmYWxzZTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCByZW1vdGVzID0gYXdhaXQgdGhpcy5naXRQcm92aWRlci5saXN0UmVtb3RlKFtcIi0tZ2V0LXVybFwiXSk7XHJcblx0XHRcdHJlbW90ZUNvbmZpZ3VyZWQgPSAhIXJlbW90ZXM7XHJcblx0XHR9IGNhdGNoIHtcclxuXHRcdFx0cmVtb3RlQ29uZmlndXJlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZW1vdGVDb25maWd1cmVkO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgaXNSZXBvKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2l0UHJvdmlkZXIuY2hlY2tJc1JlcG8oKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGdldENvbmZsaWN0aW5nRmlsZXMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5naXRQcm92aWRlci5zdGF0dXMoKS50aGVuKChzdGF0dXMpID0+IHN0YXR1cy5jb25mbGljdGVkKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHN0b3BSZWJhc2luZygpIHtcclxuXHRcdHByb2Nlc3MuZW52LkdJVF9FRElUT1IgPSBcInRydWVcIjtcclxuXHJcblx0XHRhd2FpdCB0aGlzLmdpdFN0YWdlQWxsKCk7XHJcblx0XHRhd2FpdCB0aGlzLmdpdFByb3ZpZGVyLnJlYmFzZShbXCItLWNvbnRpbnVlXCJdKTtcclxuXHRcdGF3YWl0IHRoaXMuZ2l0UHVzaCgpO1xyXG5cclxuXHRcdHByb2Nlc3MuZW52LkdJVF9FRElUT1IgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRhc3luYyB1bnN0YWdlZENoYW5nZXNFeGlzdCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdpdFByb3ZpZGVyXHJcblx0XHRcdC5zdGF0dXMoKVxyXG5cdFx0XHQudGhlbihcclxuXHRcdFx0XHQoc3RhdHVzKSA9PlxyXG5cdFx0XHRcdFx0c3RhdHVzLmZpbGVzLmxlbmd0aCA+IDAgfHwgc3RhdHVzLm5vdF9hZGRlZC5sZW5ndGggPiAwXHJcblx0XHRcdCk7XHJcblx0fVxyXG59XHJcbiIsICJjb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwPFN0cmluZywgc3RyaW5nW10+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoc3BlYyguLi5wYXRoczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGtleSA9IG5ldyBTdHJpbmcocGF0aHMpO1xuICAgY2FjaGUuc2V0KGtleSwgcGF0aHMpO1xuXG4gICByZXR1cm4ga2V5IGFzIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aFNwZWMocGF0aDogc3RyaW5nIHwgdW5rbm93bik6IHBhdGggaXMgc3RyaW5nIHtcbiAgIHJldHVybiBwYXRoIGluc3RhbmNlb2YgU3RyaW5nICYmIGNhY2hlLmhhcyhwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUGF0aHMocGF0aFNwZWM6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBjYWNoZS5nZXQocGF0aFNwZWMpIHx8IFtdO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgYEdpdEVycm9yYCBpcyB0aHJvd24gd2hlbiB0aGUgdW5kZXJseWluZyBgZ2l0YCBwcm9jZXNzIHRocm93cyBhXG4gKiBmYXRhbCBleGNlcHRpb24gKGVnIGFuIGBFTk9FTlRgIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gdXNlIGFcbiAqIG5vbi13cml0YWJsZSBkaXJlY3RvcnkgYXMgdGhlIHJvb3QgZm9yIHlvdXIgcmVwbyksIGFuZCBhY3RzIGFzIHRoZVxuICogYmFzZSBjbGFzcyBmb3IgbW9yZSBzcGVjaWZpYyBlcnJvcnMgdGhyb3duIGJ5IHRoZSBwYXJzaW5nIG9mIHRoZVxuICogZ2l0IHJlc3BvbnNlIG9yIGVycm9ycyBpbiB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFzayBhYm91dCB0b1xuICogYmUgcnVuLlxuICpcbiAqIFdoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93biwgcGVuZGluZyB0YXNrcyBpbiB0aGUgc2FtZSBpbnN0YW5jZSB3aWxsXG4gKiBub3QgYmUgZXhlY3V0ZWQuIFRoZSByZWNvbW1lbmRlZCB3YXkgdG8gcnVuIGEgc2VyaWVzIG9mIHRhc2tzIHRoYXRcbiAqIGNhbiBpbmRlcGVuZGVudGx5IGZhaWwgd2l0aG91dCBuZWVkaW5nIHRvIHByZXZlbnQgZnV0dXJlIHRhc2tzIGZyb21cbiAqIHJ1bm5pbmcgaXMgdG8gY2F0Y2ggdGhlbSBpbmRpdmlkdWFsbHk6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuIGltcG9ydCB7IGdpdFAsIFNpbXBsZUdpdCwgR2l0RXJyb3IsIFB1bGxSZXN1bHQgfSBmcm9tICdzaW1wbGUtZ2l0JztcblxuIGZ1bmN0aW9uIGNhdGNoVGFzayAoZTogR2l0RXJyb3IpIHtcbiAgIHJldHVybiBlLlxuIH1cblxuIGNvbnN0IGdpdCA9IGdpdFAocmVwb1dvcmtpbmdEaXIpO1xuIGNvbnN0IHB1bGxlZDogUHVsbFJlc3VsdCB8IEdpdEVycm9yID0gYXdhaXQgZ2l0LnB1bGwoKS5jYXRjaChjYXRjaFRhc2spO1xuIGNvbnN0IHB1c2hlZDogc3RyaW5nIHwgR2l0RXJyb3IgPSBhd2FpdCBnaXQucHVzaFRhZ3MoKS5jYXRjaChjYXRjaFRhc2spO1xuIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB0YXNrPzogU2ltcGxlR2l0VGFzazxhbnk+LFxuICAgICAgbWVzc2FnZT86IHN0cmluZ1xuICAgKSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2dpdC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBHaXRSZXNwb25zZUVycm9yYCBpcyB0aGUgd3JhcHBlciBmb3IgYSBwYXJzZWQgcmVzcG9uc2UgdGhhdCBpcyB0cmVhdGVkIGFzXG4gKiBhIGZhdGFsIGVycm9yLCBmb3IgZXhhbXBsZSBhdHRlbXB0aW5nIGEgYG1lcmdlYCBjYW4gbGVhdmUgdGhlIHJlcG8gaW4gYSBjb3JydXB0ZWRcbiAqIHN0YXRlIHdoZW4gdGhlcmUgYXJlIGNvbmZsaWN0cyBzbyB0aGUgdGFzayB3aWxsIHJlamVjdCByYXRoZXIgdGhhbiByZXNvbHZlLlxuICpcbiAqIEZvciBleGFtcGxlLCBjYXRjaGluZyB0aGUgbWVyZ2UgY29uZmxpY3QgZXhjZXB0aW9uOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiBpbXBvcnQgeyBnaXRQLCBTaW1wbGVHaXQsIEdpdFJlc3BvbnNlRXJyb3IsIE1lcmdlU3VtbWFyeSB9IGZyb20gJ3NpbXBsZS1naXQnO1xuXG4gY29uc3QgZ2l0ID0gZ2l0UChyZXBvUm9vdCk7XG4gY29uc3QgbWVyZ2VPcHRpb25zOiBzdHJpbmdbXSA9IFsnLS1uby1mZicsICdvdGhlci1icmFuY2gnXTtcbiBjb25zdCBtZXJnZVN1bW1hcnk6IE1lcmdlU3VtbWFyeSA9IGF3YWl0IGdpdC5tZXJnZShtZXJnZU9wdGlvbnMpXG4gICAgICAuY2F0Y2goKGU6IEdpdFJlc3BvbnNlRXJyb3I8TWVyZ2VTdW1tYXJ5PikgPT4gZS5naXQpO1xuXG4gaWYgKG1lcmdlU3VtbWFyeS5mYWlsZWQpIHtcbiAgIC8vIGRlYWwgd2l0aCB0aGUgZXJyb3JcbiB9XG4gYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRSZXNwb25zZUVycm9yPFQgPSBhbnk+IGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIGAuZ2l0YCBhY2Nlc3MgdGhlIHBhcnNlZCByZXNwb25zZSB0aGF0IGlzIHRyZWF0ZWQgYXMgYmVpbmcgYW4gZXJyb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdDogVCxcbiAgICAgIG1lc3NhZ2U/OiBzdHJpbmdcbiAgICkge1xuICAgICAgc3VwZXIodW5kZWZpbmVkLCBtZXNzYWdlIHx8IFN0cmluZyhnaXQpKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZ2l0LWVycm9yJztcblxuLyoqXG4gKiBUaGUgYFRhc2tDb25maWd1cmF0aW9uRXJyb3JgIGlzIHRocm93biB3aGVuIGEgY29tbWFuZCB3YXMgaW5jb3JyZWN0bHlcbiAqIGNvbmZpZ3VyZWQuIEFuIGVycm9yIG9mIHRoaXMga2luZCBtZWFucyB0aGF0IG5vIGF0dGVtcHQgd2FzIG1hZGUgdG9cbiAqIHJ1biB5b3VyIGNvbW1hbmQgdGhyb3VnaCB0aGUgdW5kZXJseWluZyBgZ2l0YCBiaW5hcnkuXG4gKlxuICogQ2hlY2sgdGhlIGAubWVzc2FnZWAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlsIG9uIHdoeSB5b3VyIGNvbmZpZ3VyYXRpb25cbiAqIHJlc3VsdGVkIGluIGFuIGVycm9yLlxuICovXG5leHBvcnQgY2xhc3MgVGFza0NvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEdpdEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgZXhpc3RzLCBGT0xERVIgfSBmcm9tICdAa3dzaXRlcy9maWxlLWV4aXN0cyc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IE5VTEwgPSAnXFwwJztcblxuZXhwb3J0IGNvbnN0IE5PT1A6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIFJldHVybnMgZWl0aGVyIHRoZSBzb3VyY2UgYXJndW1lbnQgd2hlbiBpdCBpcyBhIGBGdW5jdGlvbmAsIG9yIHRoZSBkZWZhdWx0XG4gKiBgTk9PUGAgZnVuY3Rpb24gY29uc3RhbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzRnVuY3Rpb248VCBleHRlbmRzICgpID0+IGFueT4oc291cmNlOiBUIHwgYW55KTogVCB7XG4gICByZXR1cm4gdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZSA6IE5PT1A7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdXBwbGllZCBhcmd1bWVudCBpcyBib3RoIGEgZnVuY3Rpb24sIGFuZCBpcyBub3RcbiAqIHRoZSBgTk9PUGAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJGdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb24+KHNvdXJjZTogVCB8IGFueSk6IHNvdXJjZSBpcyBUIHtcbiAgIHJldHVybiB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nICYmIHNvdXJjZSAhPT0gTk9PUDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T24oaW5wdXQ6IHN0cmluZywgY2hhcjogc3RyaW5nKTogW3N0cmluZywgc3RyaW5nXSB7XG4gICBjb25zdCBpbmRleCA9IGlucHV0LmluZGV4T2YoY2hhcik7XG4gICBpZiAoaW5kZXggPD0gMCkge1xuICAgICAgcmV0dXJuIFtpbnB1dCwgJyddO1xuICAgfVxuXG4gICByZXR1cm4gW2lucHV0LnN1YnN0cigwLCBpbmRleCksIGlucHV0LnN1YnN0cihpbmRleCArIDEpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQgZXh0ZW5kcyBhbnlbXT4oaW5wdXQ6IFQsIG9mZnNldD86IG51bWJlcik6IE1heWJlPFRbbnVtYmVyXT47XG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VCBleHRlbmRzIElBcmd1bWVudHM+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChpbnB1dDogYW55W10gfCBJQXJndW1lbnRzLCBvZmZzZXQgPSAwKTogTWF5YmU8dW5rbm93bj4ge1xuICAgcmV0dXJuIGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQgPyBpbnB1dFtvZmZzZXRdIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFzdDxUIGV4dGVuZHMgYW55W10+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTxUW251bWJlcl0+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCBleHRlbmRzIElBcmd1bWVudHM+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTx1bmtub3duPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGlucHV0OiB1bmtub3duLCBvZmZzZXQgPSAwKSB7XG4gICBpZiAoaXNBcnJheUxpa2UoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgcmV0dXJuIGlucHV0W2lucHV0Lmxlbmd0aCAtIDEgLSBvZmZzZXRdO1xuICAgfVxufVxuXG50eXBlIEFycmF5TGlrZTxUID0gYW55PiA9IFRbXSB8IElBcmd1bWVudHMgfCB7IFtpbmRleDogbnVtYmVyXTogVDsgbGVuZ3RoOiBudW1iZXIgfTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoaW5wdXQ6IGFueSk6IGlucHV0IGlzIEFycmF5TGlrZSB7XG4gICByZXR1cm4gISEoaW5wdXQgJiYgdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gJ251bWJlcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lc1dpdGhDb250ZW50KGlucHV0ID0gJycsIHRyaW1tZWQgPSB0cnVlLCBzZXBhcmF0b3IgPSAnXFxuJyk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBpbnB1dC5zcGxpdChzZXBhcmF0b3IpLnJlZHVjZSgob3V0cHV0LCBsaW5lKSA9PiB7XG4gICAgICBjb25zdCBsaW5lQ29udGVudCA9IHRyaW1tZWQgPyBsaW5lLnRyaW0oKSA6IGxpbmU7XG4gICAgICBpZiAobGluZUNvbnRlbnQpIHtcbiAgICAgICAgIG91dHB1dC5wdXNoKGxpbmVDb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICB9LCBbXSBhcyBzdHJpbmdbXSk7XG59XG5cbnR5cGUgTGluZVdpdGhDb250ZW50Q2FsbGJhY2s8VCA9IHZvaWQ+ID0gKGxpbmU6IHN0cmluZykgPT4gVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hMaW5lV2l0aENvbnRlbnQ8VD4oXG4gICBpbnB1dDogc3RyaW5nLFxuICAgY2FsbGJhY2s6IExpbmVXaXRoQ29udGVudENhbGxiYWNrPFQ+XG4pOiBUW10ge1xuICAgcmV0dXJuIHRvTGluZXNXaXRoQ29udGVudChpbnB1dCwgdHJ1ZSkubWFwKChsaW5lKSA9PiBjYWxsYmFjayhsaW5lKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb2xkZXJFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICByZXR1cm4gZXhpc3RzKHBhdGgsIEZPTERFUik7XG59XG5cbi8qKlxuICogQWRkcyBgaXRlbWAgaW50byB0aGUgYHRhcmdldGAgYEFycmF5YCBvciBgU2V0YCB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgYW5kIHJldHVybnMgdGhlIGBpdGVtYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZDxUPih0YXJnZXQ6IFRbXSB8IFNldDxUPiwgaXRlbTogVCk6IHR5cGVvZiBpdGVtIHtcbiAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIGlmICghdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICAgfVxuICAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQWRkcyBgaXRlbWAgaW50byB0aGUgYHRhcmdldGAgYEFycmF5YCB3aGVuIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQgYW5kIHJldHVybnMgdGhlIGB0YXJnZXRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jbHVkaW5nPFQ+KHRhcmdldDogVFtdLCBpdGVtOiBUKTogdHlwZW9mIHRhcmdldCB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmICF0YXJnZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgfVxuXG4gICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlPFQ+KHRhcmdldDogU2V0PFQ+IHwgVFtdLCBpdGVtOiBUKTogVCB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5kZWxldGUoaXRlbSk7XG4gICB9XG4gICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgYXMgKFxuICAgaW5wdXQ6IGFueVxuKSA9PiBzdHJpbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc0FycmF5PFQ+KHNvdXJjZTogVCB8IFRbXSk6IFRbXSB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1N0cmluZ0FycmF5PFQ+KHNvdXJjZTogVCB8IFRbXSk6IHN0cmluZ1tdIHtcbiAgIHJldHVybiBhc0FycmF5KHNvdXJjZSkubWFwKFN0cmluZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcihzb3VyY2U6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsIG9uTmFOID0gMCkge1xuICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb25OYU47XG4gICB9XG5cbiAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHNvdXJjZSwgMTApO1xuICAgcmV0dXJuIGlzTmFOKG51bSkgPyBvbk5hTiA6IG51bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeGVkQXJyYXk8VD4oaW5wdXQ6IFRbXSwgcHJlZml4OiBUKTogVFtdIHtcbiAgIGNvbnN0IG91dHB1dDogVFtdID0gW107XG4gICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5wdXQubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKHByZWZpeCwgaW5wdXRbaV0pO1xuICAgfVxuICAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGlucHV0OiBCdWZmZXIgfCBCdWZmZXJbXSk6IHN0cmluZyB7XG4gICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW5wdXQpID8gQnVmZmVyLmNvbmNhdChpbnB1dCkgOiBpbnB1dCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG59XG5cbi8qKlxuICogR2V0IGEgbmV3IG9iamVjdCBmcm9tIGEgc291cmNlIG9iamVjdCB3aXRoIG9ubHkgdGhlIGxpc3RlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGljayhzb3VyY2U6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BlcnRpZXM6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgLi4ucHJvcGVydGllcy5tYXAoKHByb3BlcnR5KSA9PiAocHJvcGVydHkgaW4gc291cmNlID8geyBbcHJvcGVydHldOiBzb3VyY2VbcHJvcGVydHldIH0gOiB7fSkpXG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24gPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHNldFRpbWVvdXQoZG9uZSwgZHVyYXRpb24pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yVm9pZDxUPihpbnB1dDogVCB8IGZhbHNlKSB7XG4gICBpZiAoaW5wdXQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfVxuICAgcmV0dXJuIGlucHV0O1xufVxuIiwgImltcG9ydCB7IE1heWJlLCBPcHRpb25zLCBQcmltaXRpdmVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgb2JqZWN0VG9TdHJpbmcgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgaXNQYXRoU3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPFQ+IHtcbiAgIChpbnB1dDogYW55KTogaW5wdXQgaXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oXG4gICBpbnB1dDogSyxcbiAgIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD5cbik6IEsgZXh0ZW5kcyBUID8gVCA6IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJUeXBlPFQsIEs+KGlucHV0OiBLLCBmaWx0ZXI6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPFQ+LCBkZWY6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oaW5wdXQ6IEssIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4sIGRlZj86IFQpOiBNYXliZTxUPiB7XG4gICBpZiAoZmlsdGVyKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgfVxuICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gZGVmIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPEFycmF5PGFueT4+ID0gKGlucHV0KTogaW5wdXQgaXMgQXJyYXk8YW55PiA9PiB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUHJpbWl0aXZlcyhcbiAgIGlucHV0OiB1bmtub3duLFxuICAgb21pdD86IEFycmF5PCdib29sZWFuJyB8ICdzdHJpbmcnIHwgJ251bWJlcic+XG4pOiBpbnB1dCBpcyBQcmltaXRpdmVzIHtcbiAgIGNvbnN0IHR5cGUgPSBpc1BhdGhTcGVjKGlucHV0KSA/ICdzdHJpbmcnIDogdHlwZW9mIGlucHV0O1xuXG4gICByZXR1cm4gKFxuICAgICAgL251bWJlcnxzdHJpbmd8Ym9vbGVhbi8udGVzdCh0eXBlKSAmJlxuICAgICAgKCFvbWl0IHx8ICFvbWl0LmluY2x1ZGVzKHR5cGUgYXMgJ2Jvb2xlYW4nIHwgJ3N0cmluZycgfCAnbnVtYmVyJykpXG4gICApO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVyU3RyaW5nOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmc+ID0gKGlucHV0KTogaW5wdXQgaXMgc3RyaW5nID0+IHtcbiAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbHRlclN0cmluZ0FycmF5OiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmdbXT4gPSAoaW5wdXQpOiBpbnB1dCBpcyBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5OiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxzdHJpbmcgfCBzdHJpbmdbXT4gPSAoXG4gICBpbnB1dFxuKTogaW5wdXQgaXMgc3RyaW5nIHwgc3RyaW5nW10gPT4ge1xuICAgcmV0dXJuIGZpbHRlclN0cmluZyhpbnB1dCkgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGZpbHRlclN0cmluZykpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0PFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCB8IHVua25vd24pOiBpbnB1dCBpcyBUO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0PFQgZXh0ZW5kcyBPYmplY3Q+KGlucHV0OiBUIHwgdW5rbm93bik6IGlucHV0IGlzIFQge1xuICAgcmV0dXJuICEhaW5wdXQgJiYgb2JqZWN0VG9TdHJpbmcoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uKGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgRnVuY3Rpb24ge1xuICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGNvbnN0IGZpbHRlckhhc0xlbmd0aDogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8eyBsZW5ndGg6IG51bWJlciB9PiA9IChcbiAgIGlucHV0XG4pOiBpbnB1dCBpcyB7IGxlbmd0aDogbnVtYmVyIH0gPT4ge1xuICAgaWYgKGlucHV0ID09IG51bGwgfHwgJ251bWJlcnxib29sZWFufGZ1bmN0aW9uJy5pbmNsdWRlcyh0eXBlb2YgaW5wdXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaW5wdXQubGVuZ3RoID09PSAnbnVtYmVyJztcbn07XG4iLCAiLyoqXG4gKiBLbm93biBwcm9jZXNzIGV4aXQgY29kZXMgdXNlZCBieSB0aGUgdGFzayBwYXJzZXJzIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGVycm9yXG4gKiB3YXMgb25lIHRoZXkgY2FuIGF1dG9tYXRpY2FsbHkgaGFuZGxlXG4gKi9cbmV4cG9ydCBlbnVtIEV4aXRDb2RlcyB7XG4gICBTVUNDRVNTLFxuICAgRVJST1IsXG4gICBOT1RfRk9VTkQgPSAtMixcbiAgIFVOQ0xFQU4gPSAxMjgsXG59XG4iLCAiaW1wb3J0IHsgVGFza1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgR2l0T3V0cHV0U3RyZWFtczxUIGV4dGVuZHMgVGFza1Jlc3BvbnNlRm9ybWF0ID0gQnVmZmVyPiB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBzdGRPdXQ6IFQsXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgc3RkRXJyOiBUXG4gICApIHt9XG5cbiAgIGFzU3RyaW5ncygpOiBHaXRPdXRwdXRTdHJlYW1zPHN0cmluZz4ge1xuICAgICAgcmV0dXJuIG5ldyBHaXRPdXRwdXRTdHJlYW1zKHRoaXMuc3RkT3V0LnRvU3RyaW5nKCd1dGY4JyksIHRoaXMuc3RkRXJyLnRvU3RyaW5nKCd1dGY4JykpO1xuICAgfVxufVxuIiwgImV4cG9ydCBjbGFzcyBMaW5lUGFyc2VyPFQ+IHtcbiAgIHByb3RlY3RlZCBtYXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICBwcml2YXRlIF9yZWdFeHA6IFJlZ0V4cFtdO1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHJlZ0V4cDogUmVnRXhwIHwgUmVnRXhwW10sXG4gICAgICB1c2VNYXRjaGVzPzogKHRhcmdldDogVCwgbWF0Y2g6IHN0cmluZ1tdKSA9PiBib29sZWFuIHwgdm9pZFxuICAgKSB7XG4gICAgICB0aGlzLl9yZWdFeHAgPSBBcnJheS5pc0FycmF5KHJlZ0V4cCkgPyByZWdFeHAgOiBbcmVnRXhwXTtcbiAgICAgIGlmICh1c2VNYXRjaGVzKSB7XG4gICAgICAgICB0aGlzLnVzZU1hdGNoZXMgPSB1c2VNYXRjaGVzO1xuICAgICAgfVxuICAgfVxuXG4gICBwYXJzZSA9IChsaW5lOiAob2Zmc2V0OiBudW1iZXIpID0+IHN0cmluZyB8IHVuZGVmaW5lZCwgdGFyZ2V0OiBUKTogYm9vbGVhbiA9PiB7XG4gICAgICB0aGlzLnJlc2V0TWF0Y2hlcygpO1xuXG4gICAgICBpZiAoIXRoaXMuX3JlZ0V4cC5ldmVyeSgocmVnLCBpbmRleCkgPT4gdGhpcy5hZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKGluZGV4KSkpKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVzZU1hdGNoZXModGFyZ2V0LCB0aGlzLnByZXBhcmVNYXRjaGVzKCkpICE9PSBmYWxzZTtcbiAgIH07XG5cbiAgIC8vIEB0cy1pZ25vcmVcbiAgIHByb3RlY3RlZCB1c2VNYXRjaGVzKHRhcmdldDogVCwgbWF0Y2g6IHN0cmluZ1tdKTogYm9vbGVhbiB8IHZvaWQge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lUGFyc2VyOnVzZU1hdGNoZXMgbm90IGltcGxlbWVudGVkYCk7XG4gICB9XG5cbiAgIHByb3RlY3RlZCByZXNldE1hdGNoZXMoKSB7XG4gICAgICB0aGlzLm1hdGNoZXMubGVuZ3RoID0gMDtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHByZXBhcmVNYXRjaGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgIH1cblxuICAgcHJvdGVjdGVkIGFkZE1hdGNoKHJlZzogUmVnRXhwLCBpbmRleDogbnVtYmVyLCBsaW5lPzogc3RyaW5nKSB7XG4gICAgICBjb25zdCBtYXRjaGVkID0gbGluZSAmJiByZWcuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICB0aGlzLnB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIW1hdGNoZWQ7XG4gICB9XG5cbiAgIHByb3RlY3RlZCBwdXNoTWF0Y2goX2luZGV4OiBudW1iZXIsIG1hdGNoZWQ6IHN0cmluZ1tdKSB7XG4gICAgICB0aGlzLm1hdGNoZXMucHVzaCguLi5tYXRjaGVkLnNsaWNlKDEpKTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlbW90ZUxpbmVQYXJzZXI8VD4gZXh0ZW5kcyBMaW5lUGFyc2VyPFQ+IHtcbiAgIHByb3RlY3RlZCBhZGRNYXRjaChyZWc6IFJlZ0V4cCwgaW5kZXg6IG51bWJlciwgbGluZT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIC9ecmVtb3RlOlxccy8udGVzdChTdHJpbmcobGluZSkpICYmIHN1cGVyLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgcHVzaE1hdGNoKGluZGV4OiBudW1iZXIsIG1hdGNoZWQ6IHN0cmluZ1tdKSB7XG4gICAgICBpZiAoaW5kZXggPiAwIHx8IG1hdGNoZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgc3VwZXIucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgIH1cbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogT21pdDxTaW1wbGVHaXRPcHRpb25zLCAnYmFzZURpcic+ID0ge1xuICAgYmluYXJ5OiAnZ2l0JyxcbiAgIG1heENvbmN1cnJlbnRQcm9jZXNzZXM6IDUsXG4gICBjb25maWc6IFtdLFxuICAgdHJpbW1lZDogZmFsc2UsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VDb25maWcoXG4gICAuLi5vcHRpb25zOiBBcnJheTxQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+IHwgdW5kZWZpbmVkPlxuKTogU2ltcGxlR2l0T3B0aW9ucyB7XG4gICBjb25zdCBiYXNlRGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgIGNvbnN0IGNvbmZpZzogU2ltcGxlR2l0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IGJhc2VEaXIsIC4uLmRlZmF1bHRPcHRpb25zIH0sXG4gICAgICAuLi5vcHRpb25zLmZpbHRlcigobykgPT4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8pXG4gICApO1xuXG4gICBjb25maWcuYmFzZURpciA9IGNvbmZpZy5iYXNlRGlyIHx8IGJhc2VEaXI7XG4gICBjb25maWcudHJpbW1lZCA9IGNvbmZpZy50cmltbWVkID09PSB0cnVlO1xuXG4gICByZXR1cm4gY29uZmlnO1xufVxuIiwgImltcG9ydCB7XG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlckZ1bmN0aW9uLFxuICAgZmlsdGVyUGxhaW5PYmplY3QsXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyVHlwZSxcbn0gZnJvbSAnLi9hcmd1bWVudC1maWx0ZXJzJztcbmltcG9ydCB7IGFzRnVuY3Rpb24sIGlzVXNlckZ1bmN0aW9uLCBsYXN0IH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IE1heWJlLCBPcHRpb25zLCBPcHRpb25zVmFsdWVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNQYXRoU3BlYyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kVGFza09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnMgPSBPcHRpb25zPihcbiAgIG9wdGlvbnM6IE1heWJlPFQ+LFxuICAgY29tbWFuZHM6IHN0cmluZ1tdID0gW11cbik6IHN0cmluZ1tdIHtcbiAgIGlmICghZmlsdGVyUGxhaW5PYmplY3Q8T3B0aW9ucz4ob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcztcbiAgIH1cblxuICAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZSgoY29tbWFuZHM6IHN0cmluZ1tdLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgdmFsdWU6IE9wdGlvbnNWYWx1ZXMgPSBvcHRpb25zW2tleV07XG5cbiAgICAgIGlmIChpc1BhdGhTcGVjKHZhbHVlKSkge1xuICAgICAgICAgY29tbWFuZHMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlclByaW1pdGl2ZXModmFsdWUsIFsnYm9vbGVhbiddKSkge1xuICAgICAgICAgY29tbWFuZHMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY29tbWFuZHMucHVzaChrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tbWFuZHM7XG4gICB9LCBjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFpbGluZ09wdGlvbnMoXG4gICBhcmdzOiBJQXJndW1lbnRzLFxuICAgaW5pdGlhbFByaW1pdGl2ZSA9IDAsXG4gICBvYmplY3RPbmx5ID0gZmFsc2Vcbik6IHN0cmluZ1tdIHtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW107XG5cbiAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbml0aWFsUHJpbWl0aXZlIDwgMCA/IGFyZ3MubGVuZ3RoIDogaW5pdGlhbFByaW1pdGl2ZTsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBpZiAoJ3N0cmluZ3xudW1iZXInLmluY2x1ZGVzKHR5cGVvZiBhcmdzW2ldKSkge1xuICAgICAgICAgY29tbWFuZC5wdXNoKFN0cmluZyhhcmdzW2ldKSk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFwcGVuZFRhc2tPcHRpb25zKHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3MpLCBjb21tYW5kKTtcbiAgIGlmICghb2JqZWN0T25seSkge1xuICAgICAgY29tbWFuZC5wdXNoKC4uLnRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzKSk7XG4gICB9XG5cbiAgIHJldHVybiBjb21tYW5kO1xufVxuXG5mdW5jdGlvbiB0cmFpbGluZ0FycmF5QXJndW1lbnQoYXJnczogSUFyZ3VtZW50cykge1xuICAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IHR5cGVvZiBsYXN0KGFyZ3MpID09PSAnZnVuY3Rpb24nO1xuICAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJBcnJheSwgW10pO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSB0cmFpbGluZyBvcHRpb25zIGFyZ3VtZW50LCBpZ25vcmluZyBhIHRyYWlsaW5nIGZ1bmN0aW9uIGFyZ3VtZW50XG4gKiBpZiB0aGVyZSBpcyBvbmUuIFdoZW4gbm90IGZvdW5kLCB0aGUgcmV0dXJuIHZhbHVlIGlzIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmdzOiBJQXJndW1lbnRzKTogTWF5YmU8T3B0aW9ucz4ge1xuICAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IGZpbHRlckZ1bmN0aW9uKGxhc3QoYXJncykpO1xuICAgcmV0dXJuIGZpbHRlclR5cGUobGFzdChhcmdzLCBoYXNUcmFpbGluZ0NhbGxiYWNrID8gMSA6IDApLCBmaWx0ZXJQbGFpbk9iamVjdCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBlaXRoZXIgdGhlIHNvdXJjZSBhcmd1bWVudCB3aGVuIGl0IGlzIGEgYEZ1bmN0aW9uYCwgb3IgdGhlIGRlZmF1bHRcbiAqIGBOT09QYCBmdW5jdGlvbiBjb25zdGFudFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KFxuICAgYXJnczogdW5rbm93bltdIHwgSUFyZ3VtZW50cyB8IHVua25vd24sXG4gICBpbmNsdWRlTm9vcCA9IHRydWVcbik6IE1heWJlPCguLi5hcmdzOiBhbnlbXSkgPT4gdW5rbm93bj4ge1xuICAgY29uc3QgY2FsbGJhY2sgPSBhc0Z1bmN0aW9uKGxhc3QoYXJncykpO1xuICAgcmV0dXJuIGluY2x1ZGVOb29wIHx8IGlzVXNlckZ1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCB0eXBlIHsgTWF5YmVBcnJheSwgVGFza1BhcnNlciwgVGFza1Jlc3BvbnNlRm9ybWF0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0T3V0cHV0U3RyZWFtcyB9IGZyb20gJy4vZ2l0LW91dHB1dC1zdHJlYW1zJztcbmltcG9ydCB7IExpbmVQYXJzZXIgfSBmcm9tICcuL2xpbmUtcGFyc2VyJztcbmltcG9ydCB7IGFzQXJyYXksIHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVGFza1BhcnNlcjxJTlBVVCBleHRlbmRzIFRhc2tSZXNwb25zZUZvcm1hdCwgUkVTUE9OU0U+KFxuICAgcGFyc2VyOiBUYXNrUGFyc2VyPElOUFVULCBSRVNQT05TRT4sXG4gICBzdHJlYW1zOiBHaXRPdXRwdXRTdHJlYW1zPElOUFVUPlxuKSB7XG4gICByZXR1cm4gcGFyc2VyKHN0cmVhbXMuc3RkT3V0LCBzdHJlYW1zLnN0ZEVycik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cmluZ1Jlc3BvbnNlPFQ+KFxuICAgcmVzdWx0OiBULFxuICAgcGFyc2VyczogTGluZVBhcnNlcjxUPltdLFxuICAgdGV4dHM6IE1heWJlQXJyYXk8c3RyaW5nPixcbiAgIHRyaW0gPSB0cnVlXG4pOiBUIHtcbiAgIGFzQXJyYXkodGV4dHMpLmZvckVhY2goKHRleHQpID0+IHtcbiAgICAgIGZvciAobGV0IGxpbmVzID0gdG9MaW5lc1dpdGhDb250ZW50KHRleHQsIHRyaW0pLCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgIGNvbnN0IGxpbmUgPSAob2Zmc2V0ID0gMCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gbWF4KSB7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXNbaSArIG9mZnNldF07XG4gICAgICAgICB9O1xuXG4gICAgICAgICBwYXJzZXJzLnNvbWUoKHsgcGFyc2UgfSkgPT4gcGFyc2UobGluZSwgcmVzdWx0KSk7XG4gICAgICB9XG4gICB9KTtcblxuICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJleHBvcnQgKiBmcm9tICcuL2FyZ3VtZW50LWZpbHRlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9leGl0LWNvZGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZ2l0LW91dHB1dC1zdHJlYW1zJztcbmV4cG9ydCAqIGZyb20gJy4vbGluZS1wYXJzZXInO1xuZXhwb3J0ICogZnJvbSAnLi9zaW1wbGUtZ2l0LW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90YXNrLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi90YXNrLXBhcnNlcic7XG5leHBvcnQgKiBmcm9tICcuL3V0aWwnO1xuIiwgImltcG9ydCB7IEV4aXRDb2RlcyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IE1heWJlLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBDaGVja1JlcG9BY3Rpb25zIHtcbiAgIEJBUkUgPSAnYmFyZScsXG4gICBJTl9UUkVFID0gJ3RyZWUnLFxuICAgSVNfUkVQT19ST09UID0gJ3Jvb3QnLFxufVxuXG5jb25zdCBvbkVycm9yOiBTdHJpbmdUYXNrPGJvb2xlYW4+WydvbkVycm9yJ10gPSAoeyBleGl0Q29kZSB9LCBlcnJvciwgZG9uZSwgZmFpbCkgPT4ge1xuICAgaWYgKGV4aXRDb2RlID09PSBFeGl0Q29kZXMuVU5DTEVBTiAmJiBpc05vdFJlcG9NZXNzYWdlKGVycm9yKSkge1xuICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oJ2ZhbHNlJykpO1xuICAgfVxuXG4gICBmYWlsKGVycm9yKTtcbn07XG5cbmNvbnN0IHBhcnNlcjogU3RyaW5nVGFzazxib29sZWFuPlsncGFyc2VyJ10gPSAodGV4dCkgPT4ge1xuICAgcmV0dXJuIHRleHQudHJpbSgpID09PSAndHJ1ZSc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJc1JlcG9UYXNrKGFjdGlvbjogTWF5YmU8Q2hlY2tSZXBvQWN0aW9ucz4pOiBTdHJpbmdUYXNrPGJvb2xlYW4+IHtcbiAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIENoZWNrUmVwb0FjdGlvbnMuQkFSRTpcbiAgICAgICAgIHJldHVybiBjaGVja0lzQmFyZVJlcG9UYXNrKCk7XG4gICAgICBjYXNlIENoZWNrUmVwb0FjdGlvbnMuSVNfUkVQT19ST09UOlxuICAgICAgICAgcmV0dXJuIGNoZWNrSXNSZXBvUm9vdFRhc2soKTtcbiAgIH1cblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWlzLWluc2lkZS13b3JrLXRyZWUnXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzUmVwb1Jvb3RUYXNrKCk6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWdpdC1kaXInXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcihwYXRoKSB7XG4gICAgICAgICByZXR1cm4gL15cXC4oZ2l0KT8kLy50ZXN0KHBhdGgudHJpbSgpKTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJc0JhcmVSZXBvVGFzaygpOiBTdHJpbmdUYXNrPGJvb2xlYW4+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZXYtcGFyc2UnLCAnLS1pcy1iYXJlLXJlcG9zaXRvcnknXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgb25FcnJvcixcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90UmVwb01lc3NhZ2UoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gICByZXR1cm4gLyhOb3QgYSBnaXQgcmVwb3NpdG9yeXxLZWluIEdpdC1SZXBvc2l0b3J5KS9pLnRlc3QoU3RyaW5nKGVycm9yKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2xlYW5TdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyB0b0xpbmVzV2l0aENvbnRlbnQgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBDbGVhblJlc3BvbnNlIGltcGxlbWVudHMgQ2xlYW5TdW1tYXJ5IHtcbiAgIHB1YmxpYyBwYXRoczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmb2xkZXJzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgZHJ5UnVuOiBib29sZWFuKSB7fVxufVxuXG5jb25zdCByZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMqL2k7XG5jb25zdCBkcnlSdW5SZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMrW2Etel0rXFxzKi9pO1xuY29uc3QgaXNGb2xkZXJSZWdleHAgPSAvXFwvJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblN1bW1hcnlQYXJzZXIoZHJ5UnVuOiBib29sZWFuLCB0ZXh0OiBzdHJpbmcpOiBDbGVhblN1bW1hcnkge1xuICAgY29uc3Qgc3VtbWFyeSA9IG5ldyBDbGVhblJlc3BvbnNlKGRyeVJ1bik7XG4gICBjb25zdCByZWdleHAgPSBkcnlSdW4gPyBkcnlSdW5SZW1vdmFsUmVnZXhwIDogcmVtb3ZhbFJlZ2V4cDtcblxuICAgdG9MaW5lc1dpdGhDb250ZW50KHRleHQpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBsaW5lLnJlcGxhY2UocmVnZXhwLCAnJyk7XG5cbiAgICAgIHN1bW1hcnkucGF0aHMucHVzaChyZW1vdmVkKTtcbiAgICAgIChpc0ZvbGRlclJlZ2V4cC50ZXN0KHJlbW92ZWQpID8gc3VtbWFyeS5mb2xkZXJzIDogc3VtbWFyeS5maWxlcykucHVzaChyZW1vdmVkKTtcbiAgIH0pO1xuXG4gICByZXR1cm4gc3VtbWFyeTtcbn1cbiIsICJpbXBvcnQgeyBUYXNrQ29uZmlndXJhdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvcic7XG5pbXBvcnQgdHlwZSB7IEJ1ZmZlclRhc2ssIEVtcHR5VGFza1BhcnNlciwgU2ltcGxlR2l0VGFzaywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEVNUFRZX0NPTU1BTkRTOiBbXSA9IFtdO1xuXG5leHBvcnQgdHlwZSBFbXB0eVRhc2sgPSB7XG4gICBjb21tYW5kczogdHlwZW9mIEVNUFRZX0NPTU1BTkRTO1xuICAgZm9ybWF0OiAnZW1wdHknO1xuICAgcGFyc2VyOiBFbXB0eVRhc2tQYXJzZXI7XG4gICBvbkVycm9yPzogdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkaG9jRXhlY1Rhc2socGFyc2VyOiBFbXB0eVRhc2tQYXJzZXIpOiBFbXB0eVRhc2sge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBFTVBUWV9DT01NQU5EUyxcbiAgICAgIGZvcm1hdDogJ2VtcHR5JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGVycm9yOiBFcnJvciB8IHN0cmluZyk6IEVtcHR5VGFzayB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgICAgZm9ybWF0OiAnZW1wdHknLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgdGhyb3cgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IG5ldyBUYXNrQ29uZmlndXJhdGlvbkVycm9yKGVycm9yKSA6IGVycm9yO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzOiBzdHJpbmdbXSwgdHJpbW1lZCA9IGZhbHNlKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICAgICByZXR1cm4gdHJpbW1lZCA/IFN0cmluZyh0ZXh0KS50cmltKCkgOiB0ZXh0O1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzOiBzdHJpbmdbXSk6IEJ1ZmZlclRhc2s8YW55PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICdidWZmZXInLFxuICAgICAgcGFyc2VyKGJ1ZmZlcikge1xuICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdWZmZXJUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiB0YXNrIGlzIEJ1ZmZlclRhc2s8Uj4ge1xuICAgcmV0dXJuIHRhc2suZm9ybWF0ID09PSAnYnVmZmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlUYXNrPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiB0YXNrIGlzIEVtcHR5VGFzayB7XG4gICByZXR1cm4gdGFzay5mb3JtYXQgPT09ICdlbXB0eScgfHwgIXRhc2suY29tbWFuZHMubGVuZ3RoO1xufVxuIiwgImltcG9ydCB7IENsZWFuU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgY2xlYW5TdW1tYXJ5UGFyc2VyIH0gZnJvbSAnLi4vcmVzcG9uc2VzL0NsZWFuU3VtbWFyeSc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFzU3RyaW5nQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFID0gJ0dpdCBjbGVhbiBpbnRlcmFjdGl2ZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQnO1xuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEID0gJ0dpdCBjbGVhbiBtb2RlIHBhcmFtZXRlciAoXCJuXCIgb3IgXCJmXCIpIGlzIHJlcXVpcmVkJztcbmV4cG9ydCBjb25zdCBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gPSAnR2l0IGNsZWFuIHVua25vd24gb3B0aW9uIGZvdW5kIGluOiAnO1xuXG4vKipcbiAqIEFsbCBzdXBwb3J0ZWQgb3B0aW9uIHN3aXRjaGVzIGF2YWlsYWJsZSBmb3IgdXNlIGluIGEgYGdpdC5jbGVhbmAgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBlbnVtIENsZWFuT3B0aW9ucyB7XG4gICBEUllfUlVOID0gJ24nLFxuICAgRk9SQ0UgPSAnZicsXG4gICBJR05PUkVEX0lOQ0xVREVEID0gJ3gnLFxuICAgSUdOT1JFRF9PTkxZID0gJ1gnLFxuICAgRVhDTFVESU5HID0gJ2UnLFxuICAgUVVJRVQgPSAncScsXG4gICBSRUNVUlNJVkUgPSAnZCcsXG59XG5cbi8qKlxuICogVGhlIHR3byBtb2RlcyBgZ2l0LmNsZWFuYCBjYW4gcnVuIGluIC0gb25lIG9mIHRoZXNlIG11c3QgYmUgc3VwcGxpZWQgaW4gb3JkZXJcbiAqIGZvciB0aGUgY29tbWFuZCB0byBub3QgdGhyb3cgYSBgVGFza0NvbmZpZ3VyYXRpb25FcnJvcmBcbiAqL1xuZXhwb3J0IHR5cGUgQ2xlYW5Nb2RlID0gQ2xlYW5PcHRpb25zLkZPUkNFIHwgQ2xlYW5PcHRpb25zLkRSWV9SVU47XG5cbmNvbnN0IENsZWFuT3B0aW9uVmFsdWVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoW1xuICAgJ2knLFxuICAgLi4uYXNTdHJpbmdBcnJheShPYmplY3QudmFsdWVzKENsZWFuT3B0aW9ucyBhcyBhbnkpKSxcbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5XaXRoT3B0aW9uc1Rhc2sobW9kZTogQ2xlYW5Nb2RlIHwgc3RyaW5nLCBjdXN0b21BcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgeyBjbGVhbk1vZGUsIG9wdGlvbnMsIHZhbGlkIH0gPSBnZXRDbGVhbk9wdGlvbnMobW9kZSk7XG5cbiAgIGlmICghY2xlYW5Nb2RlKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCk7XG4gICB9XG5cbiAgIGlmICghdmFsaWQub3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OICsgSlNPTi5zdHJpbmdpZnkobW9kZSkpO1xuICAgfVxuXG4gICBvcHRpb25zLnB1c2goLi4uY3VzdG9tQXJncyk7XG5cbiAgIGlmIChvcHRpb25zLnNvbWUoaXNJbnRlcmFjdGl2ZU1vZGUpKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERSk7XG4gICB9XG5cbiAgIHJldHVybiBjbGVhblRhc2soY2xlYW5Nb2RlLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuVGFzayhtb2RlOiBDbGVhbk1vZGUsIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxDbGVhblN1bW1hcnk+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY2xlYW4nLCBgLSR7bW9kZX1gLCAuLi5jdXN0b21BcmdzXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZyk6IENsZWFuU3VtbWFyeSB7XG4gICAgICAgICByZXR1cm4gY2xlYW5TdW1tYXJ5UGFyc2VyKG1vZGUgPT09IENsZWFuT3B0aW9ucy5EUllfUlVOLCB0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbGVhbk9wdGlvbnNBcnJheShpbnB1dDogc3RyaW5nW10pOiBpbnB1dCBpcyBDbGVhbk9wdGlvbnNbXSB7XG4gICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoKHRlc3QpID0+IENsZWFuT3B0aW9uVmFsdWVzLmhhcyh0ZXN0KSk7XG59XG5cbmZ1bmN0aW9uIGdldENsZWFuT3B0aW9ucyhpbnB1dDogc3RyaW5nKSB7XG4gICBsZXQgY2xlYW5Nb2RlOiBNYXliZTxDbGVhbk1vZGU+O1xuICAgbGV0IG9wdGlvbnM6IHN0cmluZ1tdID0gW107XG4gICBsZXQgdmFsaWQgPSB7IGNsZWFuTW9kZTogZmFsc2UsIG9wdGlvbnM6IHRydWUgfTtcblxuICAgaW5wdXRcbiAgICAgIC5yZXBsYWNlKC9bXmEtel1pL2csICcnKVxuICAgICAgLnNwbGl0KCcnKVxuICAgICAgLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgICAgIGlmIChpc0NsZWFuTW9kZShjaGFyKSkge1xuICAgICAgICAgICAgY2xlYW5Nb2RlID0gY2hhcjtcbiAgICAgICAgICAgIHZhbGlkLmNsZWFuTW9kZSA9IHRydWU7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWQub3B0aW9ucyA9IHZhbGlkLm9wdGlvbnMgJiYgaXNLbm93bk9wdGlvbigob3B0aW9uc1tvcHRpb25zLmxlbmd0aF0gPSBgLSR7Y2hhcn1gKSk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNsZWFuTW9kZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB2YWxpZCxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGlzQ2xlYW5Nb2RlKGNsZWFuTW9kZT86IHN0cmluZyk6IGNsZWFuTW9kZSBpcyBDbGVhbk1vZGUge1xuICAgcmV0dXJuIGNsZWFuTW9kZSA9PT0gQ2xlYW5PcHRpb25zLkZPUkNFIHx8IGNsZWFuTW9kZSA9PT0gQ2xlYW5PcHRpb25zLkRSWV9SVU47XG59XG5cbmZ1bmN0aW9uIGlzS25vd25PcHRpb24ob3B0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgIHJldHVybiAvXi1bYS16XSQvaS50ZXN0KG9wdGlvbikgJiYgQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKG9wdGlvbi5jaGFyQXQoMSkpO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlTW9kZShvcHRpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgaWYgKC9eLVteXFwtXS8udGVzdChvcHRpb24pKSB7XG4gICAgICByZXR1cm4gb3B0aW9uLmluZGV4T2YoJ2knKSA+IDA7XG4gICB9XG5cbiAgIHJldHVybiBvcHRpb24gPT09ICctLWludGVyYWN0aXZlJztcbn1cbiIsICJpbXBvcnQgeyBDb25maWdHZXRSZXN1bHQsIENvbmZpZ0xpc3RTdW1tYXJ5LCBDb25maWdWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGxhc3QsIHNwbGl0T24gfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBDb25maWdMaXN0IGltcGxlbWVudHMgQ29uZmlnTGlzdFN1bW1hcnkge1xuICAgcHVibGljIGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHZhbHVlczogeyBbZmlsZU5hbWU6IHN0cmluZ106IENvbmZpZ1ZhbHVlcyB9ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgcHJpdmF0ZSBfYWxsOiBDb25maWdWYWx1ZXMgfCB1bmRlZmluZWQ7XG5cbiAgIHB1YmxpYyBnZXQgYWxsKCk6IENvbmZpZ1ZhbHVlcyB7XG4gICAgICBpZiAoIXRoaXMuX2FsbCkge1xuICAgICAgICAgdGhpcy5fYWxsID0gdGhpcy5maWxlcy5yZWR1Y2UoKGFsbDogQ29uZmlnVmFsdWVzLCBmaWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFsbCwgdGhpcy52YWx1ZXNbZmlsZV0pO1xuICAgICAgICAgfSwge30pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgfVxuXG4gICBwdWJsaWMgYWRkRmlsZShmaWxlOiBzdHJpbmcpOiBDb25maWdWYWx1ZXMge1xuICAgICAgaWYgKCEoZmlsZSBpbiB0aGlzLnZhbHVlcykpIHtcbiAgICAgICAgIGNvbnN0IGxhdGVzdCA9IGxhc3QodGhpcy5maWxlcyk7XG4gICAgICAgICB0aGlzLnZhbHVlc1tmaWxlXSA9IGxhdGVzdCA/IE9iamVjdC5jcmVhdGUodGhpcy52YWx1ZXNbbGF0ZXN0XSkgOiB7fTtcblxuICAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXNbZmlsZV07XG4gICB9XG5cbiAgIHB1YmxpYyBhZGRWYWx1ZShmaWxlOiBzdHJpbmcsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmFkZEZpbGUoZmlsZSk7XG5cbiAgICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzW2tleV0pKSB7XG4gICAgICAgICAodmFsdWVzW2tleV0gYXMgc3RyaW5nW10pLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHZhbHVlc1trZXldID0gW3ZhbHVlc1trZXldIGFzIHN0cmluZywgdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hbGwgPSB1bmRlZmluZWQ7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdMaXN0UGFyc2VyKHRleHQ6IHN0cmluZyk6IENvbmZpZ0xpc3Qge1xuICAgY29uc3QgY29uZmlnID0gbmV3IENvbmZpZ0xpc3QoKTtcblxuICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0KSkge1xuICAgICAgY29uZmlnLmFkZFZhbHVlKGl0ZW0uZmlsZSwgU3RyaW5nKGl0ZW0ua2V5KSwgaXRlbS52YWx1ZSk7XG4gICB9XG5cbiAgIHJldHVybiBjb25maWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWdHZXRQYXJzZXIodGV4dDogc3RyaW5nLCBrZXk6IHN0cmluZyk6IENvbmZpZ0dldFJlc3VsdCB7XG4gICBsZXQgdmFsdWU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgY29uc3Qgc2NvcGVzOiBNYXA8c3RyaW5nLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XG5cbiAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWdQYXJzZXIodGV4dCwga2V5KSkge1xuICAgICAgaWYgKGl0ZW0ua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMucHVzaCgodmFsdWUgPSBpdGVtLnZhbHVlKSk7XG5cbiAgICAgIGlmICghc2NvcGVzLmhhcyhpdGVtLmZpbGUpKSB7XG4gICAgICAgICBzY29wZXMuc2V0KGl0ZW0uZmlsZSwgW10pO1xuICAgICAgfVxuXG4gICAgICBzY29wZXMuZ2V0KGl0ZW0uZmlsZSkhLnB1c2godmFsdWUpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgcGF0aHM6IEFycmF5LmZyb20oc2NvcGVzLmtleXMoKSksXG4gICAgICBzY29wZXMsXG4gICAgICB2YWx1ZSxcbiAgICAgIHZhbHVlcyxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0ZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoL14oZmlsZSk6LywgJycpO1xufVxuXG5mdW5jdGlvbiogY29uZmlnUGFyc2VyKHRleHQ6IHN0cmluZywgcmVxdWVzdGVkS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXDAnKTtcblxuICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPCBtYXg7ICkge1xuICAgICAgY29uc3QgZmlsZSA9IGNvbmZpZ0ZpbGVQYXRoKGxpbmVzW2krK10pO1xuXG4gICAgICBsZXQgdmFsdWUgPSBsaW5lc1tpKytdO1xuICAgICAgbGV0IGtleSA9IHJlcXVlc3RlZEtleTtcblxuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgY29uc3QgbGluZSA9IHNwbGl0T24odmFsdWUsICdcXG4nKTtcbiAgICAgICAgIGtleSA9IGxpbmVbMF07XG4gICAgICAgICB2YWx1ZSA9IGxpbmVbMV07XG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHsgZmlsZSwga2V5LCB2YWx1ZSB9O1xuICAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgQ29uZmlnR2V0UmVzdWx0LCBDb25maWdMaXN0U3VtbWFyeSwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBjb25maWdHZXRQYXJzZXIsIGNvbmZpZ0xpc3RQYXJzZXIgfSBmcm9tICcuLi9yZXNwb25zZXMvQ29uZmlnTGlzdCc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGVudW0gR2l0Q29uZmlnU2NvcGUge1xuICAgc3lzdGVtID0gJ3N5c3RlbScsXG4gICBnbG9iYWwgPSAnZ2xvYmFsJyxcbiAgIGxvY2FsID0gJ2xvY2FsJyxcbiAgIHdvcmt0cmVlID0gJ3dvcmt0cmVlJyxcbn1cblxuZnVuY3Rpb24gYXNDb25maWdTY29wZTxUIGV4dGVuZHMgR2l0Q29uZmlnU2NvcGUgfCB1bmRlZmluZWQ+KFxuICAgc2NvcGU6IEdpdENvbmZpZ1Njb3BlIHwgdW5rbm93bixcbiAgIGZhbGxiYWNrOiBUXG4pOiBHaXRDb25maWdTY29wZSB8IFQge1xuICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycgJiYgR2l0Q29uZmlnU2NvcGUuaGFzT3duUHJvcGVydHkoc2NvcGUpKSB7XG4gICAgICByZXR1cm4gc2NvcGUgYXMgR2l0Q29uZmlnU2NvcGU7XG4gICB9XG4gICByZXR1cm4gZmFsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZpZ1Rhc2soXG4gICBrZXk6IHN0cmluZyxcbiAgIHZhbHVlOiBzdHJpbmcsXG4gICBhcHBlbmQ6IGJvb2xlYW4sXG4gICBzY29wZTogR2l0Q29uZmlnU2NvcGVcbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ2NvbmZpZycsIGAtLSR7c2NvcGV9YF07XG5cbiAgIGlmIChhcHBlbmQpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy0tYWRkJyk7XG4gICB9XG5cbiAgIGNvbW1hbmRzLnB1c2goa2V5LCB2YWx1ZSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uZmlnVGFzayhrZXk6IHN0cmluZywgc2NvcGU/OiBHaXRDb25maWdTY29wZSk6IFN0cmluZ1Rhc2s8Q29uZmlnR2V0UmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ2NvbmZpZycsICctLW51bGwnLCAnLS1zaG93LW9yaWdpbicsICctLWdldC1hbGwnLCBrZXldO1xuXG4gICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBgLS0ke3Njb3BlfWApO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dCkge1xuICAgICAgICAgcmV0dXJuIGNvbmZpZ0dldFBhcnNlcih0ZXh0LCBrZXkpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmZ1bmN0aW9uIGxpc3RDb25maWdUYXNrKHNjb3BlPzogR2l0Q29uZmlnU2NvcGUpOiBTdHJpbmdUYXNrPENvbmZpZ0xpc3RTdW1tYXJ5PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY29uZmlnJywgJy0tbGlzdCcsICctLXNob3ctb3JpZ2luJywgJy0tbnVsbCddO1xuXG4gICBpZiAoc2NvcGUpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goYC0tJHtzY29wZX1gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIGNvbmZpZ0xpc3RQYXJzZXIodGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnYWRkQ29uZmlnJyB8ICdnZXRDb25maWcnIHwgJ2xpc3RDb25maWcnPiB7XG4gICByZXR1cm4ge1xuICAgICAgYWRkQ29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIC4uLnJlc3Q6IHVua25vd25bXSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBhZGRDb25maWdUYXNrKFxuICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICByZXN0WzBdID09PSB0cnVlLFxuICAgICAgICAgICAgICAgYXNDb25maWdTY29wZShyZXN0WzFdLCBHaXRDb25maWdTY29wZS5sb2NhbClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldENvbmZpZyh0aGlzOiBTaW1wbGVHaXRBcGksIGtleTogc3RyaW5nLCBzY29wZT86IEdpdENvbmZpZ1Njb3BlKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGdldENvbmZpZ1Rhc2soa2V5LCBhc0NvbmZpZ1Njb3BlKHNjb3BlLCB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgbGlzdENvbmZpZyh0aGlzOiBTaW1wbGVHaXRBcGksIC4uLnJlc3Q6IHVua25vd25bXSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBsaXN0Q29uZmlnVGFzayhhc0NvbmZpZ1Njb3BlKHJlc3RbMF0sIHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBEaWZmTmFtZVN0YXR1cyB7XG4gICBBRERFRCA9ICdBJyxcbiAgIENPUElFRCA9ICdDJyxcbiAgIERFTEVURUQgPSAnRCcsXG4gICBNT0RJRklFRCA9ICdNJyxcbiAgIFJFTkFNRUQgPSAnUicsXG4gICBDSEFOR0VEID0gJ1QnLFxuICAgVU5NRVJHRUQgPSAnVScsXG4gICBVTktOT1dOID0gJ1gnLFxuICAgQlJPS0VOID0gJ0InLFxufVxuXG5jb25zdCBkaWZmTmFtZVN0YXR1cyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhEaWZmTmFtZVN0YXR1cykpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWZmTmFtZVN0YXR1cyhpbnB1dDogc3RyaW5nKTogaW5wdXQgaXMgRGlmZk5hbWVTdGF0dXMge1xuICAgcmV0dXJuIGRpZmZOYW1lU3RhdHVzLmhhcyhpbnB1dCBhcyBEaWZmTmFtZVN0YXR1cyk7XG59XG4iLCAiaW1wb3J0IHsgR3JlcFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQge1xuICAgYXNOdW1iZXIsXG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50LFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgTlVMTCxcbiAgIHByZWZpeGVkQXJyYXksXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmNvbnN0IGRpc2FsbG93ZWRPcHRpb25zID0gWyctaCddO1xuXG5jb25zdCBRdWVyeSA9IFN5bWJvbCgnZ3JlcFF1ZXJ5Jyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0R3JlcFF1ZXJ5IGV4dGVuZHMgSXRlcmFibGU8c3RyaW5nPiB7XG4gICAvKiogQWRkcyBvbmUgb3IgbW9yZSB0ZXJtcyB0byBiZSBncm91cGVkIGFzIGFuIFwiYW5kXCIgdG8gYW55IG90aGVyIHRlcm1zICovXG4gICBhbmQoLi4uYW5kOiBzdHJpbmdbXSk6IHRoaXM7XG5cbiAgIC8qKiBBZGRzIG9uZSBvciBtb3JlIHNlYXJjaCB0ZXJtcyAtIGdpdC5ncmVwIHdpbGwgXCJvclwiIHRoaXMgdG8gb3RoZXIgdGVybXMgKi9cbiAgIHBhcmFtKC4uLnBhcmFtOiBzdHJpbmdbXSk6IHRoaXM7XG59XG5cbmNsYXNzIEdyZXBRdWVyeSBpbXBsZW1lbnRzIEdpdEdyZXBRdWVyeSB7XG4gICBwcml2YXRlIFtRdWVyeV06IHN0cmluZ1tdID0gW107XG5cbiAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgdGhpc1tRdWVyeV0pIHtcbiAgICAgICAgIHlpZWxkIHF1ZXJ5O1xuICAgICAgfVxuICAgfVxuXG4gICBhbmQoLi4uYW5kOiBzdHJpbmdbXSkge1xuICAgICAgYW5kLmxlbmd0aCAmJiB0aGlzW1F1ZXJ5XS5wdXNoKCctLWFuZCcsICcoJywgLi4ucHJlZml4ZWRBcnJheShhbmQsICctZScpLCAnKScpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHBhcmFtKC4uLnBhcmFtOiBzdHJpbmdbXSkge1xuICAgICAgdGhpc1tRdWVyeV0ucHVzaCguLi5wcmVmaXhlZEFycmF5KHBhcmFtLCAnLWUnKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1aWxkZXIgZm9yIGEgYGdpdC5ncmVwYCBxdWVyeSB3aXRoIG9wdGlvbmFsIHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ3JlcFF1ZXJ5QnVpbGRlciguLi5wYXJhbXM6IHN0cmluZ1tdKTogR2l0R3JlcFF1ZXJ5IHtcbiAgIHJldHVybiBuZXcgR3JlcFF1ZXJ5KCkucGFyYW0oLi4ucGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VHcmVwKGdyZXA6IHN0cmluZyk6IEdyZXBSZXN1bHQge1xuICAgY29uc3QgcGF0aHM6IEdyZXBSZXN1bHRbJ3BhdGhzJ10gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgIGNvbnN0IHJlc3VsdHM6IEdyZXBSZXN1bHRbJ3Jlc3VsdHMnXSA9IHt9O1xuXG4gICBmb3JFYWNoTGluZVdpdGhDb250ZW50KGdyZXAsIChpbnB1dCkgPT4ge1xuICAgICAgY29uc3QgW3BhdGgsIGxpbmUsIHByZXZpZXddID0gaW5wdXQuc3BsaXQoTlVMTCk7XG4gICAgICBwYXRocy5hZGQocGF0aCk7XG4gICAgICAocmVzdWx0c1twYXRoXSA9IHJlc3VsdHNbcGF0aF0gfHwgW10pLnB1c2goe1xuICAgICAgICAgbGluZTogYXNOdW1iZXIobGluZSksXG4gICAgICAgICBwYXRoLFxuICAgICAgICAgcHJldmlldyxcbiAgICAgIH0pO1xuICAgfSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBwYXRocyxcbiAgICAgIHJlc3VsdHMsXG4gICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdncmVwJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGdyZXAodGhpczogU2ltcGxlR2l0QXBpLCBzZWFyY2hUZXJtOiBzdHJpbmcgfCBHaXRHcmVwUXVlcnkpIHtcbiAgICAgICAgIGNvbnN0IHRoZW4gPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcbiAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcblxuICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGlzYWxsb3dlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVzKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LmdyZXA6IHVzZSBvZiBcIiR7b3B0aW9ufVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCksXG4gICAgICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodHlwZW9mIHNlYXJjaFRlcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWFyY2hUZXJtID0gZ3JlcFF1ZXJ5QnVpbGRlcigpLnBhcmFtKHNlYXJjaFRlcm0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnZ3JlcCcsICctLW51bGwnLCAnLW4nLCAnLS1mdWxsLW5hbWUnLCAuLi5vcHRpb25zLCAuLi5zZWFyY2hUZXJtXTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgICAgICAgIHBhcnNlcihzdGRPdXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUdyZXAoc3RkT3V0KTtcbiAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhlblxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgTWF5YmUsIE9wdGlvbkZsYWdzLCBPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBSZXNldE1vZGUge1xuICAgTUlYRUQgPSAnbWl4ZWQnLFxuICAgU09GVCA9ICdzb2Z0JyxcbiAgIEhBUkQgPSAnaGFyZCcsXG4gICBNRVJHRSA9ICdtZXJnZScsXG4gICBLRUVQID0gJ2tlZXAnLFxufVxuXG5jb25zdCBSZXNldE1vZGVzID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFJlc2V0TW9kZSkpO1xuXG5leHBvcnQgdHlwZSBSZXNldE9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPCctcScgfCAnLS1xdWlldCcgfCAnLS1uby1xdWlldCcgfCAnLS1wYXRoc3BlYy1mcm9tLW51bCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLXBhdGhzcGVjLWZyb20tZmlsZScsIHN0cmluZz47XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldFRhc2sobW9kZTogTWF5YmU8UmVzZXRNb2RlPiwgY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsncmVzZXQnXTtcbiAgIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKGAtLSR7bW9kZX1gKTtcbiAgIH1cbiAgIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc2V0TW9kZShtb2RlOiBSZXNldE1vZGUgfCBhbnkpOiBNYXliZTxSZXNldE1vZGU+IHtcbiAgIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgICByZXR1cm4gbW9kZTtcbiAgIH1cblxuICAgc3dpdGNoICh0eXBlb2YgbW9kZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICByZXR1cm4gUmVzZXRNb2RlLlNPRlQ7XG4gICB9XG5cbiAgIHJldHVybjtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFJlc2V0TW9kZShtb2RlOiBSZXNldE1vZGUgfCBhbnkpOiBtb2RlIGlzIFJlc2V0TW9kZSB7XG4gICByZXR1cm4gUmVzZXRNb2Rlcy5pbmNsdWRlcyhtb2RlKTtcbn1cbiIsICJpbXBvcnQgZGVidWcsIHsgRGVidWdnZXIgfSBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQge1xuICAgYXBwZW5kLFxuICAgZmlsdGVySGFzTGVuZ3RoLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyVHlwZSxcbiAgIE5PT1AsXG4gICBvYmplY3RUb1N0cmluZyxcbiAgIHJlbW92ZSxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5kZWJ1Zy5mb3JtYXR0ZXJzLkwgPSAodmFsdWU6IGFueSkgPT4gU3RyaW5nKGZpbHRlckhhc0xlbmd0aCh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiAnLScpO1xuZGVidWcuZm9ybWF0dGVycy5CID0gKHZhbHVlOiBCdWZmZXIpID0+IHtcbiAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgIH1cbiAgIHJldHVybiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59O1xuXG50eXBlIE91dHB1dExvZ2dpbmdIYW5kbGVyID0gKG1lc3NhZ2U6IHN0cmluZywgLi4uYXJnczogYW55W10pID0+IHZvaWQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZygpIHtcbiAgIHJldHVybiBkZWJ1Zygnc2ltcGxlLWdpdCcpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dExvZ2dlciBleHRlbmRzIE91dHB1dExvZ2dpbmdIYW5kbGVyIHtcbiAgIHJlYWRvbmx5IGxhYmVsOiBzdHJpbmc7XG5cbiAgIGluZm86IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuICAgc3RlcChuZXh0U3RlcD86IHN0cmluZyk6IE91dHB1dExvZ2dlcjtcbiAgIHNpYmxpbmcobmFtZTogc3RyaW5nKTogT3V0cHV0TG9nZ2VyO1xufVxuXG5mdW5jdGlvbiBwcmVmaXhlZExvZ2dlcihcbiAgIHRvOiBEZWJ1Z2dlcixcbiAgIHByZWZpeDogc3RyaW5nLFxuICAgZm9yd2FyZD86IE91dHB1dExvZ2dpbmdIYW5kbGVyXG4pOiBPdXRwdXRMb2dnaW5nSGFuZGxlciB7XG4gICBpZiAoIXByZWZpeCB8fCAhU3RyaW5nKHByZWZpeCkucmVwbGFjZSgvXFxzKi8sICcnKSkge1xuICAgICAgcmV0dXJuICFmb3J3YXJkXG4gICAgICAgICA/IHRvXG4gICAgICAgICA6IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIHRvKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgICAgICB9O1xuICAgfVxuXG4gICByZXR1cm4gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgIHRvKGAlcyAke21lc3NhZ2V9YCwgcHJlZml4LCAuLi5hcmdzKTtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICBmb3J3YXJkKG1lc3NhZ2UsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgfTtcbn1cblxuZnVuY3Rpb24gY2hpbGRMb2dnZXJOYW1lKFxuICAgbmFtZTogTWF5YmU8c3RyaW5nPixcbiAgIGNoaWxkRGVidWdnZXI6IE1heWJlPERlYnVnZ2VyPixcbiAgIHsgbmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UgfTogRGVidWdnZXJcbik6IHN0cmluZyB7XG4gICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgIH1cbiAgIGNvbnN0IGNoaWxkTmFtZXNwYWNlID0gKGNoaWxkRGVidWdnZXIgJiYgY2hpbGREZWJ1Z2dlci5uYW1lc3BhY2UpIHx8ICcnO1xuXG4gICBpZiAoY2hpbGROYW1lc3BhY2Uuc3RhcnRzV2l0aChwYXJlbnROYW1lc3BhY2UpKSB7XG4gICAgICByZXR1cm4gY2hpbGROYW1lc3BhY2Uuc3Vic3RyKHBhcmVudE5hbWVzcGFjZS5sZW5ndGggKyAxKTtcbiAgIH1cblxuICAgcmV0dXJuIGNoaWxkTmFtZXNwYWNlIHx8IHBhcmVudE5hbWVzcGFjZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihcbiAgIGxhYmVsOiBzdHJpbmcsXG4gICB2ZXJib3NlPzogc3RyaW5nIHwgRGVidWdnZXIsXG4gICBpbml0aWFsU3RlcD86IHN0cmluZyxcbiAgIGluZm9EZWJ1Z2dlciA9IGNyZWF0ZUxvZygpXG4pOiBPdXRwdXRMb2dnZXIge1xuICAgY29uc3QgbGFiZWxQcmVmaXggPSAobGFiZWwgJiYgYFske2xhYmVsfV1gKSB8fCAnJztcblxuICAgY29uc3Qgc3Bhd25lZDogT3V0cHV0TG9nZ2VyW10gPSBbXTtcbiAgIGNvbnN0IGRlYnVnRGVidWdnZXI6IE1heWJlPERlYnVnZ2VyPiA9XG4gICAgICB0eXBlb2YgdmVyYm9zZSA9PT0gJ3N0cmluZycgPyBpbmZvRGVidWdnZXIuZXh0ZW5kKHZlcmJvc2UpIDogdmVyYm9zZTtcbiAgIGNvbnN0IGtleSA9IGNoaWxkTG9nZ2VyTmFtZShmaWx0ZXJUeXBlKHZlcmJvc2UsIGZpbHRlclN0cmluZyksIGRlYnVnRGVidWdnZXIsIGluZm9EZWJ1Z2dlcik7XG5cbiAgIHJldHVybiBzdGVwKGluaXRpYWxTdGVwKTtcblxuICAgZnVuY3Rpb24gc2libGluZyhuYW1lOiBzdHJpbmcsIGluaXRpYWw/OiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBhcHBlbmQoXG4gICAgICAgICBzcGF3bmVkLFxuICAgICAgICAgY3JlYXRlTG9nZ2VyKGxhYmVsLCBrZXkucmVwbGFjZSgvXlteOl0rLywgbmFtZSksIGluaXRpYWwsIGluZm9EZWJ1Z2dlcilcbiAgICAgICk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHN0ZXAocGhhc2U/OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHN0ZXBQcmVmaXggPSAocGhhc2UgJiYgYFske3BoYXNlfV1gKSB8fCAnJztcbiAgICAgIGNvbnN0IGRlYnVnID0gKGRlYnVnRGVidWdnZXIgJiYgcHJlZml4ZWRMb2dnZXIoZGVidWdEZWJ1Z2dlciwgc3RlcFByZWZpeCkpIHx8IE5PT1A7XG4gICAgICBjb25zdCBpbmZvID0gcHJlZml4ZWRMb2dnZXIoaW5mb0RlYnVnZ2VyLCBgJHtsYWJlbFByZWZpeH0gJHtzdGVwUHJlZml4fWAsIGRlYnVnKTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVidWdEZWJ1Z2dlciA/IGRlYnVnIDogaW5mbywge1xuICAgICAgICAgbGFiZWwsXG4gICAgICAgICBzaWJsaW5nLFxuICAgICAgICAgaW5mbyxcbiAgICAgICAgIHN0ZXAsXG4gICAgICB9KTtcbiAgIH1cbn1cblxuLyoqXG4gKiBUaGUgYEdpdExvZ2dlcmAgaXMgdXNlZCBieSB0aGUgbWFpbiBgU2ltcGxlR2l0YCBydW5uZXIgdG8gaGFuZGxlIGxvZ2dpbmdcbiAqIGFueSB3YXJuaW5ncyBvciBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRMb2dnZXIge1xuICAgcHVibGljIGVycm9yOiBPdXRwdXRMb2dnaW5nSGFuZGxlcjtcblxuICAgcHVibGljIHdhcm46IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuXG4gICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdXQ6IERlYnVnZ2VyID0gY3JlYXRlTG9nKCkpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBwcmVmaXhlZExvZ2dlcihfb3V0LCAnW0VSUk9SXScpO1xuICAgICAgdGhpcy53YXJuID0gcHJlZml4ZWRMb2dnZXIoX291dCwgJ1tXQVJOXScpO1xuICAgfVxuXG4gICBzaWxlbnQoc2lsZW5jZSA9IGZhbHNlKSB7XG4gICAgICBpZiAoc2lsZW5jZSAhPT0gdGhpcy5fb3V0LmVuYWJsZWQpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBuYW1lc3BhY2UgfSA9IHRoaXMuX291dDtcbiAgICAgIGNvbnN0IGVudiA9IChwcm9jZXNzLmVudi5ERUJVRyB8fCAnJykuc3BsaXQoJywnKS5maWx0ZXIoKHMpID0+ICEhcyk7XG4gICAgICBjb25zdCBoYXNPbiA9IGVudi5pbmNsdWRlcyhuYW1lc3BhY2UpO1xuICAgICAgY29uc3QgaGFzT2ZmID0gZW52LmluY2x1ZGVzKGAtJHtuYW1lc3BhY2V9YCk7XG5cbiAgICAgIC8vIGVuYWJsaW5nIHRoZSBsb2dcbiAgICAgIGlmICghc2lsZW5jZSkge1xuICAgICAgICAgaWYgKGhhc09mZikge1xuICAgICAgICAgICAgcmVtb3ZlKGVudiwgYC0ke25hbWVzcGFjZX1gKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYucHVzaChuYW1lc3BhY2UpO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGlmIChoYXNPbikge1xuICAgICAgICAgICAgcmVtb3ZlKGVudiwgbmFtZXNwYWNlKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYucHVzaChgLSR7bmFtZXNwYWNlfWApO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWJ1Zy5lbmFibGUoZW52LmpvaW4oJywnKSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIsIE91dHB1dExvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuXG50eXBlIEFueVNpbXBsZUdpdFRhc2sgPSBTaW1wbGVHaXRUYXNrPGFueT47XG5cbnR5cGUgVGFza0luUHJvZ3Jlc3MgPSB7XG4gICBuYW1lOiBzdHJpbmc7XG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcjtcbiAgIHRhc2s6IEFueVNpbXBsZUdpdFRhc2s7XG59O1xuXG5leHBvcnQgY2xhc3MgVGFza3NQZW5kaW5nUXVldWUge1xuICAgcHJpdmF0ZSBfcXVldWU6IE1hcDxBbnlTaW1wbGVHaXRUYXNrLCBUYXNrSW5Qcm9ncmVzcz4gPSBuZXcgTWFwKCk7XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9nTGFiZWwgPSAnR2l0RXhlY3V0b3InKSB7fVxuXG4gICBwcml2YXRlIHdpdGhQcm9ncmVzcyh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVldWUuZ2V0KHRhc2spO1xuICAgfVxuXG4gICBwcml2YXRlIGNyZWF0ZVByb2dyZXNzKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBuYW1lID0gVGFza3NQZW5kaW5nUXVldWUuZ2V0TmFtZSh0YXNrLmNvbW1hbmRzWzBdKTtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih0aGlzLmxvZ0xhYmVsLCBuYW1lKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHRhc2ssXG4gICAgICAgICBsb2dnZXIsXG4gICAgICAgICBuYW1lLFxuICAgICAgfTtcbiAgIH1cblxuICAgcHVzaCh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKTogVGFza0luUHJvZ3Jlc3Mge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLmNyZWF0ZVByb2dyZXNzKHRhc2spO1xuICAgICAgcHJvZ3Jlc3MubG9nZ2VyKCdBZGRpbmcgdGFzayB0byB0aGUgcXVldWUsIGNvbW1hbmRzID0gJW8nLCB0YXNrLmNvbW1hbmRzKTtcblxuICAgICAgdGhpcy5fcXVldWUuc2V0KHRhc2ssIHByb2dyZXNzKTtcblxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgfVxuXG4gICBmYXRhbChlcnI6IEdpdEVycm9yKSB7XG4gICAgICBmb3IgKGNvbnN0IFt0YXNrLCB7IGxvZ2dlciB9XSBvZiBBcnJheS5mcm9tKHRoaXMuX3F1ZXVlLmVudHJpZXMoKSkpIHtcbiAgICAgICAgIGlmICh0YXNrID09PSBlcnIudGFzaykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZhaWxlZCAlb2AsIGVycik7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICBgRmF0YWwgZXhjZXB0aW9uLCBhbnkgYXMteWV0IHVuLXN0YXJ0ZWQgdGFza3MgcnVuIHRocm91Z2ggdGhpcyBleGVjdXRvciB3aWxsIG5vdCBiZSBhdHRlbXB0ZWRgXG4gICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICAgYEEgZmF0YWwgZXhjZXB0aW9uIG9jY3VycmVkIGluIGEgcHJldmlvdXMgdGFzaywgdGhlIHF1ZXVlIGhhcyBiZWVuIHB1cmdlZDogJW9gLFxuICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuY29tcGxldGUodGFzayk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1ZXVlIHNpemUgc2hvdWxkIGJlIHplcm8gYWZ0ZXIgZmF0YWw6ICR7dGhpcy5fcXVldWUuc2l6ZX1gKTtcbiAgICAgIH1cbiAgIH1cblxuICAgY29tcGxldGUodGFzazogQW55U2ltcGxlR2l0VGFzaykge1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgdGhpcy5fcXVldWUuZGVsZXRlKHRhc2spO1xuICAgICAgfVxuICAgfVxuXG4gICBhdHRlbXB0KHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMud2l0aFByb2dyZXNzKHRhc2spO1xuICAgICAgaWYgKCFwcm9ncmVzcykge1xuICAgICAgICAgdGhyb3cgbmV3IEdpdEVycm9yKHVuZGVmaW5lZCwgJ1Rhc2tzUGVuZGluZ1F1ZXVlOiBhdHRlbXB0IGNhbGxlZCBmb3IgYW4gdW5rbm93biB0YXNrJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmVzcy5sb2dnZXIoJ1N0YXJ0aW5nIHRhc2snKTtcblxuICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgfVxuXG4gICBzdGF0aWMgZ2V0TmFtZShuYW1lID0gJ2VtcHR5Jykge1xuICAgICAgcmV0dXJuIGB0YXNrOiR7bmFtZX06JHsrK1Rhc2tzUGVuZGluZ1F1ZXVlLmNvdW50ZXJ9YDtcbiAgIH1cblxuICAgcHJpdmF0ZSBzdGF0aWMgY291bnRlciA9IDA7XG59XG4iLCAiaW1wb3J0IHsgc3Bhd24sIFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IE91dHB1dExvZ2dlciB9IGZyb20gJy4uL2dpdC1sb2dnZXInO1xuaW1wb3J0IHsgUGx1Z2luU3RvcmUgfSBmcm9tICcuLi9wbHVnaW5zJztcbmltcG9ydCB7IEVtcHR5VGFzaywgaXNCdWZmZXJUYXNrLCBpc0VtcHR5VGFzayB9IGZyb20gJy4uL3Rhc2tzL3Rhc2snO1xuaW1wb3J0IHtcbiAgIEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgTWF5YmUsXG4gICBvdXRwdXRIYW5kbGVyLFxuICAgUnVubmFibGVUYXNrLFxuICAgU2ltcGxlR2l0RXhlY3V0b3IsXG4gICBTaW1wbGVHaXRUYXNrLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjYWxsVGFza1BhcnNlciwgZmlyc3QsIEdpdE91dHB1dFN0cmVhbXMsIG9iamVjdFRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXInO1xuaW1wb3J0IHsgVGFza3NQZW5kaW5nUXVldWUgfSBmcm9tICcuL3Rhc2tzLXBlbmRpbmctcXVldWUnO1xuXG5leHBvcnQgY2xhc3MgR2l0RXhlY3V0b3JDaGFpbiBpbXBsZW1lbnRzIFNpbXBsZUdpdEV4ZWN1dG9yIHtcbiAgIHByaXZhdGUgX2NoYWluOiBQcm9taXNlPGFueT4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgIHByaXZhdGUgX3F1ZXVlID0gbmV3IFRhc2tzUGVuZGluZ1F1ZXVlKCk7XG4gICBwcml2YXRlIF9jd2Q6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgcHVibGljIGdldCBiaW5hcnkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXhlY3V0b3IuYmluYXJ5O1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGN3ZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jd2QgfHwgdGhpcy5fZXhlY3V0b3IuY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgc2V0IGN3ZChjd2Q6IHN0cmluZykge1xuICAgICAgdGhpcy5fY3dkID0gY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGVudigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5lbnY7XG4gICB9XG5cbiAgIHB1YmxpYyBnZXQgb3V0cHV0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyO1xuICAgfVxuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX2V4ZWN1dG9yOiBTaW1wbGVHaXRFeGVjdXRvcixcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgcHVibGljIGNoYWluKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1YmxpYyBwdXNoPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG5cbiAgICAgIHJldHVybiAodGhpcy5fY2hhaW4gPSB0aGlzLl9jaGFpbi50aGVuKCgpID0+IHRoaXMuYXR0ZW1wdFRhc2sodGFzaykpKTtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0VGFzazxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+KTogUHJvbWlzZTx2b2lkIHwgUj4ge1xuICAgICAgY29uc3Qgb25TY2hlZHVsZUNvbXBsZXRlID0gYXdhaXQgdGhpcy5fc2NoZWR1bGVyLm5leHQoKTtcbiAgICAgIGNvbnN0IG9uUXVldWVDb21wbGV0ZSA9ICgpID0+IHRoaXMuX3F1ZXVlLmNvbXBsZXRlKHRhc2spO1xuXG4gICAgICB0cnkge1xuICAgICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuX3F1ZXVlLmF0dGVtcHQodGFzayk7XG4gICAgICAgICByZXR1cm4gKGF3YWl0IChpc0VtcHR5VGFzayh0YXNrKVxuICAgICAgICAgICAgPyB0aGlzLmF0dGVtcHRFbXB0eVRhc2sodGFzaywgbG9nZ2VyKVxuICAgICAgICAgICAgOiB0aGlzLmF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcikpKSBhcyBSO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgdGhyb3cgdGhpcy5vbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUgYXMgRXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgIG9uUXVldWVDb21wbGV0ZSgpO1xuICAgICAgICAgb25TY2hlZHVsZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHByaXZhdGUgb25GYXRhbEV4Y2VwdGlvbjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBlOiBFcnJvcikge1xuICAgICAgY29uc3QgZ2l0RXJyb3IgPVxuICAgICAgICAgZSBpbnN0YW5jZW9mIEdpdEVycm9yID8gT2JqZWN0LmFzc2lnbihlLCB7IHRhc2sgfSkgOiBuZXcgR2l0RXJyb3IodGFzaywgZSAmJiBTdHJpbmcoZSkpO1xuXG4gICAgICB0aGlzLl9jaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcXVldWUuZmF0YWwoZ2l0RXJyb3IpO1xuXG4gICAgICByZXR1cm4gZ2l0RXJyb3I7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdFJlbW90ZVRhc2s8Uj4odGFzazogUnVubmFibGVUYXNrPFI+LCBsb2dnZXI6IE91dHB1dExvZ2dlcikge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5hcmdzJyxcbiAgICAgICAgIFsuLi50YXNrLmNvbW1hbmRzXSxcbiAgICAgICAgIHBsdWdpbkNvbnRleHQodGFzaywgdGFzay5jb21tYW5kcylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJhdyA9IGF3YWl0IHRoaXMuZ2l0UmVzcG9uc2UoXG4gICAgICAgICB0YXNrLFxuICAgICAgICAgdGhpcy5iaW5hcnksXG4gICAgICAgICBhcmdzLFxuICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyLFxuICAgICAgICAgbG9nZ2VyLnN0ZXAoJ1NQQVdOJylcbiAgICAgICk7XG4gICAgICBjb25zdCBvdXRwdXRTdHJlYW1zID0gYXdhaXQgdGhpcy5oYW5kbGVUYXNrRGF0YSh0YXNrLCBhcmdzLCByYXcsIGxvZ2dlci5zdGVwKCdIQU5ETEUnKSk7XG5cbiAgICAgIGxvZ2dlcihgcGFzc2luZyByZXNwb25zZSB0byB0YXNrJ3MgcGFyc2VyIGFzIGEgJXNgLCB0YXNrLmZvcm1hdCk7XG5cbiAgICAgIGlmIChpc0J1ZmZlclRhc2sodGFzaykpIHtcbiAgICAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcy5hc1N0cmluZ3MoKSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdEVtcHR5VGFzayh0YXNrOiBFbXB0eVRhc2ssIGxvZ2dlcjogT3V0cHV0TG9nZ2VyKSB7XG4gICAgICBsb2dnZXIoYGVtcHR5IHRhc2sgYnlwYXNzaW5nIGNoaWxkIHByb2Nlc3MgdG8gY2FsbCB0byB0YXNrJ3MgcGFyc2VyYCk7XG4gICAgICByZXR1cm4gdGFzay5wYXJzZXIodGhpcyk7XG4gICB9XG5cbiAgIHByaXZhdGUgaGFuZGxlVGFza0RhdGE8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICByZXN1bHQ6IEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgICAgbG9nZ2VyOiBPdXRwdXRMb2dnZXJcbiAgICk6IFByb21pc2U8R2l0T3V0cHV0U3RyZWFtcz4ge1xuICAgICAgY29uc3QgeyBleGl0Q29kZSwgcmVqZWN0aW9uLCBzdGRPdXQsIHN0ZEVyciB9ID0gcmVzdWx0O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUsIGZhaWwpID0+IHtcbiAgICAgICAgIGxvZ2dlcihgUHJlcGFyaW5nIHRvIGhhbmRsZSBwcm9jZXNzIHJlc3BvbnNlIGV4aXRDb2RlPSVkIHN0ZE91dD1gLCBleGl0Q29kZSk7XG5cbiAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICAgICd0YXNrLmVycm9yJyxcbiAgICAgICAgICAgIHsgZXJyb3I6IHJlamVjdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICk7XG5cbiAgICAgICAgIGlmIChlcnJvciAmJiB0YXNrLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBleGl0Q29kZT0lcyBoYW5kbGluZyB3aXRoIGN1c3RvbSBlcnJvciBoYW5kbGVyYCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXNrLm9uRXJyb3IoXG4gICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgIChuZXdTdGRPdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBjdXN0b20gZXJyb3IgaGFuZGxlciB0cmVhdGVkIGFzIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlcihgY3VzdG9tIGVycm9yIHJldHVybmVkIGEgJXNgLCBvYmplY3RUb1N0cmluZyhuZXdTdGRPdXQpKTtcblxuICAgICAgICAgICAgICAgICAgZG9uZShcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBHaXRPdXRwdXRTdHJlYW1zKFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShuZXdTdGRPdXQpID8gQnVmZmVyLmNvbmNhdChuZXdTdGRPdXQpIDogbmV3U3RkT3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChzdGRFcnIpXG4gICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIGZhaWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICBgaGFuZGxpbmcgYXMgZXJyb3I6IGV4aXRDb2RlPSVzIHN0ZEVycj0lcyByZWplY3Rpb249JW9gLFxuICAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgICBzdGRFcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBsb2dnZXIuaW5mbyhgcmV0cmlldmluZyB0YXNrIG91dHB1dCBjb21wbGV0ZWApO1xuICAgICAgICAgZG9uZShuZXcgR2l0T3V0cHV0U3RyZWFtcyhCdWZmZXIuY29uY2F0KHN0ZE91dCksIEJ1ZmZlci5jb25jYXQoc3RkRXJyKSkpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgZ2l0UmVzcG9uc2U8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgY29tbWFuZDogc3RyaW5nLFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICBvdXRwdXRIYW5kbGVyOiBNYXliZTxvdXRwdXRIYW5kbGVyPixcbiAgICAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyXG4gICApOiBQcm9taXNlPEdpdEV4ZWN1dG9yUmVzdWx0PiB7XG4gICAgICBjb25zdCBvdXRwdXRMb2dnZXIgPSBsb2dnZXIuc2libGluZygnb3V0cHV0Jyk7XG4gICAgICBjb25zdCBzcGF3bk9wdGlvbnM6IFNwYXduT3B0aW9ucyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5vcHRpb25zJyxcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICAgICB9LFxuICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiB7XG4gICAgICAgICBjb25zdCBzdGRPdXQ6IEJ1ZmZlcltdID0gW107XG4gICAgICAgICBjb25zdCBzdGRFcnI6IEJ1ZmZlcltdID0gW107XG5cbiAgICAgICAgIGxvZ2dlci5pbmZvKGAlcyAlb2AsIGNvbW1hbmQsIGFyZ3MpO1xuICAgICAgICAgbG9nZ2VyKCclTycsIHNwYXduT3B0aW9ucyk7XG5cbiAgICAgICAgIGxldCByZWplY3Rpb24gPSB0aGlzLl9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKTtcbiAgICAgICAgIGlmIChyZWplY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKHtcbiAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgIGV4aXRDb2RlOiA5OTAxLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYygnc3Bhd24uYmVmb3JlJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGNvbnN0IHNwYXduZWQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBzcGF3bk9wdGlvbnMpO1xuXG4gICAgICAgICBzcGF3bmVkLnN0ZG91dCEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRPdXQsICdzdGRPdXQnLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRPdXQnKSlcbiAgICAgICAgICk7XG4gICAgICAgICBzcGF3bmVkLnN0ZGVyciEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRFcnIsICdzdGRFcnInLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRFcnInKSlcbiAgICAgICAgICk7XG5cbiAgICAgICAgIHNwYXduZWQub24oJ2Vycm9yJywgb25FcnJvclJlY2VpdmVkKHN0ZEVyciwgbG9nZ2VyKSk7XG5cbiAgICAgICAgIGlmIChvdXRwdXRIYW5kbGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIoYFBhc3NpbmcgY2hpbGQgcHJvY2VzcyBzdGRPdXQvc3RkRXJyIHRvIGN1c3RvbSBvdXRwdXRIYW5kbGVyYCk7XG4gICAgICAgICAgICBvdXRwdXRIYW5kbGVyKGNvbW1hbmQsIHNwYXduZWQuc3Rkb3V0ISwgc3Bhd25lZC5zdGRlcnIhLCBbLi4uYXJnc10pO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoJ3NwYXduLmFmdGVyJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgc3Bhd25lZCxcbiAgICAgICAgICAgIGNsb3NlKGV4aXRDb2RlOiBudW1iZXIsIHJlYXNvbj86IEVycm9yKSB7XG4gICAgICAgICAgICAgICBkb25lKHtcbiAgICAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0aW9uOiByZWplY3Rpb24gfHwgcmVhc29uLFxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbChyZWFzb246IEVycm9yKSB7XG4gICAgICAgICAgICAgICBpZiAoc3Bhd25lZC5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uO1xuICAgICAgICAgICAgICAgc3Bhd25lZC5raWxsKCdTSUdJTlQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBwcml2YXRlIF9iZWZvcmVTcGF3bjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgbGV0IHJlamVjdGlvbjogTWF5YmU8RXJyb3I+O1xuICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKCdzcGF3bi5iZWZvcmUnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgIH1cbn1cblxuZnVuY3Rpb24gcGx1Z2luQ29udGV4dDxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBjb21tYW5kczogc3RyaW5nW10pIHtcbiAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IGZpcnN0KHRhc2suY29tbWFuZHMpIHx8ICcnLFxuICAgICAgY29tbWFuZHMsXG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkVycm9yUmVjZWl2ZWQodGFyZ2V0OiBCdWZmZXJbXSwgbG9nZ2VyOiBPdXRwdXRMb2dnZXIpIHtcbiAgIHJldHVybiAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyKGBbRVJST1JdIGNoaWxkIHByb2Nlc3MgZXhjZXB0aW9uICVvYCwgZXJyKTtcbiAgICAgIHRhcmdldC5wdXNoKEJ1ZmZlci5mcm9tKFN0cmluZyhlcnIuc3RhY2spLCAnYXNjaWknKSk7XG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkRhdGFSZWNlaXZlZChcbiAgIHRhcmdldDogQnVmZmVyW10sXG4gICBuYW1lOiBzdHJpbmcsXG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcixcbiAgIG91dHB1dDogT3V0cHV0TG9nZ2VyXG4pIHtcbiAgIHJldHVybiAoYnVmZmVyOiBCdWZmZXIpID0+IHtcbiAgICAgIGxvZ2dlcihgJXMgcmVjZWl2ZWQgJUwgYnl0ZXNgLCBuYW1lLCBidWZmZXIpO1xuICAgICAgb3V0cHV0KGAlQmAsIGJ1ZmZlcik7XG4gICAgICB0YXJnZXQucHVzaChidWZmZXIpO1xuICAgfTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFBsdWdpblN0b3JlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgdHlwZSB7IEdpdEV4ZWN1dG9yRW52LCBvdXRwdXRIYW5kbGVyLCBTaW1wbGVHaXRFeGVjdXRvciwgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgR2l0RXhlY3V0b3JDaGFpbiB9IGZyb20gJy4vZ2l0LWV4ZWN1dG9yLWNoYWluJztcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyJztcblxuZXhwb3J0IGNsYXNzIEdpdEV4ZWN1dG9yIGltcGxlbWVudHMgU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgcHJpdmF0ZSBfY2hhaW4gPSBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuXG4gICBwdWJsaWMgZW52OiBHaXRFeGVjdXRvckVudjtcbiAgIHB1YmxpYyBvdXRwdXRIYW5kbGVyPzogb3V0cHV0SGFuZGxlcjtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgYmluYXJ5OiBzdHJpbmcgPSAnZ2l0JyxcbiAgICAgIHB1YmxpYyBjd2Q6IHN0cmluZyxcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgY2hhaW4oKTogU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgICAgcmV0dXJuIG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICB9XG5cbiAgIHB1c2g8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IFByb21pc2U8Uj4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYWluLnB1c2godGFzayk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBTaW1wbGVHaXRUYXNrLCBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE5PT1AgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRhc2tDYWxsYmFjazxSPihcbiAgIHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4sXG4gICByZXNwb25zZTogUHJvbWlzZTxSPixcbiAgIGNhbGxiYWNrOiBTaW1wbGVHaXRUYXNrQ2FsbGJhY2s8Uj4gPSBOT09QXG4pIHtcbiAgIGNvbnN0IG9uU3VjY2VzcyA9IChkYXRhOiBSKSA9PiB7XG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgIH07XG5cbiAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyOiBHaXRFcnJvciB8IEdpdFJlc3BvbnNlRXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnI/LnRhc2sgPT09IHRhc2spIHtcbiAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgR2l0UmVzcG9uc2VFcnJvciA/IGFkZERlcHJlY2F0aW9uTm90aWNlVG9FcnJvcihlcnIpIDogZXJyLFxuICAgICAgICAgICAgdW5kZWZpbmVkIGFzIGFueVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgIH07XG5cbiAgIHJlc3BvbnNlLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbn1cblxuZnVuY3Rpb24gYWRkRGVwcmVjYXRpb25Ob3RpY2VUb0Vycm9yKGVycjogR2l0UmVzcG9uc2VFcnJvcikge1xuICAgbGV0IGxvZyA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgIGBzaW1wbGUtZ2l0IGRlcHJlY2F0aW9uIG5vdGljZTogYWNjZXNzaW5nIEdpdFJlc3BvbnNlRXJyb3IuJHtuYW1lfSBzaG91bGQgYmUgR2l0UmVzcG9uc2VFcnJvci5naXQuJHtuYW1lfSwgdGhpcyB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUgaW4gdmVyc2lvbiAzYFxuICAgICAgKTtcbiAgICAgIGxvZyA9IE5PT1A7XG4gICB9O1xuXG4gICByZXR1cm4gT2JqZWN0LmNyZWF0ZShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVyci5naXQpLnJlZHVjZShkZXNjcmlwdG9yUmVkdWNlciwge30pKTtcblxuICAgZnVuY3Rpb24gZGVzY3JpcHRvclJlZHVjZXIoYWxsOiBQcm9wZXJ0eURlc2NyaXB0b3JNYXAsIG5hbWU6IHN0cmluZyk6IHR5cGVvZiBhbGwge1xuICAgICAgaWYgKG5hbWUgaW4gZXJyKSB7XG4gICAgICAgICByZXR1cm4gYWxsO1xuICAgICAgfVxuXG4gICAgICBhbGxbbmFtZV0gPSB7XG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBsb2cobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyLmdpdFtuYW1lXTtcbiAgICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWxsO1xuICAgfVxufVxuIiwgImltcG9ydCB7IGZvbGRlckV4aXN0cyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEV4ZWN1dG9yIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYWRob2NFeGVjVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3Rvcnk6IHN0cmluZywgcm9vdD86IFNpbXBsZUdpdEV4ZWN1dG9yKSB7XG4gICByZXR1cm4gYWRob2NFeGVjVGFzaygoaW5zdGFuY2U6IFNpbXBsZUdpdEV4ZWN1dG9yKSA9PiB7XG4gICAgICBpZiAoIWZvbGRlckV4aXN0cyhkaXJlY3RvcnkpKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdC5jd2Q6IGNhbm5vdCBjaGFuZ2UgdG8gbm9uLWRpcmVjdG9yeSBcIiR7ZGlyZWN0b3J5fVwiYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKHJvb3QgfHwgaW5zdGFuY2UpLmN3ZCA9IGRpcmVjdG9yeSk7XG4gICB9KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHJlbW92ZSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmZ1bmN0aW9uIGNoZWNrb3V0VGFzayhhcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2NoZWNrb3V0JywgLi4uYXJnc107XG4gICBpZiAoY29tbWFuZHNbMV0gPT09ICctYicgJiYgY29tbWFuZHMuaW5jbHVkZXMoJy1CJykpIHtcbiAgICAgIGNvbW1hbmRzWzFdID0gcmVtb3ZlKGNvbW1hbmRzLCAnLUInKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdjaGVja291dCcgfCAnY2hlY2tvdXRCcmFuY2gnIHwgJ2NoZWNrb3V0TG9jYWxCcmFuY2gnPiB7XG4gICByZXR1cm4ge1xuICAgICAgY2hlY2tvdXQodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrb3V0QnJhbmNoKHRoaXM6IFNpbXBsZUdpdEFwaSwgYnJhbmNoTmFtZSwgc3RhcnRQb2ludCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGVja291dFRhc2soWyctYicsIGJyYW5jaE5hbWUsIHN0YXJ0UG9pbnQsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICAgIGNoZWNrb3V0TG9jYWxCcmFuY2godGhpczogU2ltcGxlR2l0QXBpLCBicmFuY2hOYW1lKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoZWNrb3V0VGFzayhbJy1iJywgYnJhbmNoTmFtZSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPENvbW1pdFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eXFxbKFteXFxzXSspKCBcXChbXildK1xcKSk/IChbXlxcXV0rKS8sIChyZXN1bHQsIFticmFuY2gsIHJvb3QsIGNvbW1pdF0pID0+IHtcbiAgICAgIHJlc3VsdC5icmFuY2ggPSBicmFuY2g7XG4gICAgICByZXN1bHQuY29tbWl0ID0gY29tbWl0O1xuICAgICAgcmVzdWx0LnJvb3QgPSAhIXJvb3Q7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXHMqQXV0aG9yOlxccyguKykvaSwgKHJlc3VsdCwgW2F1dGhvcl0pID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYXV0aG9yLnNwbGl0KCc8Jyk7XG4gICAgICBjb25zdCBlbWFpbCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAoIWVtYWlsIHx8ICFlbWFpbC5pbmNsdWRlcygnQCcpKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5hdXRob3IgPSB7XG4gICAgICAgICBlbWFpbDogZW1haWwuc3Vic3RyKDAsIGVtYWlsLmxlbmd0aCAtIDEpLFxuICAgICAgICAgbmFtZTogcGFydHMuam9pbignPCcpLnRyaW0oKSxcbiAgICAgIH07XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgLyhcXGQrKVteLF0qKD86LFxccyooXFxkKylbXixdKikoPzosXFxzKihcXGQrKSkvZyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gcGFyc2VJbnQoY2hhbmdlcywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gcGFyc2VJbnQoaW5zZXJ0aW9ucywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBwYXJzZUludChkZWxldGlvbnMsIDEwKSB8fCAwO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oXFxkKylbXixdKig/OixcXHMqKFxcZCspW14oXStcXCgoWystXSkpPy8sXG4gICAgICAocmVzdWx0LCBbY2hhbmdlcywgbGluZXMsIGRpcmVjdGlvbl0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobGluZXMsIDEwKSB8fCAwO1xuICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb21taXRSZXN1bHQoc3RkT3V0OiBzdHJpbmcpOiBDb21taXRSZXN1bHQge1xuICAgY29uc3QgcmVzdWx0OiBDb21taXRSZXN1bHQgPSB7XG4gICAgICBhdXRob3I6IG51bGwsXG4gICAgICBicmFuY2g6ICcnLFxuICAgICAgY29tbWl0OiAnJyxcbiAgICAgIHJvb3Q6IGZhbHNlLFxuICAgICAgc3VtbWFyeToge1xuICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgIGluc2VydGlvbnM6IDAsXG4gICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICB9LFxuICAgfTtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IENvbW1pdFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1jb21taXQnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgcHJlZml4ZWRBcnJheSxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRUYXNrKFxuICAgbWVzc2FnZTogc3RyaW5nW10sXG4gICBmaWxlczogc3RyaW5nW10sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxDb21taXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFtcbiAgICAgICctYycsXG4gICAgICAnY29yZS5hYmJyZXY9NDAnLFxuICAgICAgJ2NvbW1pdCcsXG4gICAgICAuLi5wcmVmaXhlZEFycmF5KG1lc3NhZ2UsICctbScpLFxuICAgICAgLi4uZmlsZXMsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUNvbW1pdFJlc3VsdCxcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2NvbW1pdCc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21taXQodGhpczogU2ltcGxlR2l0QXBpLCBtZXNzYWdlOiBzdHJpbmcgfCBzdHJpbmdbXSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHx8XG4gICAgICAgICAgICBjb21taXRUYXNrKFxuICAgICAgICAgICAgICAgYXNBcnJheShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgIGFzQXJyYXkoZmlsdGVyVHlwZShyZXN0WzBdLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpLFxuICAgICAgICAgICAgICAgWy4uLmZpbHRlclR5cGUocmVzdFsxXSwgZmlsdGVyQXJyYXksIFtdKSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSldXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlPzogdW5rbm93bikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KG1lc3NhZ2UpICYmXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgYGdpdC5jb21taXQ6IHJlcXVpcmVzIHRoZSBjb21taXQgbWVzc2FnZSB0byBiZSBzdXBwbGllZCBhcyBhIHN0cmluZy9zdHJpbmdbXWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgUmVzcG9uc2UsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHsgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2ZpcnN0Q29tbWl0Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0Q29tbWl0KHRoaXM6IFNpbXBsZUdpdEFwaSk6IFJlc3BvbnNlPHN0cmluZz4ge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2LWxpc3QnLCAnLS1tYXgtcGFyZW50cz0wJywgJ0hFQUQnXSwgdHJ1ZSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5oYXNoT2JqZWN0YFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE9iamVjdFRhc2soZmlsZVBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2hhc2gtb2JqZWN0JywgZmlsZVBhdGhdO1xuICAgaWYgKHdyaXRlKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctdycpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSk7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgSW5pdFN1bW1hcnkgaW1wbGVtZW50cyBJbml0UmVzdWx0IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IGJhcmU6IGJvb2xlYW4sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGV4aXN0aW5nOiBib29sZWFuLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdERpcjogc3RyaW5nXG4gICApIHt9XG59XG5cbmNvbnN0IGluaXRSZXNwb25zZVJlZ2V4ID0gL15Jbml0LisgcmVwb3NpdG9yeSBpbiAoLispJC87XG5jb25zdCByZUluaXRSZXNwb25zZVJlZ2V4ID0gL15SZWluLisgaW4gKC4rKSQvO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbml0KGJhcmU6IGJvb2xlYW4sIHBhdGg6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICBjb25zdCByZXNwb25zZSA9IFN0cmluZyh0ZXh0KS50cmltKCk7XG4gICBsZXQgcmVzdWx0O1xuXG4gICBpZiAoKHJlc3VsdCA9IGluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCBmYWxzZSwgcmVzdWx0WzFdKTtcbiAgIH1cblxuICAgaWYgKChyZXN1bHQgPSByZUluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCB0cnVlLCByZXN1bHRbMV0pO1xuICAgfVxuXG4gICBsZXQgZ2l0RGlyID0gJyc7XG4gICBjb25zdCB0b2tlbnMgPSByZXNwb25zZS5zcGxpdCgnICcpO1xuICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodG9rZW4gPT09ICdpbicpIHtcbiAgICAgICAgIGdpdERpciA9IHRva2Vucy5qb2luKCcgJyk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCAvXnJlL2kudGVzdChyZXNwb25zZSksIGdpdERpcik7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VJbml0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0luaXRTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGJhcmVDb21tYW5kID0gJy0tYmFyZSc7XG5cbmZ1bmN0aW9uIGhhc0JhcmVDb21tYW5kKGNvbW1hbmQ6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gY29tbWFuZC5pbmNsdWRlcyhiYXJlQ29tbWFuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0VGFzayhiYXJlID0gZmFsc2UsIHBhdGg6IHN0cmluZywgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPEluaXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydpbml0JywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAoYmFyZSAmJiAhaGFzQmFyZUNvbW1hbmQoY29tbWFuZHMpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYmFyZUNvbW1hbmQpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKTogSW5pdFJlc3VsdCB7XG4gICAgICAgICByZXR1cm4gcGFyc2VJbml0KGNvbW1hbmRzLmluY2x1ZGVzKCctLWJhcmUnKSwgcGF0aCwgdGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBMb2dGb3JtYXQge1xuICAgTk9ORSA9ICcnLFxuICAgU1RBVCA9ICctLXN0YXQnLFxuICAgTlVNX1NUQVQgPSAnLS1udW1zdGF0JyxcbiAgIE5BTUVfT05MWSA9ICctLW5hbWUtb25seScsXG4gICBOQU1FX1NUQVRVUyA9ICctLW5hbWUtc3RhdHVzJyxcbn1cblxuY29uc3QgbG9nRm9ybWF0UmVnZXggPSAvXi0tKHN0YXR8bnVtc3RhdHxuYW1lLW9ubHl8bmFtZS1zdGF0dXMpKD18JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZm9ybWF0ID0gbG9nRm9ybWF0UmVnZXguZXhlYyhjdXN0b21BcmdzW2ldKTtcbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgIHJldHVybiBgLS0ke2Zvcm1hdFsxXX1gIGFzIExvZ0Zvcm1hdDtcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIExvZ0Zvcm1hdC5OT05FO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2dGb3JtYXQoY3VzdG9tQXJnOiBzdHJpbmcgfCB1bmtub3duKSB7XG4gICByZXR1cm4gbG9nRm9ybWF0UmVnZXgudGVzdChjdXN0b21BcmcgYXMgc3RyaW5nKTtcbn1cbiIsICJpbXBvcnQgeyBEaWZmUmVzdWx0LCBEaWZmUmVzdWx0QmluYXJ5RmlsZSwgRGlmZlJlc3VsdFRleHRGaWxlIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbi8qKipcbiAqIFRoZSBEaWZmU3VtbWFyeSBpcyByZXR1cm5lZCBhcyBhIHJlc3BvbnNlIHRvIGdldHRpbmcgYGdpdCgpLnN0YXR1cygpYFxuICovXG5leHBvcnQgY2xhc3MgRGlmZlN1bW1hcnkgaW1wbGVtZW50cyBEaWZmUmVzdWx0IHtcbiAgIGNoYW5nZWQgPSAwO1xuICAgZGVsZXRpb25zID0gMDtcbiAgIGluc2VydGlvbnMgPSAwO1xuXG4gICBmaWxlczogQXJyYXk8RGlmZlJlc3VsdFRleHRGaWxlIHwgRGlmZlJlc3VsdEJpbmFyeUZpbGU+ID0gW107XG59XG4iLCAiaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTG9nRm9ybWF0IH0gZnJvbSAnLi4vYXJncy9sb2ctZm9ybWF0JztcbmltcG9ydCB7IERpZmZTdW1tYXJ5IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0RpZmZTdW1tYXJ5JztcbmltcG9ydCB7IGlzRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuLi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBMaW5lUGFyc2VyLCBvclZvaWQsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHN0YXRQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oLispXFxzK1xcfFxccysoXFxkKykoXFxzK1srXFwtXSspPyQvLFxuICAgICAgKHJlc3VsdCwgW2ZpbGUsIGNoYW5nZXMsIGFsdGVyYXRpb25zID0gJyddKSA9PiB7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGFzTnVtYmVyKGNoYW5nZXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14rXS9nLCAnJykubGVuZ3RoLFxuICAgICAgICAgICAgZGVsZXRpb25zOiBhbHRlcmF0aW9ucy5yZXBsYWNlKC9bXi1dL2csICcnKS5sZW5ndGgsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKC4rKSBcXHxcXHMrQmluIChbMC05Ll0rKSAtPiAoWzAtOS5dKykgKFthLXpdKykvLFxuICAgICAgKHJlc3VsdCwgW2ZpbGUsIGJlZm9yZSwgYWZ0ZXJdKSA9PiB7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiBmaWxlLnRyaW0oKSxcbiAgICAgICAgICAgIGJlZm9yZTogYXNOdW1iZXIoYmVmb3JlKSxcbiAgICAgICAgICAgIGFmdGVyOiBhc051bWJlcihhZnRlciksXG4gICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oXFxkKykgZmlsZXM/IGNoYW5nZWRcXHMqKCg/OiwgXFxkKyBbXixdKyl7MCwyfSkvLFxuICAgICAgKHJlc3VsdCwgW2NoYW5nZWQsIHN1bW1hcnldKSA9PiB7XG4gICAgICAgICBjb25zdCBpbnNlcnRlZCA9IC8oXFxkKykgaS8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSAvKFxcZCspIGQvLmV4ZWMoc3VtbWFyeSk7XG5cbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkID0gYXNOdW1iZXIoY2hhbmdlZCk7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGluc2VydGVkPy5bMV0pO1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyA9IGFzTnVtYmVyKGRlbGV0ZWQ/LlsxXSk7XG4gICAgICB9XG4gICApLFxuXTtcblxuY29uc3QgbnVtU3RhdFBhcnNlciA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgLyhcXGQrKVxcdChcXGQrKVxcdCguKykkLyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzSW5zZXJ0LCBjaGFuZ2VzRGVsZXRlLCBmaWxlXSkgPT4ge1xuICAgICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IGFzTnVtYmVyKGNoYW5nZXNJbnNlcnQpO1xuICAgICAgICAgY29uc3QgZGVsZXRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0RlbGV0ZSk7XG5cbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyArPSBpbnNlcnRpb25zO1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9ucyArPSBkZWxldGlvbnM7XG5cbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBjaGFuZ2VzOiBpbnNlcnRpb25zICsgZGVsZXRpb25zLFxuICAgICAgICAgICAgaW5zZXJ0aW9ucyxcbiAgICAgICAgICAgIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PigvLVxcdC1cXHQoLispJC8sIChyZXN1bHQsIFtmaWxlXSkgPT4ge1xuICAgICAgcmVzdWx0LmNoYW5nZWQrKztcblxuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgZmlsZSxcbiAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgYmVmb3JlOiAwLFxuICAgICAgICAgYmluYXJ5OiB0cnVlLFxuICAgICAgfSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IG5hbWVPbmx5UGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oLyguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgZmlsZSxcbiAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgIH0pO1xuICAgfSksXG5dO1xuXG5jb25zdCBuYW1lU3RhdHVzUGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKFtBQ0RNUlRVWEJdKShbMC05XXswLDN9KVxcdCguW15cXHRdKikoXFx0KC5bXlxcdF0qKSk/JC8sXG4gICAgICAocmVzdWx0LCBbc3RhdHVzLCBfc2ltaWxhcml0eSwgZnJvbSwgX3RvLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICAgICBmaWxlOiB0byA/PyBmcm9tLFxuICAgICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgICAgIHN0YXR1czogb3JWb2lkKGlzRGlmZk5hbWVTdGF0dXMoc3RhdHVzKSAmJiBzdGF0dXMpLFxuICAgICAgICAgICAgaW5zZXJ0aW9uczogMCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5jb25zdCBkaWZmU3VtbWFyeVBhcnNlcnM6IFJlY29yZDxMb2dGb3JtYXQsIExpbmVQYXJzZXI8RGlmZlJlc3VsdD5bXT4gPSB7XG4gICBbTG9nRm9ybWF0Lk5PTkVdOiBzdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5TVEFUXTogc3RhdFBhcnNlcixcbiAgIFtMb2dGb3JtYXQuTlVNX1NUQVRdOiBudW1TdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5OQU1FX1NUQVRVU106IG5hbWVTdGF0dXNQYXJzZXIsXG4gICBbTG9nRm9ybWF0Lk5BTUVfT05MWV06IG5hbWVPbmx5UGFyc2VyLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpZmZQYXJzZXIoZm9ybWF0ID0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgIGNvbnN0IHBhcnNlciA9IGRpZmZTdW1tYXJ5UGFyc2Vyc1tmb3JtYXRdO1xuXG4gICByZXR1cm4gKHN0ZE91dDogc3RyaW5nKSA9PiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBEaWZmU3VtbWFyeSgpLCBwYXJzZXIsIHN0ZE91dCwgZmFsc2UpO1xufVxuIiwgImltcG9ydCB7IExpc3RMb2dMaW5lLCBMb2dSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldERpZmZQYXJzZXIgfSBmcm9tICcuL3BhcnNlLWRpZmYtc3VtbWFyeSc7XG5pbXBvcnQgeyBMb2dGb3JtYXQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuXG5leHBvcnQgY29uc3QgU1RBUlRfQk9VTkRBUlkgPSAnXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyXHUwMEYyICc7XG5cbmV4cG9ydCBjb25zdCBDT01NSVRfQk9VTkRBUlkgPSAnIFx1MDBGMlx1MDBGMic7XG5cbmV4cG9ydCBjb25zdCBTUExJVFRFUiA9ICcgXHUwMEYyICc7XG5cbmNvbnN0IGRlZmF1bHRGaWVsZE5hbWVzID0gWydoYXNoJywgJ2RhdGUnLCAnbWVzc2FnZScsICdyZWZzJywgJ2F1dGhvcl9uYW1lJywgJ2F1dGhvcl9lbWFpbCddO1xuXG5mdW5jdGlvbiBsaW5lQnVpbGRlcih0b2tlbnM6IHN0cmluZ1tdLCBmaWVsZHM6IHN0cmluZ1tdKTogYW55IHtcbiAgIHJldHVybiBmaWVsZHMucmVkdWNlKFxuICAgICAgKGxpbmUsIGZpZWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgbGluZVtmaWVsZF0gPSB0b2tlbnNbaW5kZXhdIHx8ICcnO1xuICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9LFxuICAgICAgT2JqZWN0LmNyZWF0ZSh7IGRpZmY6IG51bGwgfSkgYXMgYW55XG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdExvZ1N1bW1hcnlQYXJzZXI8VCA9IGFueT4oXG4gICBzcGxpdHRlciA9IFNQTElUVEVSLFxuICAgZmllbGRzID0gZGVmYXVsdEZpZWxkTmFtZXMsXG4gICBsb2dGb3JtYXQgPSBMb2dGb3JtYXQuTk9ORVxuKSB7XG4gICBjb25zdCBwYXJzZURpZmZSZXN1bHQgPSBnZXREaWZmUGFyc2VyKGxvZ0Zvcm1hdCk7XG5cbiAgIHJldHVybiBmdW5jdGlvbiAoc3RkT3V0OiBzdHJpbmcpOiBMb2dSZXN1bHQ8VD4ge1xuICAgICAgY29uc3QgYWxsOiBSZWFkb25seUFycmF5PFQgJiBMaXN0TG9nTGluZT4gPSB0b0xpbmVzV2l0aENvbnRlbnQoXG4gICAgICAgICBzdGRPdXQsXG4gICAgICAgICB0cnVlLFxuICAgICAgICAgU1RBUlRfQk9VTkRBUllcbiAgICAgICkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICBjb25zdCBsaW5lRGV0YWlsID0gaXRlbS50cmltKCkuc3BsaXQoQ09NTUlUX0JPVU5EQVJZKTtcbiAgICAgICAgIGNvbnN0IGxpc3RMb2dMaW5lOiBUICYgTGlzdExvZ0xpbmUgPSBsaW5lQnVpbGRlcihcbiAgICAgICAgICAgIGxpbmVEZXRhaWxbMF0udHJpbSgpLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgICAgICAgIGZpZWxkc1xuICAgICAgICAgKTtcblxuICAgICAgICAgaWYgKGxpbmVEZXRhaWwubGVuZ3RoID4gMSAmJiAhIWxpbmVEZXRhaWxbMV0udHJpbSgpKSB7XG4gICAgICAgICAgICBsaXN0TG9nTGluZS5kaWZmID0gcGFyc2VEaWZmUmVzdWx0KGxpbmVEZXRhaWxbMV0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbGlzdExvZ0xpbmU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIGFsbCxcbiAgICAgICAgIGxhdGVzdDogKGFsbC5sZW5ndGggJiYgYWxsWzBdKSB8fCBudWxsLFxuICAgICAgICAgdG90YWw6IGFsbC5sZW5ndGgsXG4gICAgICB9O1xuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgaXNMb2dGb3JtYXQsIExvZ0Zvcm1hdCwgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgZ2V0RGlmZlBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5JztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU3VtbWFyeVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPERpZmZSZXN1bHQ+IHwgRW1wdHlUYXNrIHtcbiAgIGxldCBsb2dGb3JtYXQgPSBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKTtcblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ2RpZmYnXTtcblxuICAgaWYgKGxvZ0Zvcm1hdCA9PT0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgICAgIGxvZ0Zvcm1hdCA9IExvZ0Zvcm1hdC5TVEFUO1xuICAgICAgY29tbWFuZHMucHVzaCgnLS1zdGF0PTQwOTYnKTtcbiAgIH1cblxuICAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgcmV0dXJuIChcbiAgICAgIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGNvbW1hbmRzKSB8fCB7XG4gICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgIHBhcnNlcjogZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpLFxuICAgICAgfVxuICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGN1c3RvbUFyZ3M6IHVua25vd25bXSk6IEVtcHR5VGFzayB8IHZvaWQge1xuICAgY29uc3QgZmxhZ3MgPSBjdXN0b21BcmdzLmZpbHRlcihpc0xvZ0Zvcm1hdCk7XG5cbiAgIGlmIChmbGFncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgIGBTdW1tYXJ5IGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgLSBwaWNrIG9uZSBvZiAke2ZsYWdzLmpvaW4oJywnKX1gXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAoZmxhZ3MubGVuZ3RoICYmIGN1c3RvbUFyZ3MuaW5jbHVkZXMoJy16JykpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgYFN1bW1hcnkgZmxhZyAke2ZsYWdzfSBwYXJzaW5nIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggbnVsbCB0ZXJtaW5hdGlvbiBvcHRpb24gJy16J2BcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBPcHRpb25zLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBMb2dSZXN1bHQsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuLi9hcmdzL3BhdGhzcGVjJztcbmltcG9ydCB7XG4gICBDT01NSVRfQk9VTkRBUlksXG4gICBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcixcbiAgIFNQTElUVEVSLFxuICAgU1RBUlRfQk9VTkRBUlksXG59IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQge1xuICAgYXBwZW5kVGFza09wdGlvbnMsXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxuICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcgfSBmcm9tICcuL2RpZmYnO1xuXG5lbnVtIGV4Y2x1ZGVPcHRpb25zIHtcbiAgICctLXByZXR0eScsXG4gICAnbWF4LWNvdW50JyxcbiAgICdtYXhDb3VudCcsXG4gICAnbicsXG4gICAnZmlsZScsXG4gICAnZm9ybWF0JyxcbiAgICdmcm9tJyxcbiAgICd0bycsXG4gICAnc3BsaXR0ZXInLFxuICAgJ3N5bW1ldHJpYycsXG4gICAnbWFpbE1hcCcsXG4gICAnbXVsdGlMaW5lJyxcbiAgICdzdHJpY3REYXRlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0TG9nRmllbGRzIHtcbiAgIGhhc2g6IHN0cmluZztcbiAgIGRhdGU6IHN0cmluZztcbiAgIG1lc3NhZ2U6IHN0cmluZztcbiAgIHJlZnM6IHN0cmluZztcbiAgIGJvZHk6IHN0cmluZztcbiAgIGF1dGhvcl9uYW1lOiBzdHJpbmc7XG4gICBhdXRob3JfZW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgTG9nT3B0aW9uczxUID0gRGVmYXVsdExvZ0ZpZWxkcz4gPSB7XG4gICBmaWxlPzogc3RyaW5nO1xuICAgZm9ybWF0PzogVDtcbiAgIGZyb20/OiBzdHJpbmc7XG4gICBtYWlsTWFwPzogYm9vbGVhbjtcbiAgIG1heENvdW50PzogbnVtYmVyO1xuICAgbXVsdGlMaW5lPzogYm9vbGVhbjtcbiAgIHNwbGl0dGVyPzogc3RyaW5nO1xuICAgc3RyaWN0RGF0ZT86IGJvb2xlYW47XG4gICBzeW1tZXRyaWM/OiBib29sZWFuO1xuICAgdG8/OiBzdHJpbmc7XG59O1xuXG5pbnRlcmZhY2UgUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBmaWVsZHM6IHN0cmluZ1tdO1xuICAgc3BsaXR0ZXI6IHN0cmluZztcbiAgIGNvbW1hbmRzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gcHJldHR5Rm9ybWF0KFxuICAgZm9ybWF0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmtub3duPixcbiAgIHNwbGl0dGVyOiBzdHJpbmdcbik6IFtzdHJpbmdbXSwgc3RyaW5nXSB7XG4gICBjb25zdCBmaWVsZHM6IHN0cmluZ1tdID0gW107XG4gICBjb25zdCBmb3JtYXRTdHI6IHN0cmluZ1tdID0gW107XG5cbiAgIE9iamVjdC5rZXlzKGZvcm1hdCkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgIGZvcm1hdFN0ci5wdXNoKFN0cmluZyhmb3JtYXRbZmllbGRdKSk7XG4gICB9KTtcblxuICAgcmV0dXJuIFtmaWVsZHMsIGZvcm1hdFN0ci5qb2luKHNwbGl0dGVyKV07XG59XG5cbmZ1bmN0aW9uIHVzZXJPcHRpb25zPFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCk6IE9wdGlvbnMge1xuICAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KS5yZWR1Y2UoKG91dCwga2V5KSA9PiB7XG4gICAgICBpZiAoIShrZXkgaW4gZXhjbHVkZU9wdGlvbnMpKSB7XG4gICAgICAgICBvdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgfSwge30gYXMgT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxvZ09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnM+KFxuICAgb3B0OiBPcHRpb25zIHwgTG9nT3B0aW9uczxUPiA9IHt9LFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBjb25zdCBzcGxpdHRlciA9IGZpbHRlclR5cGUob3B0LnNwbGl0dGVyLCBmaWx0ZXJTdHJpbmcsIFNQTElUVEVSKTtcbiAgIGNvbnN0IGZvcm1hdCA9XG4gICAgICAhZmlsdGVyUHJpbWl0aXZlcyhvcHQuZm9ybWF0KSAmJiBvcHQuZm9ybWF0XG4gICAgICAgICA/IG9wdC5mb3JtYXRcbiAgICAgICAgIDoge1xuICAgICAgICAgICAgICBoYXNoOiAnJUgnLFxuICAgICAgICAgICAgICBkYXRlOiBvcHQuc3RyaWN0RGF0ZSA9PT0gZmFsc2UgPyAnJWFpJyA6ICclYUknLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnJXMnLFxuICAgICAgICAgICAgICByZWZzOiAnJUQnLFxuICAgICAgICAgICAgICBib2R5OiBvcHQubXVsdGlMaW5lID8gJyVCJyA6ICclYicsXG4gICAgICAgICAgICAgIGF1dGhvcl9uYW1lOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyAnJWFOJyA6ICclYW4nLFxuICAgICAgICAgICAgICBhdXRob3JfZW1haWw6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/ICclYUUnIDogJyVhZScsXG4gICAgICAgICAgIH07XG5cbiAgIGNvbnN0IFtmaWVsZHMsIGZvcm1hdFN0cl0gPSBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcik7XG5cbiAgIGNvbnN0IHN1ZmZpeDogc3RyaW5nW10gPSBbXTtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW1xuICAgICAgYC0tcHJldHR5PWZvcm1hdDoke1NUQVJUX0JPVU5EQVJZfSR7Zm9ybWF0U3RyfSR7Q09NTUlUX0JPVU5EQVJZfWAsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgY29uc3QgbWF4Q291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IChvcHQgYXMgYW55KS5uIHx8IChvcHQgYXMgYW55KVsnbWF4LWNvdW50J10gfHwgb3B0Lm1heENvdW50O1xuICAgaWYgKG1heENvdW50KSB7XG4gICAgICBjb21tYW5kLnB1c2goYC0tbWF4LWNvdW50PSR7bWF4Q291bnR9YCk7XG4gICB9XG5cbiAgIGlmIChvcHQuZnJvbSB8fCBvcHQudG8pIHtcbiAgICAgIGNvbnN0IHJhbmdlT3BlcmF0b3IgPSBvcHQuc3ltbWV0cmljICE9PSBmYWxzZSA/ICcuLi4nIDogJy4uJztcbiAgICAgIHN1ZmZpeC5wdXNoKGAke29wdC5mcm9tIHx8ICcnfSR7cmFuZ2VPcGVyYXRvcn0ke29wdC50byB8fCAnJ31gKTtcbiAgIH1cblxuICAgaWYgKGZpbHRlclN0cmluZyhvcHQuZmlsZSkpIHtcbiAgICAgIGNvbW1hbmQucHVzaCgnLS1mb2xsb3cnLCBwYXRoc3BlYyhvcHQuZmlsZSkpO1xuICAgfVxuXG4gICBhcHBlbmRUYXNrT3B0aW9ucyh1c2VyT3B0aW9ucyhvcHQgYXMgT3B0aW9ucyksIGNvbW1hbmQpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZmllbGRzLFxuICAgICAgc3BsaXR0ZXIsXG4gICAgICBjb21tYW5kczogWy4uLmNvbW1hbmQsIC4uLnN1ZmZpeF0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nVGFzazxUPihcbiAgIHNwbGl0dGVyOiBzdHJpbmcsXG4gICBmaWVsZHM6IHN0cmluZ1tdLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8TG9nUmVzdWx0PFQ+PiB7XG4gICBjb25zdCBwYXJzZXIgPSBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciwgZmllbGRzLCBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydsb2cnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2xvZyc+IHtcbiAgIHJldHVybiB7XG4gICAgICBsb2c8VCBleHRlbmRzIE9wdGlvbnM+KHRoaXM6IFNpbXBsZUdpdEFwaSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zPFQ+KFxuICAgICAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJBcnJheSlcbiAgICAgICAgICk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKC4uLnJlc3QpIHx8XG4gICAgICAgICAgICB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhvcHRpb25zLmNvbW1hbmRzKSB8fFxuICAgICAgICAgICAgY3JlYXRlTG9nVGFzayhvcHRpb25zKTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgICB9LFxuICAgfTtcblxuICAgZnVuY3Rpb24gY3JlYXRlTG9nVGFzayhvcHRpb25zOiBQYXJzZWRMb2dPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbG9nVGFzayhvcHRpb25zLnNwbGl0dGVyLCBvcHRpb25zLmZpZWxkcywgb3B0aW9ucy5jb21tYW5kcyk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKGZyb20/OiB1bmtub3duLCB0bz86IHVua25vd24pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICBmaWx0ZXJTdHJpbmcoZnJvbSkgJiZcbiAgICAgICAgIGZpbHRlclN0cmluZyh0bykgJiZcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICBgZ2l0LmxvZyhzdHJpbmcsIHN0cmluZykgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZ2l0LmxvZyh7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9KWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgIE1lcmdlQ29uZmxpY3QsXG4gICBNZXJnZUNvbmZsaWN0RGVsZXRpb24sXG4gICBNZXJnZURldGFpbCxcbiAgIE1lcmdlUmVzdWx0U3RhdHVzLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1lcmdlU3VtbWFyeUNvbmZsaWN0IGltcGxlbWVudHMgTWVyZ2VDb25mbGljdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSByZWFzb246IHN0cmluZyxcbiAgICAgIHB1YmxpYyByZWFkb25seSBmaWxlOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICAgIHB1YmxpYyByZWFkb25seSBtZXRhPzogTWVyZ2VDb25mbGljdERlbGV0aW9uXG4gICApIHt9XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuZmlsZX06JHt0aGlzLnJlYXNvbn1gO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VTdW1tYXJ5RGV0YWlsIGltcGxlbWVudHMgTWVyZ2VEZXRhaWwge1xuICAgcHVibGljIGNvbmZsaWN0czogTWVyZ2VDb25mbGljdFtdID0gW107XG4gICBwdWJsaWMgbWVyZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHJlc3VsdDogTWVyZ2VSZXN1bHRTdGF0dXMgPSAnc3VjY2Vzcyc7XG5cbiAgIGdldCBmYWlsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25mbGljdHMubGVuZ3RoID4gMDtcbiAgIH1cblxuICAgZ2V0IHJlYXNvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgIH1cblxuICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5jb25mbGljdHMubGVuZ3RoKSB7XG4gICAgICAgICByZXR1cm4gYENPTkZMSUNUUzogJHt0aGlzLmNvbmZsaWN0cy5qb2luKCcsICcpfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT0snO1xuICAgfVxufVxuIiwgImltcG9ydCB7XG4gICBQdWxsRGV0YWlsRmlsZUNoYW5nZXMsXG4gICBQdWxsRGV0YWlsU3VtbWFyeSxcbiAgIFB1bGxGYWlsZWRSZXN1bHQsXG4gICBQdWxsUmVzdWx0LFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIFB1bGxTdW1tYXJ5IGltcGxlbWVudHMgUHVsbFJlc3VsdCB7XG4gICBwdWJsaWMgcmVtb3RlTWVzc2FnZXMgPSB7XG4gICAgICBhbGw6IFtdLFxuICAgfTtcbiAgIHB1YmxpYyBjcmVhdGVkID0gW107XG4gICBwdWJsaWMgZGVsZXRlZDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBkZWxldGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIGluc2VydGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIHN1bW1hcnk6IFB1bGxEZXRhaWxTdW1tYXJ5ID0ge1xuICAgICAgY2hhbmdlczogMCxcbiAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgIGluc2VydGlvbnM6IDAsXG4gICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUHVsbEZhaWxlZFN1bW1hcnkgaW1wbGVtZW50cyBQdWxsRmFpbGVkUmVzdWx0IHtcbiAgIHJlbW90ZSA9ICcnO1xuICAgaGFzaCA9IHtcbiAgICAgIGxvY2FsOiAnJyxcbiAgICAgIHJlbW90ZTogJycsXG4gICB9O1xuICAgYnJhbmNoID0ge1xuICAgICAgbG9jYWw6ICcnLFxuICAgICAgcmVtb3RlOiAnJyxcbiAgIH07XG4gICBtZXNzYWdlID0gJyc7XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgIH1cbn1cbiIsICJpbXBvcnQge1xuICAgUmVtb3RlTWVzc2FnZVJlc3VsdCxcbiAgIFJlbW90ZU1lc3NhZ2VzLFxuICAgUmVtb3RlTWVzc2FnZXNPYmplY3RFbnVtZXJhdGlvbixcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcblxuZnVuY3Rpb24gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQ8VCBleHRlbmRzIFJlbW90ZU1lc3NhZ2VzID0gUmVtb3RlTWVzc2FnZXM+KFxuICAgcmVtb3RlTWVzc2FnZXM6IFRcbik6IFJlbW90ZU1lc3NhZ2VzT2JqZWN0RW51bWVyYXRpb24ge1xuICAgcmV0dXJuIChyZW1vdGVNZXNzYWdlcy5vYmplY3RzID0gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyB8fCB7XG4gICAgICBjb21wcmVzc2luZzogMCxcbiAgICAgIGNvdW50aW5nOiAwLFxuICAgICAgZW51bWVyYXRpbmc6IDAsXG4gICAgICBwYWNrUmV1c2VkOiAwLFxuICAgICAgcmV1c2VkOiB7IGNvdW50OiAwLCBkZWx0YTogMCB9LFxuICAgICAgdG90YWw6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICB9KTtcbn1cblxuZnVuY3Rpb24gYXNPYmplY3RDb3VudChzb3VyY2U6IHN0cmluZykge1xuICAgY29uc3QgY291bnQgPSAvXlxccyooXFxkKykvLmV4ZWMoc291cmNlKTtcbiAgIGNvbnN0IGRlbHRhID0gL2RlbHRhIChcXGQrKS9pLmV4ZWMoc291cmNlKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiBhc051bWJlcigoY291bnQgJiYgY291bnRbMV0pIHx8ICcwJyksXG4gICAgICBkZWx0YTogYXNOdW1iZXIoKGRlbHRhICYmIGRlbHRhWzFdKSB8fCAnMCcpLFxuICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VyczogUmVtb3RlTGluZVBhcnNlcjxSZW1vdGVNZXNzYWdlUmVzdWx0PFJlbW90ZU1lc3NhZ2VzPj5bXSA9XG4gICBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IChcXGQrKSwvaSxcbiAgICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IFxcZCslIFxcKFxcZCtcXC8oXFxkKylcXCksL2ksXG4gICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudW1lcmF0aW9uLCB7IFtrZXldOiBhc051bWJlcihjb3VudCkgfSk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICAvdG90YWwgKFteLF0rKSwgcmV1c2VkIChbXixdKyksIHBhY2stcmV1c2VkIChcXGQrKS9pLFxuICAgICAgICAgKHJlc3VsdCwgW3RvdGFsLCByZXVzZWQsIHBhY2tSZXVzZWRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgIG9iamVjdHMudG90YWwgPSBhc09iamVjdENvdW50KHRvdGFsKTtcbiAgICAgICAgICAgIG9iamVjdHMucmV1c2VkID0gYXNPYmplY3RDb3VudChyZXVzZWQpO1xuICAgICAgICAgICAgb2JqZWN0cy5wYWNrUmV1c2VkID0gYXNOdW1iZXIocGFja1JldXNlZCk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgXTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMsIFJlbW90ZU1lc3NhZ2VSZXN1bHQsIFJlbW90ZU1lc3NhZ2VzIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgcGFyc2VTdHJpbmdSZXNwb25zZSwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW9iamVjdHMnO1xuXG5jb25zdCBwYXJzZXJzOiBSZW1vdGVMaW5lUGFyc2VyPFJlbW90ZU1lc3NhZ2VSZXN1bHQ8UHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzIHwgUmVtb3RlTWVzc2FnZXM+PltdID1cbiAgIFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKC9ecmVtb3RlOlxccyooLispJC8sIChyZXN1bHQsIFt0ZXh0XSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLmFsbC5wdXNoKHRleHQudHJpbSgpKTtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLFxuICAgICAgLi4ucmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICBbL2NyZWF0ZSBhICg/OnB1bGx8bWVyZ2UpIHJlcXVlc3QvaSwgL1xccyhodHRwcz86XFwvXFwvXFxTKykkL10sXG4gICAgICAgICAocmVzdWx0LCBbcHVsbFJlcXVlc3RVcmxdKSA9PiB7XG4gICAgICAgICAgICAocmVzdWx0LnJlbW90ZU1lc3NhZ2VzIGFzIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcykucHVsbFJlcXVlc3RVcmwgPSBwdWxsUmVxdWVzdFVybDtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIFsvZm91bmQgKFxcZCspIHZ1bG5lcmFiaWxpdGllcy4rXFwoKFteKV0rKVxcKS9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgIChyZXN1bHQsIFtjb3VudCwgc3VtbWFyeSwgdXJsXSkgPT4ge1xuICAgICAgICAgICAgKHJlc3VsdC5yZW1vdGVNZXNzYWdlcyBhcyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMpLnZ1bG5lcmFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgICAgIGNvdW50OiBhc051bWJlcihjb3VudCksXG4gICAgICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICBdO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZW1vdGVNZXNzYWdlczxUIGV4dGVuZHMgUmVtb3RlTWVzc2FnZXMgPSBSZW1vdGVNZXNzYWdlcz4oXG4gICBfc3RkT3V0OiBzdHJpbmcsXG4gICBzdGRFcnI6IHN0cmluZ1xuKTogUmVtb3RlTWVzc2FnZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHJlbW90ZU1lc3NhZ2VzOiBuZXcgUmVtb3RlTWVzc2FnZVN1bW1hcnkoKSBhcyBUIH0sIHBhcnNlcnMsIHN0ZEVycik7XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVNZXNzYWdlU3VtbWFyeSBpbXBsZW1lbnRzIFJlbW90ZU1lc3NhZ2VzIHtcbiAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdID0gW107XG59XG4iLCAiaW1wb3J0IHsgUHVsbERldGFpbCwgUHVsbEZhaWxlZFJlc3VsdCwgUHVsbFJlc3VsdCwgUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFB1bGxGYWlsZWRTdW1tYXJ5LCBQdWxsU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeSc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXBwZW5kLCBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VSZW1vdGVNZXNzYWdlcyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW1lc3NhZ2VzJztcblxuY29uc3QgRklMRV9VUERBVEVfUkVHRVggPSAvXlxccyooLis/KVxccytcXHxcXHMrXFxkK1xccyooXFwrKikoLSopLztcbmNvbnN0IFNVTU1BUllfUkVHRVggPSAvKFxcZCspXFxEKygoXFxkKylcXEQrXFwoXFwrXFwpKT8oXFxEKyhcXGQrKVxcRCtcXCgtXFwpKT8vO1xuY29uc3QgQUNUSU9OX1JFR0VYID0gL14oY3JlYXRlfGRlbGV0ZSkgbW9kZSBcXGQrICguKykvO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFB1bGxSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihGSUxFX1VQREFURV9SRUdFWCwgKHJlc3VsdCwgW2ZpbGUsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgIHJlc3VsdC5maWxlcy5wdXNoKGZpbGUpO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9ucykge1xuICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnNbZmlsZV0gPSBpbnNlcnRpb25zLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGV0aW9ucykge1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9uc1tmaWxlXSA9IGRlbGV0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFNVTU1BUllfUkVHRVgsIChyZXN1bHQsIFtjaGFuZ2VzLCAsIGluc2VydGlvbnMsICwgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgaWYgKGluc2VydGlvbnMgIT09IHVuZGVmaW5lZCB8fCBkZWxldGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9ICtjaGFuZ2VzIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gK2luc2VydGlvbnMgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9ICtkZWxldGlvbnMgfHwgMDtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihBQ1RJT05fUkVHRVgsIChyZXN1bHQsIFthY3Rpb24sIGZpbGVdKSA9PiB7XG4gICAgICBhcHBlbmQocmVzdWx0LmZpbGVzLCBmaWxlKTtcbiAgICAgIGFwcGVuZChhY3Rpb24gPT09ICdjcmVhdGUnID8gcmVzdWx0LmNyZWF0ZWQgOiByZXN1bHQuZGVsZXRlZCwgZmlsZSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IGVycm9yUGFyc2VyczogTGluZVBhcnNlcjxQdWxsRmFpbGVkUmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15mcm9tXFxzKC4rKSQvaSwgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHZvaWQgKHJlc3VsdC5yZW1vdGUgPSByZW1vdGUpKSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eZmF0YWw6XFxzKC4rKSQvLCAocmVzdWx0LCBbbWVzc2FnZV0pID0+IHZvaWQgKHJlc3VsdC5tZXNzYWdlID0gbWVzc2FnZSkpLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKVxccysoXFxTKylcXHMrLT5cXHMrKFxcUyspJC8sXG4gICAgICAocmVzdWx0LCBbaGFzaExvY2FsLCBoYXNoUmVtb3RlLCBicmFuY2hMb2NhbCwgYnJhbmNoUmVtb3RlXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaC5sb2NhbCA9IGJyYW5jaExvY2FsO1xuICAgICAgICAgcmVzdWx0Lmhhc2gubG9jYWwgPSBoYXNoTG9jYWw7XG4gICAgICAgICByZXN1bHQuYnJhbmNoLnJlbW90ZSA9IGJyYW5jaFJlbW90ZTtcbiAgICAgICAgIHJlc3VsdC5oYXNoLnJlbW90ZSA9IGhhc2hSZW1vdGU7XG4gICAgICB9XG4gICApLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUHVsbERldGFpbDogVGFza1BhcnNlcjxzdHJpbmcsIFB1bGxEZXRhaWw+ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbFN1bW1hcnkoKSwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdWxsUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVsbFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgbmV3IFB1bGxTdW1tYXJ5KCksXG4gICAgICBwYXJzZVB1bGxEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLFxuICAgICAgcGFyc2VSZW1vdGVNZXNzYWdlczxSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpXG4gICApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHVsbEVycm9yUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZykge1xuICAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbEZhaWxlZFN1bW1hcnkoKSwgZXJyb3JQYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcblxuICAgcmV0dXJuIHB1bGxFcnJvci5tZXNzYWdlICYmIHB1bGxFcnJvcjtcbn1cbiIsICJpbXBvcnQgeyBNZXJnZURldGFpbCwgTWVyZ2VSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IE1lcmdlU3VtbWFyeUNvbmZsaWN0LCBNZXJnZVN1bW1hcnlEZXRhaWwgfSBmcm9tICcuLi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5JztcbmltcG9ydCB7IFRhc2tQYXJzZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VQdWxsUmVzdWx0IH0gZnJvbSAnLi9wYXJzZS1wdWxsJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxNZXJnZURldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQXV0by1tZXJnaW5nXFxzKyguKykkLywgKHN1bW1hcnksIFthdXRvTWVyZ2VdKSA9PiB7XG4gICAgICBzdW1tYXJ5Lm1lcmdlcy5wdXNoKGF1dG9NZXJnZSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTogTWVyZ2UgY29uZmxpY3QgaW4gKC4rKSQvLCAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZV0pID0+IHtcbiAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSkpO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eQ09ORkxJQ1RcXHMrXFwoKC4rXFwvZGVsZXRlKVxcKTogKC4rKSBkZWxldGVkIGluICguKykgYW5kLyxcbiAgICAgIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlLCBkZWxldGVSZWZdKSA9PiB7XG4gICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIGZpbGUsIHsgZGVsZXRlUmVmIH0pKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6LywgKHN1bW1hcnksIFtyZWFzb25dKSA9PiB7XG4gICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIG51bGwpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL15BdXRvbWF0aWMgbWVyZ2UgZmFpbGVkO1xccysoLispJC8sIChzdW1tYXJ5LCBbcmVzdWx0XSkgPT4ge1xuICAgICAgc3VtbWFyeS5yZXN1bHQgPSByZXN1bHQ7XG4gICB9KSxcbl07XG5cbi8qKlxuICogUGFyc2UgdGhlIGNvbXBsZXRlIHJlc3BvbnNlIGZyb20gYGdpdC5tZXJnZWBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlTWVyZ2VSZXN1bHQ6IFRhc2tQYXJzZXI8c3RyaW5nLCBNZXJnZVJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKHBhcnNlTWVyZ2VEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLCBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1lcmdlIHNwZWNpZmljIGRldGFpbCAoaWU6IG5vdCB0aGUgY29udGVudCBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcHVsbCBkZXRhaWwpIGZyb20gYGdpdC5tbmVyZ2VgXG4gKiBAcGFyYW0gc3RkT3V0XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZU1lcmdlRGV0YWlsOiBUYXNrUGFyc2VyPHN0cmluZywgTWVyZ2VEZXRhaWw+ID0gKHN0ZE91dCkgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IE1lcmdlU3VtbWFyeURldGFpbCgpLCBwYXJzZXJzLCBzdGRPdXQpO1xufTtcbiIsICJpbXBvcnQgeyBNZXJnZVJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VNZXJnZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbWVyZ2UnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBFbXB0eVRhc2sgfCBTdHJpbmdUYXNrPE1lcmdlUmVzdWx0PiB7XG4gICBpZiAoIWN1c3RvbUFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0Lm1lcmdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24nKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBbJ21lcmdlJywgLi4uY3VzdG9tQXJnc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBNZXJnZVJlc3VsdCB7XG4gICAgICAgICBjb25zdCBtZXJnZSA9IHBhcnNlTWVyZ2VSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgICAgaWYgKG1lcmdlLmZhaWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdpdFJlc3BvbnNlRXJyb3IobWVyZ2UpO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbWVyZ2U7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQge1xuICAgUHVzaERldGFpbCxcbiAgIFB1c2hSZXN1bHQsXG4gICBQdXNoUmVzdWx0UHVzaGVkSXRlbSxcbiAgIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHBhcnNlUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuL3BhcnNlLXJlbW90ZS1tZXNzYWdlcyc7XG5cbmZ1bmN0aW9uIHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsOiBzdHJpbmcsIHJlbW90ZTogc3RyaW5nLCBzdGF0dXM6IHN0cmluZyk6IFB1c2hSZXN1bHRQdXNoZWRJdGVtIHtcbiAgIGNvbnN0IGRlbGV0ZWQgPSBzdGF0dXMuaW5jbHVkZXMoJ2RlbGV0ZWQnKTtcbiAgIGNvbnN0IHRhZyA9IHN0YXR1cy5pbmNsdWRlcygndGFnJykgfHwgL15yZWZzXFwvdGFncy8udGVzdChsb2NhbCk7XG4gICBjb25zdCBhbHJlYWR5VXBkYXRlZCA9ICFzdGF0dXMuaW5jbHVkZXMoJ25ldycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZGVsZXRlZCxcbiAgICAgIHRhZyxcbiAgICAgIGJyYW5jaDogIXRhZyxcbiAgICAgIG5ldzogIWFscmVhZHlVcGRhdGVkLFxuICAgICAgYWxyZWFkeVVwZGF0ZWQsXG4gICAgICBsb2NhbCxcbiAgICAgIHJlbW90ZSxcbiAgIH07XG59XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8UHVzaERldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eUHVzaGluZyB0byAoLispJC8sIChyZXN1bHQsIFtyZXBvXSkgPT4ge1xuICAgICAgcmVzdWx0LnJlcG8gPSByZXBvO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXnVwZGF0aW5nIGxvY2FsIHRyYWNraW5nIHJlZiAnKC4rKScvLCAocmVzdWx0LCBbbG9jYWxdKSA9PiB7XG4gICAgICByZXN1bHQucmVmID0ge1xuICAgICAgICAgLi4uKHJlc3VsdC5yZWYgfHwge30pLFxuICAgICAgICAgbG9jYWwsXG4gICAgICB9O1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXls9Ki1dXFxzKyhbXjpdKyk6KFxcUyspXFxzK1xcWyguKyldJC8sIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCB0eXBlXSkgPT4ge1xuICAgICAgcmVzdWx0LnB1c2hlZC5wdXNoKHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHR5cGUpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXkJyYW5jaCAnKFteJ10rKScgc2V0IHVwIHRvIHRyYWNrIHJlbW90ZSBicmFuY2ggJyhbXiddKyknIGZyb20gJyhbXiddKyknLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCByZW1vdGVOYW1lXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaCA9IHtcbiAgICAgICAgICAgIC4uLihyZXN1bHQuYnJhbmNoIHx8IHt9KSxcbiAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgcmVtb3RlTmFtZSxcbiAgICAgICAgIH07XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbXjpdKyk6KFxcUyspXFxzKyhbYS16MC05XSspXFwuXFwuKFthLXowLTldKykkLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCBmcm9tLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC51cGRhdGUgPSB7XG4gICAgICAgICAgICBoZWFkOiB7XG4gICAgICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdXNoUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVzaFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIGNvbnN0IHB1c2hEZXRhaWwgPSBwYXJzZVB1c2hEZXRhaWwoc3RkT3V0LCBzdGRFcnIpO1xuICAgY29uc3QgcmVzcG9uc2VEZXRhaWwgPSBwYXJzZVJlbW90ZU1lc3NhZ2VzPFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpO1xuXG4gICByZXR1cm4ge1xuICAgICAgLi4ucHVzaERldGFpbCxcbiAgICAgIC4uLnJlc3BvbnNlRGV0YWlsLFxuICAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVB1c2hEZXRhaWw6IFRhc2tQYXJzZXI8c3RyaW5nLCBQdXNoRGV0YWlsPiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UoeyBwdXNoZWQ6IFtdIH0sIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZVB1c2hSZXN1bHQgYXMgcGFyc2VyIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1wdXNoJztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhcHBlbmQsIHJlbW92ZSB9IGZyb20gJy4uL3V0aWxzJztcblxudHlwZSBQdXNoUmVmID0geyByZW1vdGU/OiBzdHJpbmc7IGJyYW5jaD86IHN0cmluZyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhZ3NUYXNrKHJlZjogUHVzaFJlZiA9IHt9LCBjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8UHVzaFJlc3VsdD4ge1xuICAgYXBwZW5kKGN1c3RvbUFyZ3MsICctLXRhZ3MnKTtcbiAgIHJldHVybiBwdXNoVGFzayhyZWYsIGN1c3RvbUFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhc2socmVmOiBQdXNoUmVmID0ge30sIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxQdXNoUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncHVzaCcsIC4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKHJlZi5icmFuY2gpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYuYnJhbmNoKTtcbiAgIH1cbiAgIGlmIChyZWYucmVtb3RlKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVmLnJlbW90ZSk7XG4gICB9XG5cbiAgIHJlbW92ZShjb21tYW5kcywgJy12Jyk7XG4gICBhcHBlbmQoY29tbWFuZHMsICctLXZlcmJvc2UnKTtcbiAgIGFwcGVuZChjb21tYW5kcywgJy0tcG9yY2VsYWluJyk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdzaG93QnVmZmVyJyB8ICdzaG93Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHNob3dCdWZmZXIodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnc2hvdycsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgICAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoJy0tYmluYXJ5JykpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCAnLS1iaW5hcnknKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgc2hvdyh0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydzaG93JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgRmlsZVN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY29uc3QgZnJvbVBhdGhSZWdleCA9IC9eKC4rKSAtPiAoLispJC87XG5cbmV4cG9ydCBjbGFzcyBGaWxlU3RhdHVzU3VtbWFyeSBpbXBsZW1lbnRzIEZpbGVTdGF0dXNSZXN1bHQge1xuICAgcHVibGljIHJlYWRvbmx5IGZyb206IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIGluZGV4OiBzdHJpbmcsXG4gICAgICBwdWJsaWMgd29ya2luZ19kaXI6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoJ1InID09PSBpbmRleCArIHdvcmtpbmdfZGlyKSB7XG4gICAgICAgICBjb25zdCBkZXRhaWwgPSBmcm9tUGF0aFJlZ2V4LmV4ZWMocGF0aCkgfHwgW251bGwsIHBhdGgsIHBhdGhdO1xuICAgICAgICAgdGhpcy5mcm9tID0gZGV0YWlsWzFdIHx8ICcnO1xuICAgICAgICAgdGhpcy5wYXRoID0gZGV0YWlsWzJdIHx8ICcnO1xuICAgICAgfVxuICAgfVxufVxuIiwgImltcG9ydCB7IFN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgYXBwZW5kLCBOVUxMIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgRmlsZVN0YXR1c1N1bW1hcnkgfSBmcm9tICcuL0ZpbGVTdGF0dXNTdW1tYXJ5JztcblxudHlwZSBTdGF0dXNMaW5lUGFyc2VyID0gKHJlc3VsdDogU3RhdHVzUmVzdWx0LCBmaWxlOiBzdHJpbmcpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNTdW1tYXJ5IGltcGxlbWVudHMgU3RhdHVzUmVzdWx0IHtcbiAgIHB1YmxpYyBub3RfYWRkZWQgPSBbXTtcbiAgIHB1YmxpYyBjb25mbGljdGVkID0gW107XG4gICBwdWJsaWMgY3JlYXRlZCA9IFtdO1xuICAgcHVibGljIGRlbGV0ZWQgPSBbXTtcbiAgIHB1YmxpYyBpZ25vcmVkID0gdW5kZWZpbmVkO1xuICAgcHVibGljIG1vZGlmaWVkID0gW107XG4gICBwdWJsaWMgcmVuYW1lZCA9IFtdO1xuICAgcHVibGljIGZpbGVzID0gW107XG4gICBwdWJsaWMgc3RhZ2VkID0gW107XG4gICBwdWJsaWMgYWhlYWQgPSAwO1xuICAgcHVibGljIGJlaGluZCA9IDA7XG4gICBwdWJsaWMgY3VycmVudCA9IG51bGw7XG4gICBwdWJsaWMgdHJhY2tpbmcgPSBudWxsO1xuICAgcHVibGljIGRldGFjaGVkID0gZmFsc2U7XG5cbiAgIHB1YmxpYyBpc0NsZWFuID0gKCkgPT4ge1xuICAgICAgcmV0dXJuICF0aGlzLmZpbGVzLmxlbmd0aDtcbiAgIH07XG59XG5cbmVudW0gUG9yY2VsYWluRmlsZVN0YXR1cyB7XG4gICBBRERFRCA9ICdBJyxcbiAgIERFTEVURUQgPSAnRCcsXG4gICBNT0RJRklFRCA9ICdNJyxcbiAgIFJFTkFNRUQgPSAnUicsXG4gICBDT1BJRUQgPSAnQycsXG4gICBVTk1FUkdFRCA9ICdVJyxcbiAgIFVOVFJBQ0tFRCA9ICc/JyxcbiAgIElHTk9SRUQgPSAnIScsXG4gICBOT05FID0gJyAnLFxufVxuXG5mdW5jdGlvbiByZW5hbWVkRmlsZShsaW5lOiBzdHJpbmcpIHtcbiAgIGNvbnN0IFt0bywgZnJvbV0gPSBsaW5lLnNwbGl0KE5VTEwpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZnJvbTogZnJvbSB8fCB0byxcbiAgICAgIHRvLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VyKFxuICAgaW5kZXhYOiBQb3JjZWxhaW5GaWxlU3RhdHVzLFxuICAgaW5kZXhZOiBQb3JjZWxhaW5GaWxlU3RhdHVzLFxuICAgaGFuZGxlcjogU3RhdHVzTGluZVBhcnNlclxuKTogW3N0cmluZywgU3RhdHVzTGluZVBhcnNlcl0ge1xuICAgcmV0dXJuIFtgJHtpbmRleFh9JHtpbmRleFl9YCwgaGFuZGxlcl07XG59XG5cbmZ1bmN0aW9uIGNvbmZsaWN0cyhpbmRleFg6IFBvcmNlbGFpbkZpbGVTdGF0dXMsIC4uLmluZGV4WTogUG9yY2VsYWluRmlsZVN0YXR1c1tdKSB7XG4gICByZXR1cm4gaW5kZXhZLm1hcCgoeSkgPT4gcGFyc2VyKGluZGV4WCwgeSwgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jb25mbGljdGVkLCBmaWxlKSkpO1xufVxuXG5jb25zdCBwYXJzZXJzOiBNYXA8c3RyaW5nLCBTdGF0dXNMaW5lUGFyc2VyPiA9IG5ldyBNYXAoW1xuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQuY3JlYXRlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpXG4gICApLFxuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICAgICBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmXG4gICAgICAgICBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSkgJiZcbiAgICAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcblxuICAgcGFyc2VyKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZEZpbGUoZmlsZSkpO1xuICAgfSksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELCAocmVzdWx0LCBmaWxlKSA9PiB7XG4gICAgICBjb25zdCByZW5hbWVkID0gcmVuYW1lZEZpbGUoZmlsZSk7XG4gICAgICBhcHBlbmQocmVzdWx0LnJlbmFtZWQsIHJlbmFtZWQpO1xuICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgcmVuYW1lZC50byk7XG4gICB9KSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLklHTk9SRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuSUdOT1JFRCwgKF9yZXN1bHQsIF9maWxlKSA9PiB7XG4gICAgICBhcHBlbmQoKF9yZXN1bHQuaWdub3JlZCA9IF9yZXN1bHQuaWdub3JlZCB8fCBbXSksIF9maWxlKTtcbiAgIH0pLFxuXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5VTlRSQUNLRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5UUkFDS0VELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5ub3RfYWRkZWQsIGZpbGUpXG4gICApLFxuXG4gICAuLi5jb25mbGljdHMoUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5VTk1FUkdFRCksXG4gICAuLi5jb25mbGljdHMoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEXG4gICApLFxuICAgLi4uY29uZmxpY3RzKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5VTk1FUkdFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLkRFTEVURUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEXG4gICApLFxuXG4gICBbXG4gICAgICAnIyMnLFxuICAgICAgKHJlc3VsdCwgbGluZSkgPT4ge1xuICAgICAgICAgY29uc3QgYWhlYWRSZWcgPSAvYWhlYWQgKFxcZCspLztcbiAgICAgICAgIGNvbnN0IGJlaGluZFJlZyA9IC9iZWhpbmQgKFxcZCspLztcbiAgICAgICAgIGNvbnN0IGN1cnJlbnRSZWcgPSAvXiguKz8oPz0oPzpcXC57M318XFxzfCQpKSkvO1xuICAgICAgICAgY29uc3QgdHJhY2tpbmdSZWcgPSAvXFwuezN9KFxcUyopLztcbiAgICAgICAgIGNvbnN0IG9uRW1wdHlCcmFuY2hSZWcgPSAvXFxzb25cXHMoW1xcU10rKSQvO1xuICAgICAgICAgbGV0IHJlZ2V4UmVzdWx0O1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IGFoZWFkUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuYWhlYWQgPSAocmVnZXhSZXN1bHQgJiYgK3JlZ2V4UmVzdWx0WzFdKSB8fCAwO1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IGJlaGluZFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmJlaGluZCA9IChyZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0pIHx8IDA7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gY3VycmVudFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXTtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSB0cmFja2luZ1JlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LnRyYWNraW5nID0gcmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV07XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gb25FbXB0eUJyYW5jaFJlZy5leGVjKGxpbmUpO1xuICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSAocmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV0pIHx8IHJlc3VsdC5jdXJyZW50O1xuXG4gICAgICAgICByZXN1bHQuZGV0YWNoZWQgPSAvXFwobm8gYnJhbmNoXFwpLy50ZXN0KGxpbmUpO1xuICAgICAgfSxcbiAgIF0sXG5dKTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3RhdHVzU3VtbWFyeSA9IGZ1bmN0aW9uICh0ZXh0OiBzdHJpbmcpOiBTdGF0dXNSZXN1bHQge1xuICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KE5VTEwpO1xuICAgY29uc3Qgc3RhdHVzID0gbmV3IFN0YXR1c1N1bW1hcnkoKTtcblxuICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyApIHtcbiAgICAgIGxldCBsaW5lID0gbGluZXNbaSsrXS50cmltKCk7XG5cbiAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gUG9yY2VsYWluRmlsZVN0YXR1cy5SRU5BTUVEKSB7XG4gICAgICAgICBsaW5lICs9IE5VTEwgKyAobGluZXNbaSsrXSB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHNwbGl0TGluZShzdGF0dXMsIGxpbmUpO1xuICAgfVxuXG4gICByZXR1cm4gc3RhdHVzO1xufTtcblxuZnVuY3Rpb24gc3BsaXRMaW5lKHJlc3VsdDogU3RhdHVzUmVzdWx0LCBsaW5lU3RyOiBzdHJpbmcpIHtcbiAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lU3RyLnRyaW0oKTtcbiAgIHN3aXRjaCAoJyAnKSB7XG4gICAgICBjYXNlIHRyaW1tZWQuY2hhckF0KDIpOlxuICAgICAgICAgcmV0dXJuIGRhdGEodHJpbW1lZC5jaGFyQXQoMCksIHRyaW1tZWQuY2hhckF0KDEpLCB0cmltbWVkLnN1YnN0cigzKSk7XG4gICAgICBjYXNlIHRyaW1tZWQuY2hhckF0KDEpOlxuICAgICAgICAgcmV0dXJuIGRhdGEoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCB0cmltbWVkLmNoYXJBdCgwKSwgdHJpbW1lZC5zdWJzdHIoMikpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIHJldHVybjtcbiAgIH1cblxuICAgZnVuY3Rpb24gZGF0YShpbmRleDogc3RyaW5nLCB3b3JraW5nRGlyOiBzdHJpbmcsIHBhdGg6IHN0cmluZykge1xuICAgICAgY29uc3QgcmF3ID0gYCR7aW5kZXh9JHt3b3JraW5nRGlyfWA7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2Vycy5nZXQocmF3KTtcblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgIGhhbmRsZXIocmVzdWx0LCBwYXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhdyAhPT0gJyMjJyAmJiByYXcgIT09ICchIScpIHtcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKG5ldyBGaWxlU3RhdHVzU3VtbWFyeShwYXRoLnJlcGxhY2UoL1xcMC4rJC8sICcnKSwgaW5kZXgsIHdvcmtpbmdEaXIpKTtcbiAgICAgIH1cbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTdGF0dXNSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlU3RhdHVzU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9TdGF0dXNTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGlnbm9yZWRPcHRpb25zID0gWyctLW51bGwnLCAnLXonXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXR1c1Rhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPFN0YXR1c1Jlc3VsdD4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbXG4gICAgICAnc3RhdHVzJyxcbiAgICAgICctLXBvcmNlbGFpbicsXG4gICAgICAnLWInLFxuICAgICAgJy11JyxcbiAgICAgICctLW51bGwnLFxuICAgICAgLi4uY3VzdG9tQXJncy5maWx0ZXIoKGFyZykgPT4gIWlnbm9yZWRPcHRpb25zLmluY2x1ZGVzKGFyZykpLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZykge1xuICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdHVzU3VtbWFyeSh0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBFeGl0Q29kZXMsIExpbmVQYXJzZXIsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvblJlc3VsdCB7XG4gICBtYWpvcjogbnVtYmVyO1xuICAgbWlub3I6IG51bWJlcjtcbiAgIHBhdGNoOiBudW1iZXIgfCBzdHJpbmc7XG4gICBhZ2VudDogc3RyaW5nO1xuICAgaW5zdGFsbGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBOT1RfSU5TVEFMTEVEID0gJ2luc3RhbGxlZD1mYWxzZSc7XG5cbmZ1bmN0aW9uIHZlcnNpb25SZXNwb25zZShcbiAgIG1ham9yID0gMCxcbiAgIG1pbm9yID0gMCxcbiAgIHBhdGNoOiBzdHJpbmcgfCBudW1iZXIgPSAwLFxuICAgYWdlbnQgPSAnJyxcbiAgIGluc3RhbGxlZCA9IHRydWVcbik6IFZlcnNpb25SZXN1bHQge1xuICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHtcbiAgICAgICAgIG1ham9yLFxuICAgICAgICAgbWlub3IsXG4gICAgICAgICBwYXRjaCxcbiAgICAgICAgIGFnZW50LFxuICAgICAgICAgaW5zdGFsbGVkLFxuICAgICAgfSxcbiAgICAgICd0b1N0cmluZycsXG4gICAgICB7XG4gICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gO1xuICAgICAgICAgfSxcbiAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH1cbiAgICk7XG59XG5cbmZ1bmN0aW9uIG5vdEluc3RhbGxlZFJlc3BvbnNlKCkge1xuICAgcmV0dXJuIHZlcnNpb25SZXNwb25zZSgwLCAwLCAwLCAnJywgZmFsc2UpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICd2ZXJzaW9uJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24odGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh7XG4gICAgICAgICAgICBjb21tYW5kczogWyctLXZlcnNpb24nXSxcbiAgICAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgICAgIHBhcnNlcjogdmVyc2lvblBhcnNlcixcbiAgICAgICAgICAgIG9uRXJyb3IocmVzdWx0LCBlcnJvciwgZG9uZSwgZmFpbCkge1xuICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5leGl0Q29kZSA9PT0gRXhpdENvZGVzLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoQnVmZmVyLmZyb20oTk9UX0lOU1RBTExFRCkpO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBmYWlsKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFZlcnNpb25SZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXGQrKSg/OlxccypcXCgoLispXFwpKT8vLFxuICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gJyddKSA9PiB7XG4gICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBhc051bWJlcihwYXRjaCksIGFnZW50KVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC92ZXJzaW9uIChcXGQrKVxcLihcXGQrKVxcLihcXEQrKSguKyk/JC8sXG4gICAgICAocmVzdWx0LCBbbWFqb3IsIG1pbm9yLCBwYXRjaCwgYWdlbnQgPSAnJ10pID0+IHtcbiAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2ZXJzaW9uUmVzcG9uc2UoYXNOdW1iZXIobWFqb3IpLCBhc051bWJlcihtaW5vciksIHBhdGNoLCBhZ2VudCkpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIHZlcnNpb25QYXJzZXIoc3RkT3V0OiBzdHJpbmcpIHtcbiAgIGlmIChzdGRPdXQgPT09IE5PVF9JTlNUQUxMRUQpIHtcbiAgICAgIHJldHVybiBub3RJbnN0YWxsZWRSZXNwb25zZSgpO1xuICAgfVxuXG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgc3RkT3V0KSwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRCYXNlIH0gZnJvbSAnLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyB0YXNrQ2FsbGJhY2sgfSBmcm9tICcuL3Rhc2stY2FsbGJhY2snO1xuaW1wb3J0IHsgY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2sgfSBmcm9tICcuL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeSc7XG5pbXBvcnQgY2hlY2tvdXQgZnJvbSAnLi90YXNrcy9jaGVja291dCc7XG5pbXBvcnQgY29tbWl0IGZyb20gJy4vdGFza3MvY29tbWl0JztcbmltcG9ydCBjb25maWcgZnJvbSAnLi90YXNrcy9jb25maWcnO1xuaW1wb3J0IGZpcnN0Q29tbWl0IGZyb20gJy4vdGFza3MvZmlyc3QtY29tbWl0JztcbmltcG9ydCBncmVwIGZyb20gJy4vdGFza3MvZ3JlcCc7XG5pbXBvcnQgeyBoYXNoT2JqZWN0VGFzayB9IGZyb20gJy4vdGFza3MvaGFzaC1vYmplY3QnO1xuaW1wb3J0IHsgaW5pdFRhc2sgfSBmcm9tICcuL3Rhc2tzL2luaXQnO1xuaW1wb3J0IGxvZyBmcm9tICcuL3Rhc2tzL2xvZyc7XG5pbXBvcnQgeyBtZXJnZVRhc2sgfSBmcm9tICcuL3Rhc2tzL21lcmdlJztcbmltcG9ydCB7IHB1c2hUYXNrIH0gZnJvbSAnLi90YXNrcy9wdXNoJztcbmltcG9ydCBzaG93IGZyb20gJy4vdGFza3Mvc2hvdyc7XG5pbXBvcnQgeyBzdGF0dXNUYXNrIH0gZnJvbSAnLi90YXNrcy9zdGF0dXMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFza3MvdGFzayc7XG5pbXBvcnQgdmVyc2lvbiBmcm9tICcuL3Rhc2tzL3ZlcnNpb24nO1xuaW1wb3J0IHsgb3V0cHV0SGFuZGxlciwgU2ltcGxlR2l0RXhlY3V0b3IsIFNpbXBsZUdpdFRhc2ssIFNpbXBsZUdpdFRhc2tDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxufSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFNpbXBsZUdpdEFwaSBpbXBsZW1lbnRzIFNpbXBsZUdpdEJhc2Uge1xuICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZXhlY3V0b3I6IFNpbXBsZUdpdEV4ZWN1dG9yKSB7fVxuXG4gICBwcm90ZWN0ZWQgX3J1blRhc2s8VD4odGFzazogU2ltcGxlR2l0VGFzazxUPiwgdGhlbj86IFNpbXBsZUdpdFRhc2tDYWxsYmFjazxUPikge1xuICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9leGVjdXRvci5jaGFpbigpO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGNoYWluLnB1c2godGFzayk7XG5cbiAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICB0YXNrQ2FsbGJhY2sodGFzaywgcHJvbWlzZSwgdGhlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMsIHtcbiAgICAgICAgIHRoZW46IHsgdmFsdWU6IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICBjYXRjaDogeyB2YWx1ZTogcHJvbWlzZS5jYXRjaC5iaW5kKHByb21pc2UpIH0sXG4gICAgICAgICBfZXhlY3V0b3I6IHsgdmFsdWU6IGNoYWluIH0sXG4gICAgICB9KTtcbiAgIH1cblxuICAgYWRkKGZpbGVzOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsnYWRkJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBjd2QoZGlyZWN0b3J5OiBzdHJpbmcgfCB7IHBhdGg6IHN0cmluZzsgcm9vdD86IGJvb2xlYW4gfSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGRpcmVjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeSwgdGhpcy5fZXhlY3V0b3IpLCBuZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rvcnk/LnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKFxuICAgICAgICAgICAgICAgZGlyZWN0b3J5LnBhdGgsXG4gICAgICAgICAgICAgICAoZGlyZWN0b3J5LnJvb3QgJiYgdGhpcy5fZXhlY3V0b3IpIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5leHRcbiAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0LmN3ZDogd29ya2luZ0RpcmVjdG9yeSBtdXN0IGJlIHN1cHBsaWVkIGFzIGEgc3RyaW5nJyksXG4gICAgICAgICBuZXh0XG4gICAgICApO1xuICAgfVxuXG4gICBoYXNoT2JqZWN0KHBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4gfCB1bmtub3duKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGhhc2hPYmplY3RUYXNrKHBhdGgsIHdyaXRlID09PSB0cnVlKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBpbml0KGJhcmU/OiBib29sZWFuIHwgdW5rbm93bikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBpbml0VGFzayhiYXJlID09PSB0cnVlLCB0aGlzLl9leGVjdXRvci5jd2QsIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBtZXJnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgbWVyZ2VUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBtZXJnZUZyb21UbyhyZW1vdGU6IHN0cmluZywgYnJhbmNoOiBzdHJpbmcpIHtcbiAgICAgIGlmICghKGZpbHRlclN0cmluZyhyZW1vdGUpICYmIGZpbHRlclN0cmluZyhicmFuY2gpKSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgICAgYEdpdC5tZXJnZUZyb21UbyByZXF1aXJlcyB0aGF0IHRoZSAncmVtb3RlJyBhbmQgJ2JyYW5jaCcgYXJndW1lbnRzIGFyZSBzdXBwbGllZCBhcyBzdHJpbmdzYFxuICAgICAgICAgICAgKVxuICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBtZXJnZVRhc2soW3JlbW90ZSwgYnJhbmNoLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cywgZmFsc2UpXG4gICAgICApO1xuICAgfVxuXG4gICBvdXRwdXRIYW5kbGVyKGhhbmRsZXI6IG91dHB1dEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dG9yLm91dHB1dEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1c2goKSB7XG4gICAgICBjb25zdCB0YXNrID0gcHVzaFRhc2soXG4gICAgICAgICB7XG4gICAgICAgICAgICByZW1vdGU6IGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgICAgYnJhbmNoOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1sxXSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIH0sXG4gICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xuICAgfVxuXG4gICBzdGFzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3N0YXNoJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxuXG4gICBzdGF0dXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIHN0YXR1c1Rhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICk7XG4gICB9XG59XG5cbk9iamVjdC5hc3NpZ24oXG4gICBTaW1wbGVHaXRBcGkucHJvdG90eXBlLFxuICAgY2hlY2tvdXQoKSxcbiAgIGNvbW1pdCgpLFxuICAgY29uZmlnKCksXG4gICBmaXJzdENvbW1pdCgpLFxuICAgZ3JlcCgpLFxuICAgbG9nKCksXG4gICBzaG93KCksXG4gICB2ZXJzaW9uKClcbik7XG4iLCAiaW1wb3J0IHsgYXBwZW5kLCByZW1vdmUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCwgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZCc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICcuLi9naXQtbG9nZ2VyJztcblxudHlwZSBTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB2b2lkO1xudHlwZSBTY2hlZHVsZWRUYXNrID0gUGljazxEZWZlcnJlZFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiwgJ3Byb21pc2UnIHwgJ2RvbmUnPiAmIHtcbiAgIGlkOiBudW1iZXI7XG59O1xuXG5jb25zdCBjcmVhdGVTY2hlZHVsZWRUYXNrOiAoKSA9PiBTY2hlZHVsZWRUYXNrID0gKCgpID0+IHtcbiAgIGxldCBpZCA9IDA7XG4gICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWQrKztcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgZG9uZSB9ID0gY3JlYXRlRGVmZXJyZWQ8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPigpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgIGRvbmUsXG4gICAgICAgICBpZCxcbiAgICAgIH07XG4gICB9O1xufSkoKTtcblxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciB7XG4gICBwcml2YXRlIGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcignJywgJ3NjaGVkdWxlcicpO1xuICAgcHJpdmF0ZSBwZW5kaW5nOiBTY2hlZHVsZWRUYXNrW10gPSBbXTtcbiAgIHByaXZhdGUgcnVubmluZzogU2NoZWR1bGVkVGFza1tdID0gW107XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uY3VycmVuY3kgPSAyKSB7XG4gICAgICB0aGlzLmxvZ2dlcihgQ29uc3RydWN0ZWQsIGNvbmN1cnJlbmN5PSVzYCwgY29uY3VycmVuY3kpO1xuICAgfVxuXG4gICBwcml2YXRlIHNjaGVkdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmcubGVuZ3RoIHx8IHRoaXMucnVubmluZy5sZW5ndGggPj0gdGhpcy5jb25jdXJyZW5jeSkge1xuICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICBgU2NoZWR1bGUgYXR0ZW1wdCBpZ25vcmVkLCBwZW5kaW5nPSVzIHJ1bm5pbmc9JXMgY29uY3VycmVuY3k9JXNgLFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5XG4gICAgICAgICApO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXNrID0gYXBwZW5kKHRoaXMucnVubmluZywgdGhpcy5wZW5kaW5nLnNoaWZ0KCkhKTtcbiAgICAgIHRoaXMubG9nZ2VyKGBBdHRlbXB0aW5nIGlkPSVzYCwgdGFzay5pZCk7XG4gICAgICB0YXNrLmRvbmUoKCkgPT4ge1xuICAgICAgICAgdGhpcy5sb2dnZXIoYENvbXBsZXRpbmcgaWQ9YCwgdGFzay5pZCk7XG4gICAgICAgICByZW1vdmUodGhpcy5ydW5uaW5nLCB0YXNrKTtcbiAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBuZXh0KCk6IFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiB7XG4gICAgICBjb25zdCB7IHByb21pc2UsIGlkIH0gPSBhcHBlbmQodGhpcy5wZW5kaW5nLCBjcmVhdGVTY2hlZHVsZWRUYXNrKCkpO1xuICAgICAgdGhpcy5sb2dnZXIoYFNjaGVkdWxpbmcgaWQ9JXNgLCBpZCk7XG5cbiAgICAgIHRoaXMuc2NoZWR1bGUoKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQXBwbHlPcHRpb25zID0gT3B0aW9ucyAmXG4gICBPcHRpb25GbGFnczxcbiAgICAgIHwgJy0tc3RhdCdcbiAgICAgIHwgJy0tbnVtc3RhdCdcbiAgICAgIHwgJy0tc3VtbWFyeSdcbiAgICAgIHwgJy0tY2hlY2snXG4gICAgICB8ICctLWluZGV4J1xuICAgICAgfCAnLS1pbnRlbnQtdG8tYWRkJ1xuICAgICAgfCAnLS0zd2F5J1xuICAgICAgfCAnLS1hcHBseSdcbiAgICAgIHwgJy0tbm8tYWRkJ1xuICAgICAgfCAnLVInXG4gICAgICB8ICctLXJldmVyc2UnXG4gICAgICB8ICctLWFsbG93LWJpbmFyeS1yZXBsYWNlbWVudCdcbiAgICAgIHwgJy0tYmluYXJ5J1xuICAgICAgfCAnLS1yZWplY3QnXG4gICAgICB8ICcteidcbiAgICAgIHwgJy0taW5hY2N1cmF0ZS1lb2YnXG4gICAgICB8ICctLXJlY291bnQnXG4gICAgICB8ICctLWNhY2hlZCdcbiAgICAgIHwgJy0taWdub3JlLXNwYWNlLWNoYW5nZSdcbiAgICAgIHwgJy0taWdub3JlLXdoaXRlc3BhY2UnXG4gICAgICB8ICctLXZlcmJvc2UnXG4gICAgICB8ICctLXVuc2FmZS1wYXRocydcbiAgID4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0td2hpdGVzcGFjZScsICdub3dhcm4nIHwgJ3dhcm4nIHwgJ2ZpeCcgfCAnZXJyb3InIHwgJ2Vycm9yLWFsbCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLWJ1aWxkLWZha2UtYW5jZXN0b3InIHwgJy0tZXhjbHVkZScgfCAnLS1pbmNsdWRlJyB8ICctLWRpcmVjdG9yeScsIHN0cmluZz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy1wJyB8ICctQycsIG51bWJlcj47XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoVGFzayhwYXRjaGVzOiBzdHJpbmdbXSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydhcHBseScsIC4uLmN1c3RvbUFyZ3MsIC4uLnBhdGNoZXNdKTtcbn1cbiIsICJpbXBvcnQge1xuICAgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsXG4gICBCcmFuY2hTaW5nbGVEZWxldGVGYWlsdXJlLFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0LFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2Vzcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBCcmFuY2hEZWxldGlvbkJhdGNoIGltcGxlbWVudHMgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQge1xuICAgYWxsOiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRbXSA9IFtdO1xuICAgYnJhbmNoZXM6IHsgW2JyYW5jaE5hbWU6IHN0cmluZ106IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCB9ID0ge307XG4gICBlcnJvcnM6IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdFtdID0gW107XG5cbiAgIGdldCBzdWNjZXNzKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hEZWxldGlvblN1Y2Nlc3MoYnJhbmNoOiBzdHJpbmcsIGhhc2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZVN1Y2Nlc3Mge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZUZhaWx1cmUge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbmdsZUJyYW5jaERlbGV0ZUZhaWx1cmUoXG4gICB0ZXN0OiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRcbik6IHRlc3QgaXMgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2VzcyB7XG4gICByZXR1cm4gdGVzdC5zdWNjZXNzO1xufVxuIiwgImltcG9ydCB7IEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQge1xuICAgQnJhbmNoRGVsZXRpb25CYXRjaCxcbiAgIGJyYW5jaERlbGV0aW9uRmFpbHVyZSxcbiAgIGJyYW5jaERlbGV0aW9uU3VjY2Vzcyxcbn0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnknO1xuaW1wb3J0IHsgVGFza1BhcnNlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEV4aXRDb2RlcywgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgZGVsZXRlU3VjY2Vzc1JlZ2V4ID0gLyhcXFMrKVxccytcXChcXFMrXFxzKFteKV0rKVxcKS87XG5jb25zdCBkZWxldGVFcnJvclJlZ2V4ID0gL15lcnJvclteJ10rJyhbXiddKyknL207XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8QnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihkZWxldGVTdWNjZXNzUmVnZXgsIChyZXN1bHQsIFticmFuY2gsIGhhc2hdKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpO1xuXG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoZGVsZXRlRXJyb3JSZWdleCwgKHJlc3VsdCwgW2JyYW5jaF0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaCk7XG5cbiAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChkZWxldGlvbik7XG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQnJhbmNoRGVsZXRpb25zOiBUYXNrUGFyc2VyPHN0cmluZywgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+ID0gKFxuICAgc3RkT3V0LFxuICAgc3RkRXJyXG4pID0+IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hEZWxldGlvbkJhdGNoKCksIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0JyYW5jaERlbGV0aW9uRXJyb3IoZGF0YTogc3RyaW5nLCBwcm9jZXNzRXhpdENvZGU6IEV4aXRDb2Rlcyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHByb2Nlc3NFeGl0Q29kZSA9PT0gRXhpdENvZGVzLkVSUk9SICYmIGRlbGV0ZUVycm9yUmVnZXgudGVzdChkYXRhKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJyYW5jaFN1bW1hcnksIEJyYW5jaFN1bW1hcnlCcmFuY2ggfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGVudW0gQnJhbmNoU3RhdHVzSWRlbnRpZmllciB7XG4gICBDVVJSRU5UID0gJyonLFxuICAgTElOS0VEID0gJysnLFxufVxuXG5leHBvcnQgY2xhc3MgQnJhbmNoU3VtbWFyeVJlc3VsdCBpbXBsZW1lbnRzIEJyYW5jaFN1bW1hcnkge1xuICAgcHVibGljIGFsbDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBicmFuY2hlczogeyBbcDogc3RyaW5nXTogQnJhbmNoU3VtbWFyeUJyYW5jaCB9ID0ge307XG4gICBwdWJsaWMgY3VycmVudDogc3RyaW5nID0gJyc7XG4gICBwdWJsaWMgZGV0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgcHVzaChcbiAgICAgIHN0YXR1czogQnJhbmNoU3RhdHVzSWRlbnRpZmllciB8IHVua25vd24sXG4gICAgICBkZXRhY2hlZDogYm9vbGVhbixcbiAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgIGNvbW1pdDogc3RyaW5nLFxuICAgICAgbGFiZWw6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQpIHtcbiAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgIHRoaXMuY3VycmVudCA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLmJyYW5jaGVzW25hbWVdID0ge1xuICAgICAgICAgY3VycmVudDogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQsXG4gICAgICAgICBsaW5rZWRXb3JrVHJlZTogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkxJTktFRCxcbiAgICAgICAgIG5hbWUsXG4gICAgICAgICBjb21taXQsXG4gICAgICAgICBsYWJlbCxcbiAgICAgIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCcmFuY2hTdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBCcmFuY2hTdW1tYXJ5UmVzdWx0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnknO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxCcmFuY2hTdW1tYXJ5UmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbKitdXFxzKT9cXCgoPzpIRUFEICk/ZGV0YWNoZWQgKD86ZnJvbXxhdCkgKFxcUyspXFwpXFxzKyhbYS16MC05XSspXFxzKC4qKSQvLFxuICAgICAgKHJlc3VsdCwgW2N1cnJlbnQsIG5hbWUsIGNvbW1pdCwgbGFiZWxdKSA9PiB7XG4gICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIHRydWUsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oWyorXVxccyk/KFxcUyspXFxzKyhbYS16MC05XSspXFxzPyguKikkL3MsXG4gICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgZmFsc2UsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIGJyYW5jaFN0YXR1cyhpbnB1dD86IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0ID8gaW5wdXQuY2hhckF0KDApIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0OiBzdHJpbmcpOiBCcmFuY2hTdW1tYXJ5IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hTdW1tYXJ5UmVzdWx0KCksIHBhcnNlcnMsIHN0ZE91dCk7XG59XG4iLCAiaW1wb3J0IHsgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsIEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCwgQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IGhhc0JyYW5jaERlbGV0aW9uRXJyb3IsIHBhcnNlQnJhbmNoRGVsZXRpb25zIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1icmFuY2gtZGVsZXRlJztcbmltcG9ydCB7IHBhcnNlQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtYnJhbmNoJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGNvbW1hbmRzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgZGVsZXRlQ29tbWFuZHMgPSBbJy1kJywgJy1EJywgJy0tZGVsZXRlJ107XG4gICByZXR1cm4gY29tbWFuZHMuc29tZSgoY29tbWFuZCkgPT4gZGVsZXRlQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoVGFzayhcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPEJyYW5jaFN1bW1hcnkgfCBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IGlzRGVsZXRlID0gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGN1c3RvbUFyZ3MpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2JyYW5jaCcsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctYScpO1xuICAgfVxuXG4gICBpZiAoIWNvbW1hbmRzLmluY2x1ZGVzKCctdicpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgICAgaWYgKGlzRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpLmFsbFswXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hMb2NhbFRhc2soKTogU3RyaW5nVGFzazxCcmFuY2hTdW1tYXJ5PiB7XG4gICBjb25zdCBwYXJzZXIgPSBwYXJzZUJyYW5jaFN1bW1hcnk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWydicmFuY2gnLCAnLXYnXSxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVCcmFuY2hlc1Rhc2soXG4gICBicmFuY2hlczogc3RyaW5nW10sXG4gICBmb3JjZURlbGV0ZSA9IGZhbHNlXG4pOiBTdHJpbmdUYXNrPEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsnYnJhbmNoJywgJy12JywgZm9yY2VEZWxldGUgPyAnLUQnIDogJy1kJywgLi4uYnJhbmNoZXNdLFxuICAgICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IoeyBleGl0Q29kZSwgc3RkT3V0IH0sIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGRvbmUoc3RkT3V0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlQnJhbmNoVGFzayhcbiAgIGJyYW5jaDogc3RyaW5nLFxuICAgZm9yY2VEZWxldGUgPSBmYWxzZVxuKTogU3RyaW5nVGFzazxCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IHRhc2s6IFN0cmluZ1Rhc2s8QnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0PiA9IHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ2JyYW5jaCcsICctdicsIGZvcmNlRGVsZXRlID8gJy1EJyA6ICctZCcsIGJyYW5jaF0sXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYnJhbmNoZXNbYnJhbmNoXSE7XG4gICAgICB9LFxuICAgICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRFcnIsIHN0ZE91dCB9LCBlcnJvciwgXywgZmFpbCkge1xuICAgICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihcbiAgICAgICAgICAgIHRhc2sucGFyc2VyKGJ1ZmZlclRvU3RyaW5nKHN0ZE91dCksIGJ1ZmZlclRvU3RyaW5nKHN0ZEVycikpLFxuICAgICAgICAgICAgU3RyaW5nKGVycm9yKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gdGFzaztcbn1cbiIsICIvKipcbiAqIFBhcnNlciBmb3IgdGhlIGBjaGVjay1pZ25vcmVgIGNvbW1hbmQgLSByZXR1cm5zIGVhY2ggZmlsZSBhcyBhIHN0cmluZyBhcnJheVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VDaGVja0lnbm9yZSA9ICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gdGV4dFxuICAgICAgLnNwbGl0KC9cXG4vZylcbiAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgLmZpbHRlcigoZmlsZSkgPT4gISFmaWxlKTtcbn07XG4iLCAiaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ2hlY2tJZ25vcmUgfSBmcm9tICcuLi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZ25vcmVUYXNrKHBhdGhzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nW10+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydjaGVjay1pZ25vcmUnLCAuLi5wYXRoc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlQ2hlY2tJZ25vcmUsXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFwcGVuZCwgZmlsdGVyU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBDbG9uZU9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPFxuICAgICAgfCAnLS1iYXJlJ1xuICAgICAgfCAnLS1kaXNzb2NpYXRlJ1xuICAgICAgfCAnLS1taXJyb3InXG4gICAgICB8ICctLW5vLWNoZWNrb3V0J1xuICAgICAgfCAnLS1uby1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tbm8tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS1uby1zaW5nbGUtYnJhbmNoJ1xuICAgICAgfCAnLS1uby10YWdzJ1xuICAgICAgfCAnLS1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tc2luZ2xlLWJyYW5jaCdcbiAgICAgIHwgJy0tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS12ZXJib3NlJ1xuICAgPiAmXG4gICBPcHRpb25GbGFnczwnLS1kZXB0aCcgfCAnLWonIHwgJy0tam9icycsIG51bWJlcj4gJlxuICAgT3B0aW9uRmxhZ3M8XG4gICAgICB8ICctLWJyYW5jaCdcbiAgICAgIHwgJy0tb3JpZ2luJ1xuICAgICAgfCAnLS1yZWN1cnNlLXN1Ym1vZHVsZXMnXG4gICAgICB8ICctLXNlcGFyYXRlLWdpdC1kaXInXG4gICAgICB8ICctLXNoYWxsb3ctZXhjbHVkZSdcbiAgICAgIHwgJy0tc2hhbGxvdy1zaW5jZSdcbiAgICAgIHwgJy0tdGVtcGxhdGUnLFxuICAgICAgc3RyaW5nXG4gICA+O1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVGFzayhcbiAgIHJlcG86IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgIGRpcmVjdG9yeTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB8IEVtcHR5VGFzayB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY2xvbmUnLCAuLi5jdXN0b21BcmdzXTtcblxuICAgZmlsdGVyU3RyaW5nKHJlcG8pICYmIGNvbW1hbmRzLnB1c2gocmVwbyk7XG4gICBmaWx0ZXJTdHJpbmcoZGlyZWN0b3J5KSAmJiBjb21tYW5kcy5wdXNoKGRpcmVjdG9yeSk7XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVNaXJyb3JUYXNrKFxuICAgcmVwbzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgZGlyZWN0b3J5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKSB7XG4gICBhcHBlbmQoY3VzdG9tQXJncywgJy0tbWlycm9yJyk7XG5cbiAgIHJldHVybiBjbG9uZVRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKTtcbn1cbiIsICJpbXBvcnQgeyBGZXRjaFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxGZXRjaFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9Gcm9tICguKykkLywgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHtcbiAgICAgIHJlc3VsdC5yZW1vdGUgPSByZW1vdGU7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IGJyYW5jaF1cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LmJyYW5jaGVzLnB1c2goe1xuICAgICAgICAgbmFtZSxcbiAgICAgICAgIHRyYWNraW5nLFxuICAgICAgfSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IHRhZ11cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LnRhZ3MucHVzaCh7XG4gICAgICAgICBuYW1lLFxuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoLy0gXFxbZGVsZXRlZF1cXHMrXFxTK1xccyotPiAoLispJC8sIChyZXN1bHQsIFt0cmFja2luZ10pID0+IHtcbiAgICAgIHJlc3VsdC5kZWxldGVkLnB1c2goe1xuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXFxzKihbXi5dKylcXC5cXC4oXFxTKylcXHMrKFxcUyspXFxzKi0+ICguKykkLyxcbiAgICAgIChyZXN1bHQsIFtmcm9tLCB0bywgbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgICByZXN1bHQudXBkYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0cmFja2luZyxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZldGNoUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZyk6IEZldGNoUmVzdWx0IHtcbiAgIGNvbnN0IHJlc3VsdDogRmV0Y2hSZXN1bHQgPSB7XG4gICAgICByYXc6IHN0ZE91dCxcbiAgICAgIHJlbW90ZTogbnVsbCxcbiAgICAgIGJyYW5jaGVzOiBbXSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgdXBkYXRlZDogW10sXG4gICAgICBkZWxldGVkOiBbXSxcbiAgIH07XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufVxuIiwgImltcG9ydCB7IEZldGNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZUZldGNoUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1mZXRjaCc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrLCBFbXB0eVRhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoVGFzayhcbiAgIHJlbW90ZTogc3RyaW5nLFxuICAgYnJhbmNoOiBzdHJpbmcsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxGZXRjaFJlc3VsdD4gfCBFbXB0eVRhc2sge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2ZldGNoJywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgICAgY29tbWFuZHMucHVzaChyZW1vdGUsIGJyYW5jaCk7XG4gICB9XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUZldGNoUmVzdWx0LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBNb3ZlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPE1vdmVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcigvXlJlbmFtaW5nICguKykgdG8gKC4rKSQvLCAocmVzdWx0LCBbZnJvbSwgdG9dKSA9PiB7XG4gICAgICByZXN1bHQubW92ZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgfSksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNb3ZlUmVzdWx0KHN0ZE91dDogc3RyaW5nKTogTW92ZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IG1vdmVzOiBbXSB9LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxuIiwgImltcG9ydCB7IE1vdmVSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlTW92ZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbW92ZSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUYXNrKGZyb206IHN0cmluZyB8IHN0cmluZ1tdLCB0bzogc3RyaW5nKTogU3RyaW5nVGFzazxNb3ZlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IFsnbXYnLCAnLXYnLCAuLi5hc0FycmF5KGZyb20pLCB0b10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlTW92ZVJlc3VsdCxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgUHVsbFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VQdWxsRXJyb3JSZXN1bHQsIHBhcnNlUHVsbFJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtcHVsbCc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHVsbFRhc2soXG4gICByZW1vdGU6IE1heWJlPHN0cmluZz4sXG4gICBicmFuY2g6IE1heWJlPHN0cmluZz4sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxQdWxsUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ3B1bGwnLCAuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVtb3RlLCBicmFuY2gpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBQdWxsUmVzdWx0IHtcbiAgICAgICAgIHJldHVybiBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IocmVzdWx0LCBfZXJyb3IsIF9kb25lLCBmYWlsKSB7XG4gICAgICAgICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVB1bGxFcnJvclJlc3VsdChcbiAgICAgICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRPdXQpLFxuICAgICAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZEVycilcbiAgICAgICAgICk7XG4gICAgICAgICBpZiAocHVsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChuZXcgR2l0UmVzcG9uc2VFcnJvcihwdWxsRXJyb3IpKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZmFpbChfZXJyb3IpO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgZm9yRWFjaExpbmVXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3RlV2l0aFJlZnMgZXh0ZW5kcyBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICByZWZzOiB7XG4gICAgICBmZXRjaDogc3RyaW5nO1xuICAgICAgcHVzaDogc3RyaW5nO1xuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlR2V0UmVtb3Rlcyh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRob3V0UmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhvdXRSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWVdKSA9PiAocmVtb3Rlc1tuYW1lXSA9IHsgbmFtZSB9KSk7XG5cbiAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRoUmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWUsIHVybCwgcHVycG9zZV0pID0+IHtcbiAgICAgIGlmICghcmVtb3Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZWZzOiB7IGZldGNoOiAnJywgcHVzaDogJycgfSxcbiAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdXJwb3NlICYmIHVybCkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXS5yZWZzW3B1cnBvc2UucmVwbGFjZSgvW15hLXpdL2csICcnKSBhcyBrZXlvZiBSZW1vdGVXaXRoUmVmc1sncmVmcyddXSA9IHVybDtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZW1vdGVzKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh0ZXh0OiBzdHJpbmcsIGhhbmRsZXI6IChsaW5lOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgZm9yRWFjaExpbmVXaXRoQ29udGVudCh0ZXh0LCAobGluZSkgPT4gaGFuZGxlcihsaW5lLnNwbGl0KC9cXHMrLykpKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZUdldFJlbW90ZXMsIHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgfSBmcm9tICcuLi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZW1vdGVUYXNrKFxuICAgcmVtb3RlTmFtZTogc3RyaW5nLFxuICAgcmVtb3RlUmVwbzogc3RyaW5nLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmVtb3RlJywgJ2FkZCcsIC4uLmN1c3RvbUFyZ3MsIHJlbW90ZU5hbWUsIHJlbW90ZVJlcG9dKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbW90ZXNUYXNrKHZlcmJvc2U6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPGFueT4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3JlbW90ZSddO1xuICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcjogdmVyYm9zZSA/IHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgOiBwYXJzZUdldFJlbW90ZXMsXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFJlbW90ZXNUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gICBpZiAoY29tbWFuZHNbMF0gIT09ICdscy1yZW1vdGUnKSB7XG4gICAgICBjb21tYW5kcy51bnNoaWZ0KCdscy1yZW1vdGUnKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3RlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSA9IFtdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKGNvbW1hbmRzWzBdICE9PSAncmVtb3RlJykge1xuICAgICAgY29tbWFuZHMudW5zaGlmdCgncmVtb3RlJyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRhc2socmVtb3RlTmFtZTogc3RyaW5nKSB7XG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlbW90ZScsICdyZW1vdmUnLCByZW1vdGVOYW1lXSk7XG59XG4iLCAiaW1wb3J0IHsgTG9nT3B0aW9ucywgTG9nUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBsb2dGb3JtYXRGcm9tQ29tbWFuZCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQgdHlwZSB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyB9IGZyb20gJy4vZGlmZic7XG5pbXBvcnQgeyBwYXJzZUxvZ09wdGlvbnMgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgdHlwZSB7IEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFzaExpc3RUYXNrKFxuICAgb3B0OiBMb2dPcHRpb25zID0ge30sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogRW1wdHlUYXNrIHwgU3RyaW5nVGFzazxMb2dSZXN1bHQ+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnM8YW55PihvcHQpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3N0YXNoJywgJ2xpc3QnLCAuLi5vcHRpb25zLmNvbW1hbmRzLCAuLi5jdXN0b21BcmdzXTtcbiAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKFxuICAgICAgb3B0aW9ucy5zcGxpdHRlcixcbiAgICAgIG9wdGlvbnMuZmllbGRzLFxuICAgICAgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY29tbWFuZHMpXG4gICApO1xuXG4gICByZXR1cm4gKFxuICAgICAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgcGFyc2VyLFxuICAgICAgfVxuICAgKTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdWJNb2R1bGVUYXNrKHJlcG86IHN0cmluZywgcGF0aDogc3RyaW5nKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsnYWRkJywgcmVwbywgcGF0aF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN1Yk1vZHVsZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soWydpbml0JywgLi4uY3VzdG9tQXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViTW9kdWxlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChjb21tYW5kc1swXSAhPT0gJ3N1Ym1vZHVsZScpIHtcbiAgICAgIGNvbW1hbmRzLnVuc2hpZnQoJ3N1Ym1vZHVsZScpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsndXBkYXRlJywgLi4uY3VzdG9tQXJnc10pO1xufVxuIiwgImltcG9ydCB7IFRhZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgVGFnTGlzdCBpbXBsZW1lbnRzIFRhZ1Jlc3VsdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGxhdGVzdDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICApIHt9XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRhZ0xpc3QgPSBmdW5jdGlvbiAoZGF0YTogc3RyaW5nLCBjdXN0b21Tb3J0ID0gZmFsc2UpIHtcbiAgIGNvbnN0IHRhZ3MgPSBkYXRhLnNwbGl0KCdcXG4nKS5tYXAodHJpbW1lZCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICBpZiAoIWN1c3RvbVNvcnQpIHtcbiAgICAgIHRhZ3Muc29ydChmdW5jdGlvbiAodGFnQSwgdGFnQikge1xuICAgICAgICAgY29uc3QgcGFydHNBID0gdGFnQS5zcGxpdCgnLicpO1xuICAgICAgICAgY29uc3QgcGFydHNCID0gdGFnQi5zcGxpdCgnLicpO1xuXG4gICAgICAgICBpZiAocGFydHNBLmxlbmd0aCA9PT0gMSB8fCBwYXJ0c0IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlU29ydGVkKHRvTnVtYmVyKHBhcnRzQVswXSksIHRvTnVtYmVyKHBhcnRzQlswXSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHBhcnRzQS5sZW5ndGgsIHBhcnRzQi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gc29ydGVkKHRvTnVtYmVyKHBhcnRzQVtpXSksIHRvTnVtYmVyKHBhcnRzQltpXSkpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIGNvbnN0IGxhdGVzdCA9IGN1c3RvbVNvcnQgPyB0YWdzWzBdIDogWy4uLnRhZ3NdLnJldmVyc2UoKS5maW5kKCh0YWcpID0+IHRhZy5pbmRleE9mKCcuJykgPj0gMCk7XG5cbiAgIHJldHVybiBuZXcgVGFnTGlzdCh0YWdzLCBsYXRlc3QpO1xufTtcblxuZnVuY3Rpb24gc2luZ2xlU29ydGVkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgIGNvbnN0IGFJc051bSA9IGlzTmFOKGEpO1xuICAgY29uc3QgYklzTnVtID0gaXNOYU4oYik7XG5cbiAgIGlmIChhSXNOdW0gIT09IGJJc051bSkge1xuICAgICAgcmV0dXJuIGFJc051bSA/IDEgOiAtMTtcbiAgIH1cblxuICAgcmV0dXJuIGFJc051bSA/IHNvcnRlZChhLCBiKSA6IDA7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIHRyaW1tZWQoaW5wdXQ6IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0LnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIoaW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChpbnB1dC5yZXBsYWNlKC9eXFxEKy9nLCAnJyksIDEwKSB8fCAwO1xuICAgfVxuXG4gICByZXR1cm4gMDtcbn1cbiIsICJpbXBvcnQgeyBUYWdSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlVGFnTGlzdCB9IGZyb20gJy4uL3Jlc3BvbnNlcy9UYWdMaXN0JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQudGFnc2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhZ0xpc3RUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPFRhZ1Jlc3VsdD4ge1xuICAgY29uc3QgaGFzQ3VzdG9tU29ydCA9IGN1c3RvbUFyZ3Muc29tZSgob3B0aW9uKSA9PiAvXi0tc29ydD0vLnRlc3Qob3B0aW9uKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWyd0YWcnLCAnLWwnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZVRhZ0xpc3QodGV4dCwgaGFzQ3VzdG9tU29ydCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5hZGRUYWdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUYWdUYXNrKG5hbWU6IHN0cmluZyk6IFN0cmluZ1Rhc2s8eyBuYW1lOiBzdHJpbmcgfT4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ3RhZycsIG5hbWVdLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgICAgfSxcbiAgIH07XG59XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQuYWRkVGFnYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQW5ub3RhdGVkVGFnVGFzayhcbiAgIG5hbWU6IHN0cmluZyxcbiAgIHRhZ01lc3NhZ2U6IHN0cmluZ1xuKTogU3RyaW5nVGFzazx7IG5hbWU6IHN0cmluZyB9PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsndGFnJywgJy1hJywgJy1tJywgdGFnTWVzc2FnZSwgbmFtZV0sXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJjb25zdCB7IEdpdEV4ZWN1dG9yIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvcicpO1xuY29uc3QgeyBTaW1wbGVHaXRBcGkgfSA9IHJlcXVpcmUoJy4vbGliL3NpbXBsZS1naXQtYXBpJyk7XG5cbmNvbnN0IHsgU2NoZWR1bGVyIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL3NjaGVkdWxlcicpO1xuY29uc3QgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy90YXNrJyk7XG5jb25zdCB7XG4gICBhc0FycmF5LFxuICAgZmlsdGVyQXJyYXksXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSxcbiAgIGZpbHRlclR5cGUsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG4gICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudCxcbn0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xuY29uc3QgeyBhcHBseVBhdGNoVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvYXBwbHktcGF0Y2gnKTtcbmNvbnN0IHtcbiAgIGJyYW5jaFRhc2ssXG4gICBicmFuY2hMb2NhbFRhc2ssXG4gICBkZWxldGVCcmFuY2hlc1Rhc2ssXG4gICBkZWxldGVCcmFuY2hUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2JyYW5jaCcpO1xuY29uc3QgeyBjaGVja0lnbm9yZVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlnbm9yZScpO1xuY29uc3QgeyBjaGVja0lzUmVwb1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8nKTtcbmNvbnN0IHsgY2xvbmVUYXNrLCBjbG9uZU1pcnJvclRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2Nsb25lJyk7XG5jb25zdCB7IGNsZWFuV2l0aE9wdGlvbnNUYXNrLCBpc0NsZWFuT3B0aW9uc0FycmF5IH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9jbGVhbicpO1xuY29uc3QgeyBkaWZmU3VtbWFyeVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2RpZmYnKTtcbmNvbnN0IHsgZmV0Y2hUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9mZXRjaCcpO1xuY29uc3QgeyBtb3ZlVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvbW92ZScpO1xuY29uc3QgeyBwdWxsVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcHVsbCcpO1xuY29uc3QgeyBwdXNoVGFnc1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3B1c2gnKTtcbmNvbnN0IHtcbiAgIGFkZFJlbW90ZVRhc2ssXG4gICBnZXRSZW1vdGVzVGFzayxcbiAgIGxpc3RSZW1vdGVzVGFzayxcbiAgIHJlbW90ZVRhc2ssXG4gICByZW1vdmVSZW1vdGVUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3JlbW90ZScpO1xuY29uc3QgeyBnZXRSZXNldE1vZGUsIHJlc2V0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcmVzZXQnKTtcbmNvbnN0IHsgc3Rhc2hMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3Rhc2gtbGlzdCcpO1xuY29uc3Qge1xuICAgYWRkU3ViTW9kdWxlVGFzayxcbiAgIGluaXRTdWJNb2R1bGVUYXNrLFxuICAgc3ViTW9kdWxlVGFzayxcbiAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2ssXG59ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3ViLW1vZHVsZScpO1xuY29uc3QgeyBhZGRBbm5vdGF0ZWRUYWdUYXNrLCBhZGRUYWdUYXNrLCB0YWdMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvdGFnJyk7XG5jb25zdCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3Rhc2snKTtcblxuZnVuY3Rpb24gR2l0KG9wdGlvbnMsIHBsdWdpbnMpIHtcbiAgIHRoaXMuX2V4ZWN1dG9yID0gbmV3IEdpdEV4ZWN1dG9yKFxuICAgICAgb3B0aW9ucy5iaW5hcnksXG4gICAgICBvcHRpb25zLmJhc2VEaXIsXG4gICAgICBuZXcgU2NoZWR1bGVyKG9wdGlvbnMubWF4Q29uY3VycmVudFByb2Nlc3NlcyksXG4gICAgICBwbHVnaW5zXG4gICApO1xuXG4gICB0aGlzLl90cmltbWVkID0gb3B0aW9ucy50cmltbWVkO1xufVxuXG4oR2l0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlR2l0QXBpLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gR2l0O1xuXG4vKipcbiAqIFNldHMgdGhlIHBhdGggdG8gYSBjdXN0b20gZ2l0IGJpbmFyeSwgc2hvdWxkIGVpdGhlciBiZSBgZ2l0YCB3aGVuIHRoZXJlIGlzIGFuIGluc3RhbGxhdGlvbiBvZiBnaXQgYXZhaWxhYmxlIG9uXG4gKiB0aGUgc3lzdGVtIHBhdGgsIG9yIGEgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIGV4ZWN1dGFibGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1hbmRcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuY3VzdG9tQmluYXJ5ID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgIHRoaXMuX2V4ZWN1dG9yLmJpbmFyeSA9IGNvbW1hbmQ7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBmb3IgdGhlIHNwYXduZWQgY2hpbGQgcHJvY2VzcywgZWl0aGVyIHN1cHBseSBib3RoIGEgbmFtZSBhbmQgdmFsdWUgYXMgc3RyaW5ncyBvclxuICogYSBzaW5nbGUgb2JqZWN0IHRvIGVudGlyZWx5IHJlcGxhY2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuZW52ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX2V4ZWN1dG9yLmVudiA9IG5hbWU7XG4gICB9IGVsc2Uge1xuICAgICAgKHRoaXMuX2V4ZWN1dG9yLmVudiA9IHRoaXMuX2V4ZWN1dG9yLmVudiB8fCB7fSlbbmFtZV0gPSB2YWx1ZTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpc3QgdGhlIHN0YXNoKHMpIG9mIHRoZSBsb2NhbCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUuc3Rhc2hMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3Rhc2hMaXN0VGFzayhcbiAgICAgICAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3VtZW50cykgfHwge30sXG4gICAgICAgICAoZmlsdGVyQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucykgfHwgW11cbiAgICAgICksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsb25lVGFzayhhcGksIHRhc2ssIHJlcG9QYXRoLCBsb2NhbFBhdGgpIHtcbiAgIGlmICh0eXBlb2YgcmVwb1BhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhgZ2l0LiR7YXBpfSgpIHJlcXVpcmVzIGEgc3RyaW5nICdyZXBvUGF0aCdgKTtcbiAgIH1cblxuICAgcmV0dXJuIHRhc2socmVwb1BhdGgsIGZpbHRlclR5cGUobG9jYWxQYXRoLCBmaWx0ZXJTdHJpbmcpLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSk7XG59XG5cbi8qKlxuICogQ2xvbmUgYSBnaXQgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjcmVhdGVDbG9uZVRhc2soJ2Nsb25lJywgY2xvbmVUYXNrLCAuLi5hcmd1bWVudHMpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIE1pcnJvciBhIGdpdCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjcmVhdGVDbG9uZVRhc2soJ21pcnJvcicsIGNsb25lTWlycm9yVGFzaywgLi4uYXJndW1lbnRzKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBNb3ZlcyBvbmUgb3IgbW9yZSBmaWxlcyB0byBhIG5ldyBkZXN0aW5hdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtbXZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gKi9cbkdpdC5wcm90b3R5cGUubXYgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKG1vdmVUYXNrKGZyb20sIHRvKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZXMgcHVsbCBhbmQgdGFncyB0byBnZXQgdGhlIGxpc3Qgb2YgdGFncyB0aGVuIGNoZWNrcyBvdXQgdGhlIGxhdGVzdCB0YWcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tvdXRMYXRlc3RUYWcgPSBmdW5jdGlvbiAodGhlbikge1xuICAgdmFyIGdpdCA9IHRoaXM7XG4gICByZXR1cm4gdGhpcy5wdWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdpdC50YWdzKGZ1bmN0aW9uIChlcnIsIHRhZ3MpIHtcbiAgICAgICAgIGdpdC5jaGVja291dCh0YWdzLmxhdGVzdCwgdGhlbik7XG4gICAgICB9KTtcbiAgIH0pO1xufTtcblxuLyoqXG4gKiBQdWxsIHRoZSB1cGRhdGVkIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gKHJlbW90ZSwgYnJhbmNoLCBvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHB1bGxUYXNrKFxuICAgICAgICAgZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBmaWx0ZXJUeXBlKGJyYW5jaCwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIEZldGNoIHRoZSB1cGRhdGVkIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IHJlcG8uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLmZldGNoKCd1cHN0cmVhbScsICdtYXN0ZXInKSAvLyBmZXRjaGVzIGZyb20gbWFzdGVyIG9uIHJlbW90ZSBuYW1lZCB1cHN0cmVhbVxuICogICAuZmV0Y2goZnVuY3Rpb24gKCkge30pIC8vIHJ1bnMgZmV0Y2ggYWdhaW5zdCBkZWZhdWx0IHJlbW90ZSBhbmQgYnJhbmNoIGFuZCBjYWxscyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVtb3RlXVxuICogQHBhcmFtIHtzdHJpbmd9IFticmFuY2hdXG4gKi9cbkdpdC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAocmVtb3RlLCBicmFuY2gpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZmV0Y2hUYXNrKFxuICAgICAgICAgZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBmaWx0ZXJUeXBlKGJyYW5jaCwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERpc2FibGVzL2VuYWJsZXMgdGhlIHVzZSBvZiB0aGUgY29uc29sZSBmb3IgcHJpbnRpbmcgd2FybmluZ3MgYW5kIGVycm9ycywgYnkgZGVmYXVsdCBtZXNzYWdlcyBhcmUgbm90IHNob3duIGluXG4gKiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzaWxlbmNlXG4gKiBAcmV0dXJucyB7R2l0fVxuICovXG5HaXQucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uIChzaWxlbmNlKSB7XG4gICBjb25zb2xlLndhcm4oXG4gICAgICAnc2ltcGxlLWdpdCBkZXByZWNhdGlvbiBub3RpY2U6IGdpdC5zaWxlbnQ6IGxvZ2dpbmcgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIGBkZWJ1Z2AgbGlicmFyeSAvIGBERUJVR2AgZW52aXJvbm1lbnQgdmFyaWFibGUsIHRoaXMgd2lsbCBiZSBhbiBlcnJvciBpbiB2ZXJzaW9uIDMnXG4gICApO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHRhZ3MuIFdoZW4gdXNpbmcgZ2l0IDIuNy4wIG9yIGFib3ZlLCBpbmNsdWRlIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYFwiLS1zb3J0XCI6IFwicHJvcGVydHktbmFtZVwiYCB0b1xuICogc29ydCB0aGUgdGFncyBieSB0aGF0IHByb3BlcnR5IGluc3RlYWQgb2YgdXNpbmcgdGhlIGRlZmF1bHQgc2VtYW50aWMgdmVyc2lvbmluZyBzb3J0LlxuICpcbiAqIE5vdGUsIHN1cHBseWluZyB0aGlzIG9wdGlvbiB3aGVuIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBHaXQgdmVyc2lvbiB3aWxsIGNhdXNlIHRoZSBvcGVyYXRpb24gdG8gZmFpbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS50YWdzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgdGFnTGlzdFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJlYmFzZXMgdGhlIGN1cnJlbnQgd29ya2luZyBjb3B5LiBPcHRpb25zIGNhbiBiZSBzdXBwbGllZCBlaXRoZXIgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nIHBhcmFtZXRlcnNcbiAqIHRvIGJlIHNlbnQgdG8gdGhlIGBnaXQgcmViYXNlYCBjb21tYW5kLCBvciBhIHN0YW5kYXJkIG9wdGlvbnMgb2JqZWN0LlxuICovXG5HaXQucHJvdG90eXBlLnJlYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlYmFzZScsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVzZXQgYSByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICByZXNldFRhc2soZ2V0UmVzZXRNb2RlKG1vZGUpLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV2ZXJ0IG9uZSBvciBtb3JlIGNvbW1pdHMgaW4gdGhlIGxvY2FsIHdvcmtpbmcgY29weVxuICovXG5HaXQucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uIChjb21taXQpIHtcbiAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgaWYgKHR5cGVvZiBjb21taXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdDb21taXQgbXVzdCBiZSBhIHN0cmluZycpLCBuZXh0KTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2ZXJ0JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSksIGNvbW1pdF0pLFxuICAgICAgbmV4dFxuICAgKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlnaHR3ZWlnaHQgdGFnIHRvIHRoZSBoZWFkIG9mIHRoZSBjdXJyZW50IGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICBjb25zdCB0YXNrID1cbiAgICAgIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgPyBhZGRUYWdUYXNrKG5hbWUpXG4gICAgICAgICA6IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ0dpdC5hZGRUYWcgcmVxdWlyZXMgYSB0YWcgbmFtZScpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBhbm5vdGF0ZWQgdGFnIHRvIHRoZSBoZWFkIG9mIHRoZSBjdXJyZW50IGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmFkZEFubm90YXRlZFRhZyA9IGZ1bmN0aW9uICh0YWdOYW1lLCB0YWdNZXNzYWdlKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGFkZEFubm90YXRlZFRhZ1Rhc2sodGFnTmFtZSwgdGFnTWVzc2FnZSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgbG9jYWwgYnJhbmNoXG4gKi9cbkdpdC5wcm90b3R5cGUuZGVsZXRlTG9jYWxCcmFuY2ggPSBmdW5jdGlvbiAoYnJhbmNoTmFtZSwgZm9yY2VEZWxldGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGVsZXRlQnJhbmNoVGFzayhicmFuY2hOYW1lLCB0eXBlb2YgZm9yY2VEZWxldGUgPT09ICdib29sZWFuJyA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBvbmUgb3IgbW9yZSBsb2NhbCBicmFuY2hlc1xuICovXG5HaXQucHJvdG90eXBlLmRlbGV0ZUxvY2FsQnJhbmNoZXMgPSBmdW5jdGlvbiAoYnJhbmNoTmFtZXMsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGRlbGV0ZUJyYW5jaGVzVGFzayhicmFuY2hOYW1lcywgdHlwZW9mIGZvcmNlRGVsZXRlID09PSAnYm9vbGVhbicgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBicmFuY2hlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0IHwgc3RyaW5nW119IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuYnJhbmNoID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYnJhbmNoVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGxpc3Qgb2YgbG9jYWwgYnJhbmNoZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5icmFuY2hMb2NhbCA9IGZ1bmN0aW9uICh0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhicmFuY2hMb2NhbFRhc2soKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhbnkgY29tbWFuZCBhZ2FpbnN0IHRoZSBnaXQgYmluYXJ5LlxuICovXG5HaXQucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgY29uc3QgY3JlYXRlUmVzdENvbW1hbmRzID0gIUFycmF5LmlzQXJyYXkoY29tbWFuZHMpO1xuICAgY29uc3QgY29tbWFuZCA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlUmVzdENvbW1hbmRzID8gYXJndW1lbnRzIDogY29tbWFuZHMsIDApO1xuXG4gICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmQubGVuZ3RoICYmIGNyZWF0ZVJlc3RDb21tYW5kczsgaSsrKSB7XG4gICAgICBpZiAoIWZpbHRlclByaW1pdGl2ZXMoY29tbWFuZFtpXSkpIHtcbiAgICAgICAgIGNvbW1hbmQuc3BsaWNlKGksIGNvbW1hbmQubGVuZ3RoIC0gaSk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgY29tbWFuZC5wdXNoKC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDAsIHRydWUpKTtcblxuICAgdmFyIG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgaWYgKCFjb21tYW5kLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdSYXc6IG11c3Qgc3VwcGx5IG9uZSBvciBtb3JlIGNvbW1hbmQgdG8gZXhlY3V0ZScpLFxuICAgICAgICAgbmV4dFxuICAgICAgKTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kLCB0aGlzLl90cmltbWVkKSwgbmV4dCk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZUFkZCA9IGZ1bmN0aW9uIChyZXBvLCBwYXRoLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhhZGRTdWJNb2R1bGVUYXNrKHJlcG8sIHBhdGgpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChhcmdzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Ym1vZHVsZUluaXQgPSBmdW5jdGlvbiAoYXJncywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBpbml0U3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuc3ViTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3ViTW9kdWxlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUubGlzdFJlbW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgbGlzdFJlbW90ZXNUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcmVtb3RlIHRvIHRoZSBsaXN0IG9mIHJlbW90ZXMuXG4gKi9cbkdpdC5wcm90b3R5cGUuYWRkUmVtb3RlID0gZnVuY3Rpb24gKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgYWRkUmVtb3RlVGFzayhyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBlbnRyeSBieSBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgcmVtb3Rlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5yZW1vdmVSZW1vdGUgPSBmdW5jdGlvbiAocmVtb3RlTmFtZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2socmVtb3ZlUmVtb3RlVGFzayhyZW1vdGVOYW1lKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIHJlbW90ZXMsIHNldHRpbmcgdGhlIG9wdGlvbmFsIHZlcmJvc2UgYXJndW1lbnQgdG8gdHJ1ZSBpbmNsdWRlcyBhZGRpdGlvbmFsXG4gKiBkZXRhaWwgb24gdGhlIHJlbW90ZXMgdGhlbXNlbHZlcy5cbiAqL1xuR2l0LnByb3RvdHlwZS5nZXRSZW1vdGVzID0gZnVuY3Rpb24gKHZlcmJvc2UsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGdldFJlbW90ZXNUYXNrKHZlcmJvc2UgPT09IHRydWUpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIENhbGwgYW55IGBnaXQgcmVtb3RlYCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50cyBwYXNzZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5yZW1vdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICByZW1vdGVUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBDYWxsIGFueSBgZ2l0IHRhZ2AgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHMgcGFzc2VkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIGNvbnN0IGNvbW1hbmQgPSBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKTtcblxuICAgaWYgKGNvbW1hbmRbMF0gIT09ICd0YWcnKSB7XG4gICAgICBjb21tYW5kLnVuc2hpZnQoJ3RhZycpO1xuICAgfVxuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgcmVwb3NpdG9yeSBzZXJ2ZXIgaW5mb1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnVwZGF0ZVNlcnZlckluZm8gPSBmdW5jdGlvbiAodGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsndXBkYXRlLXNlcnZlci1pbmZvJ10pLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGUgY3VycmVudCB0YWcgY2hhbmdlcyB0byBhIHJlbW90ZSB3aGljaCBjYW4gYmUgZWl0aGVyIGEgVVJMIG9yIG5hbWVkIHJlbW90ZS4gV2hlbiBub3Qgc3BlY2lmaWVkIHVzZXMgdGhlXG4gKiBkZWZhdWx0IGNvbmZpZ3VyZWQgcmVtb3RlIHNwZWMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtyZW1vdGVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS5wdXNoVGFncyA9IGZ1bmN0aW9uIChyZW1vdGUsIHRoZW4pIHtcbiAgIGNvbnN0IHRhc2sgPSBwdXNoVGFnc1Rhc2soXG4gICAgICB7IHJlbW90ZTogZmlsdGVyVHlwZShyZW1vdGUsIGZpbHRlclN0cmluZykgfSxcbiAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICApO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIG5hbWVkIGZpbGVzIGZyb20gc291cmNlIGNvbnRyb2wuXG4gKi9cbkdpdC5wcm90b3R5cGUucm0gPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JtJywgJy1mJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBuYW1lZCBmaWxlcyBmcm9tIHNvdXJjZSBjb250cm9sIGJ1dCBrZWVwcyB0aGVtIG9uIGRpc2sgcmF0aGVyIHRoYW4gZGVsZXRpbmcgdGhlbSBlbnRpcmVseS4gVG9cbiAqIGNvbXBsZXRlbHkgcmVtb3ZlIHRoZSBmaWxlcywgdXNlIGBybWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVzXG4gKi9cbkdpdC5wcm90b3R5cGUucm1LZWVwTG9jYWwgPSBmdW5jdGlvbiAoZmlsZXMpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JtJywgJy0tY2FjaGVkJywgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBvYmplY3RzIGluIGEgdHJlZSBiYXNlZCBvbiBjb21taXQgaGFzaC4gUGFzc2luZyBpbiBhbiBvYmplY3QgaGFzaCByZXR1cm5zIHRoZSBvYmplY3QncyBjb250ZW50LFxuICogc2l6ZSwgYW5kIHR5cGUuXG4gKlxuICogUGFzc2luZyBcIi1wXCIgd2lsbCBpbnN0cnVjdCBjYXQtZmlsZSB0byBkZXRlcm1pbmUgdGhlIG9iamVjdCB0eXBlLCBhbmQgZGlzcGxheSBpdHMgZm9ybWF0dGVkIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2F0RmlsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fY2F0RmlsZSgndXRmLTgnLCBhcmd1bWVudHMpO1xufTtcblxuR2l0LnByb3RvdHlwZS5iaW5hcnlDYXRGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHRoaXMuX2NhdEZpbGUoJ2J1ZmZlcicsIGFyZ3VtZW50cyk7XG59O1xuXG5HaXQucHJvdG90eXBlLl9jYXRGaWxlID0gZnVuY3Rpb24gKGZvcm1hdCwgYXJncykge1xuICAgdmFyIGhhbmRsZXIgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJncyk7XG4gICB2YXIgY29tbWFuZCA9IFsnY2F0LWZpbGUnXTtcbiAgIHZhciBvcHRpb25zID0gYXJnc1swXTtcblxuICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdHaXQuY2F0RmlsZTogb3B0aW9ucyBtdXN0IGJlIHN1cHBsaWVkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MnKSxcbiAgICAgICAgIGhhbmRsZXJcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBjb21tYW5kLnB1c2guYXBwbHkoY29tbWFuZCwgb3B0aW9ucyk7XG4gICB9XG5cbiAgIGNvbnN0IHRhc2sgPVxuICAgICAgZm9ybWF0ID09PSAnYnVmZmVyJyA/IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZCkgOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmQpO1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBoYW5kbGVyKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCB0YXNrID0gZmlsdGVyU3RyaW5nKG9wdGlvbnMpXG4gICAgICA/IGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICdnaXQuZGlmZjogc3VwcGx5aW5nIG9wdGlvbnMgYXMgYSBzaW5nbGUgc3RyaW5nIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHN3aXRjaCB0byBhbiBhcnJheSBvZiBzdHJpbmdzJ1xuICAgICAgICApXG4gICAgICA6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydkaWZmJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5kaWZmU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgZGlmZlN1bW1hcnlUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5hcHBseVBhdGNoID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgIGNvbnN0IHRhc2sgPSAhZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheShwYXRjaGVzKVxuICAgICAgPyBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICBgZ2l0LmFwcGx5UGF0Y2ggcmVxdWlyZXMgb25lIG9yIG1vcmUgc3RyaW5nIHBhdGNoZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50YFxuICAgICAgICApXG4gICAgICA6IGFwcGx5UGF0Y2hUYXNrKGFzQXJyYXkocGF0Y2hlcyksIGdldFRyYWlsaW5nT3B0aW9ucyhbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5yZXZwYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZXYtcGFyc2UnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCB0cnVlKV07XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMsIHRydWUpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqL1xuR2l0LnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uIChtb2RlLCBvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID0gaXNDbGVhbk9wdGlvbnNBcnJheShtb2RlKTtcbiAgIGNvbnN0IGNsZWFuTW9kZSA9XG4gICAgICAodXNpbmdDbGVhbk9wdGlvbnNBcnJheSAmJiBtb2RlLmpvaW4oJycpKSB8fCBmaWx0ZXJUeXBlKG1vZGUsIGZpbHRlclN0cmluZykgfHwgJyc7XG4gICBjb25zdCBjdXN0b21BcmdzID0gZ2V0VHJhaWxpbmdPcHRpb25zKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCB1c2luZ0NsZWFuT3B0aW9uc0FycmF5ID8gMSA6IDApKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjbGVhbldpdGhPcHRpb25zVGFzayhjbGVhbk1vZGUsIGN1c3RvbUFyZ3MpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAodGhlbikge1xuICAgY29uc3QgdGFzayA9IHtcbiAgICAgIGNvbW1hbmRzOiBbXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcigpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbigpO1xuICAgICAgICAgfVxuICAgICAgfSxcbiAgIH07XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2spO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHF1ZXVlIG9mIHBlbmRpbmcgY29tbWFuZHMgYW5kIHJldHVybnMgdGhlIHdyYXBwZXIgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICpcbiAqIEByZXR1cm5zIHtHaXR9XG4gKi9cbkdpdC5wcm90b3R5cGUuY2xlYXJRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIC8vIFRPRE86XG4gICAvLyB0aGlzLl9leGVjdXRvci5jbGVhcigpO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcGF0aG5hbWUgb3IgcGF0aG5hbWVzIGFyZSBleGNsdWRlZCBieSAuZ2l0aWdub3JlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGhuYW1lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuY2hlY2tJZ25vcmUgPSBmdW5jdGlvbiAocGF0aG5hbWVzLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNoZWNrSWdub3JlVGFzayhhc0FycmF5KGZpbHRlclR5cGUocGF0aG5hbWVzLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5jaGVja0lzUmVwbyA9IGZ1bmN0aW9uIChjaGVja1R5cGUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY2hlY2tJc1JlcG9UYXNrKGZpbHRlclR5cGUoY2hlY2tUeXBlLCBmaWx0ZXJTdHJpbmcpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHaXQ7XG4iLCAiaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuL2FyZ3MvcGF0aHNwZWMnO1xuaW1wb3J0IHsgR2l0Q29uc3RydWN0RXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtY29uc3RydWN0LWVycm9yJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvcic7XG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IFRhc2tDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3InO1xuaW1wb3J0IHsgQ2hlY2tSZXBvQWN0aW9ucyB9IGZyb20gJy4vdGFza3MvY2hlY2staXMtcmVwbyc7XG5pbXBvcnQgeyBDbGVhbk9wdGlvbnMgfSBmcm9tICcuL3Rhc2tzL2NsZWFuJztcbmltcG9ydCB7IEdpdENvbmZpZ1Njb3BlIH0gZnJvbSAnLi90YXNrcy9jb25maWcnO1xuaW1wb3J0IHsgRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMnO1xuaW1wb3J0IHsgZ3JlcFF1ZXJ5QnVpbGRlciB9IGZyb20gJy4vdGFza3MvZ3JlcCc7XG5pbXBvcnQgeyBSZXNldE1vZGUgfSBmcm9tICcuL3Rhc2tzL3Jlc2V0JztcblxuZXhwb3J0IHtcbiAgIENoZWNrUmVwb0FjdGlvbnMsXG4gICBDbGVhbk9wdGlvbnMsXG4gICBEaWZmTmFtZVN0YXR1cyxcbiAgIEdpdENvbmZpZ1Njb3BlLFxuICAgR2l0Q29uc3RydWN0RXJyb3IsXG4gICBHaXRFcnJvcixcbiAgIEdpdFBsdWdpbkVycm9yLFxuICAgR2l0UmVzcG9uc2VFcnJvcixcbiAgIFJlc2V0TW9kZSxcbiAgIFRhc2tDb25maWd1cmF0aW9uRXJyb3IsXG4gICBncmVwUXVlcnlCdWlsZGVyLFxuICAgcGF0aHNwZWMsXG59O1xuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgYEdpdENvbnN0cnVjdEVycm9yYCBpcyB0aHJvd24gd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBvZiB0aGUgYHNpbXBsZS1naXRgIGluc3RhbmNlIGl0c2VsZi4gTW9zdCBjb21tb25seSBhcyBhIHJlc3VsdCBvZiB1c2luZ1xuICogYSBgYmFzZURpcmAgb3B0aW9uIHRoYXQgcG9pbnRzIHRvIGEgZm9sZGVyIHRoYXQgZWl0aGVyIGRvZXMgbm90IGV4aXN0LFxuICogb3IgY2Fubm90IGJlIHJlYWQgYnkgdGhlIHVzZXIgdGhlIG5vZGUgc2NyaXB0IGlzIHJ1bm5pbmcgYXMuXG4gKlxuICogQ2hlY2sgdGhlIGAubWVzc2FnZWAgcHJvcGVydHkgZm9yIG1vcmUgZGV0YWlsIGluY2x1ZGluZyB0aGUgcHJvcGVydGllc1xuICogcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEdpdENvbnN0cnVjdEVycm9yIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgY29uZmlnOiBTaW1wbGVHaXRPcHRpb25zLFxuICAgICAgbWVzc2FnZTogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucywgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuXG5leHBvcnQgY2xhc3MgR2l0UGx1Z2luRXJyb3IgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyB0YXNrPzogU2ltcGxlR2l0VGFzazxhbnk+LFxuICAgICAgcHVibGljIHJlYWRvbmx5IHBsdWdpbj86IGtleW9mIFNpbXBsZUdpdE9wdGlvbnMsXG4gICAgICBtZXNzYWdlPzogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHRhc2ssIG1lc3NhZ2UpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0UGx1Z2luKHNpZ25hbDogU2ltcGxlR2l0T3B0aW9uc1snYWJvcnQnXSkge1xuICAgaWYgKCFzaWduYWwpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgY29uc3Qgb25TcGF3bkFmdGVyOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih1bmRlZmluZWQsICdhYm9ydCcsICdBYm9ydCBzaWduYWwgcmVjZWl2ZWQnKSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGtpbGwpO1xuXG4gICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2Nsb3NlJywgKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywga2lsbCkpO1xuICAgICAgfSxcbiAgIH07XG5cbiAgIGNvbnN0IG9uU3Bhd25CZWZvcmU6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYmVmb3JlJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYmVmb3JlJyxcbiAgICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ2Fib3J0JywgJ0Fib3J0IGFscmVhZHkgc2lnbmFsZWQnKSk7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcblxuICAgcmV0dXJuIFtvblNwYXduQmVmb3JlLCBvblNwYXduQWZ0ZXJdO1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRQbHVnaW5Db25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGlzQ29uZmlnU3dpdGNoKGFyZzogc3RyaW5nIHwgdW5rbm93bikge1xuICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gJy1jJztcbn1cblxuZnVuY3Rpb24gcHJldmVudFByb3RvY29sT3ZlcnJpZGUoYXJnOiBzdHJpbmcsIG5leHQ6IHN0cmluZykge1xuICAgaWYgKCFpc0NvbmZpZ1N3aXRjaChhcmcpKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIGlmICghL15cXHMqcHJvdG9jb2woLlthLXpdKyk/LmFsbG93Ly50ZXN0KG5leHQpKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgICd1bnNhZmUnLFxuICAgICAgJ0NvbmZpZ3VyaW5nIHByb3RvY29sLmFsbG93IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZUV4dFByb3RvY29sJ1xuICAgKTtcbn1cblxuZnVuY3Rpb24gcHJldmVudFVwbG9hZFBhY2soYXJnOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nKSB7XG4gICBpZiAoL15cXHMqLS0odXBsb2FkfHJlY2VpdmUpLXBhY2svLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIC0tdXBsb2FkLXBhY2sgb3IgLS1yZWNlaXZlLXBhY2sgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChtZXRob2QgPT09ICdjbG9uZScgJiYgL15cXHMqLXVcXGIvLnRlc3QoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgJ3Vuc2FmZScsXG4gICAgICAgICBgVXNlIG9mIGNsb25lIHdpdGggb3B0aW9uIC11IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZVBhY2tgXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAobWV0aG9kID09PSAncHVzaCcgJiYgL15cXHMqLS1leGVjXFxiLy50ZXN0KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICd1bnNhZmUnLFxuICAgICAgICAgYFVzZSBvZiBwdXNoIHdpdGggb3B0aW9uIC0tZXhlYyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICAgKTtcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbih7XG4gICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgPSBmYWxzZSxcbiAgIGFsbG93VW5zYWZlUGFjayA9IGZhbHNlLFxufTogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWyd1bnNhZmUnXSA9IHt9KTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICBhcmdzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaW5kZXggPCBhcmdzLmxlbmd0aCA/IGFyZ3NbaW5kZXggKyAxXSA6ICcnO1xuXG4gICAgICAgICAgICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgfHwgcHJldmVudFByb3RvY29sT3ZlcnJpZGUoY3VycmVudCwgbmV4dCk7XG4gICAgICAgICAgICBhbGxvd1Vuc2FmZVBhY2sgfHwgcHJldmVudFVwbG9hZFBhY2soY3VycmVudCwgY29udGV4dC5tZXRob2QpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgcHJlZml4ZWRBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbihcbiAgIGNvbmZpZ3VyYXRpb246IHN0cmluZ1tdXG4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFyZ3MnPiB7XG4gICBjb25zdCBwcmVmaXggPSBwcmVmaXhlZEFycmF5KGNvbmZpZ3VyYXRpb24sICctYycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIHJldHVybiBbLi4ucHJlZml4LCAuLi5kYXRhXTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGRlZmVycmVkLCBEZWZlcnJlZFByb21pc2UgfSBmcm9tICdAa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmNvbnN0IG5ldmVyID0gZGVmZXJyZWQoKS5wcm9taXNlO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGlvbkRldGVjdGlvblBsdWdpbih7XG4gICBvbkNsb3NlID0gdHJ1ZSxcbiAgIG9uRXhpdCA9IDUwLFxufTogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWydjb21wbGV0aW9uJ10gPSB7fSk6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiB7XG4gICBmdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gICAgICBsZXQgZXhpdENvZGUgPSAtMTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IHtcbiAgICAgICAgIGNsb3NlOiBkZWZlcnJlZCgpLFxuICAgICAgICAgY2xvc2VUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgICAgZXhpdDogZGVmZXJyZWQoKSxcbiAgICAgICAgIGV4aXRUaW1lb3V0OiBkZWZlcnJlZCgpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgIG9uQ2xvc2UgPT09IGZhbHNlID8gbmV2ZXIgOiBldmVudHMuY2xvc2VUaW1lb3V0LnByb21pc2UsXG4gICAgICAgICBvbkV4aXQgPT09IGZhbHNlID8gbmV2ZXIgOiBldmVudHMuZXhpdFRpbWVvdXQucHJvbWlzZSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25maWd1cmVUaW1lb3V0KG9uQ2xvc2UsIGV2ZW50cy5jbG9zZSwgZXZlbnRzLmNsb3NlVGltZW91dCk7XG4gICAgICBjb25maWd1cmVUaW1lb3V0KG9uRXhpdCwgZXZlbnRzLmV4aXQsIGV2ZW50cy5leGl0VGltZW91dCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICBjbG9zZShjb2RlOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgICAgIGV2ZW50cy5jbG9zZS5kb25lKCk7XG4gICAgICAgICB9LFxuICAgICAgICAgZXhpdChjb2RlOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgICAgIGV2ZW50cy5leGl0LmRvbmUoKTtcbiAgICAgICAgIH0sXG4gICAgICAgICBnZXQgZXhpdENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpdENvZGU7XG4gICAgICAgICB9LFxuICAgICAgICAgcmVzdWx0LFxuICAgICAgfTtcbiAgIH1cblxuICAgZnVuY3Rpb24gY29uZmlndXJlVGltZW91dChcbiAgICAgIGZsYWc6IGJvb2xlYW4gfCBudW1iZXIsXG4gICAgICBldmVudDogRGVmZXJyZWRQcm9taXNlPHZvaWQ+LFxuICAgICAgdGltZW91dDogRGVmZXJyZWRQcm9taXNlPHZvaWQ+XG4gICApIHtcbiAgICAgIGlmIChmbGFnID09PSBmYWxzZSkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAoZmxhZyA9PT0gdHJ1ZSA/IGV2ZW50LnByb21pc2UgOiBldmVudC5wcm9taXNlLnRoZW4oKCkgPT4gZGVsYXkoZmxhZykpKS50aGVuKHRpbWVvdXQuZG9uZSk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYXN5bmMgYWN0aW9uKF9kYXRhLCB7IHNwYXduZWQsIGNsb3NlIH0pIHtcbiAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gICAgICAgICBsZXQgZGVmZXJDbG9zZSA9IHRydWU7XG4gICAgICAgICBsZXQgcXVpY2tDbG9zZSA9ICgpID0+IHZvaWQgKGRlZmVyQ2xvc2UgPSBmYWxzZSk7XG5cbiAgICAgICAgIHNwYXduZWQuc3Rkb3V0Py5vbignZGF0YScsIHF1aWNrQ2xvc2UpO1xuICAgICAgICAgc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgcXVpY2tDbG9zZSk7XG4gICAgICAgICBzcGF3bmVkLm9uKCdlcnJvcicsIHF1aWNrQ2xvc2UpO1xuXG4gICAgICAgICBzcGF3bmVkLm9uKCdjbG9zZScsIChjb2RlOiBudW1iZXIpID0+IGV2ZW50cy5jbG9zZShjb2RlKSk7XG4gICAgICAgICBzcGF3bmVkLm9uKCdleGl0JywgKGNvZGU6IG51bWJlcikgPT4gZXZlbnRzLmV4aXQoY29kZSkpO1xuXG4gICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXZlbnRzLnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChkZWZlckNsb3NlKSB7XG4gICAgICAgICAgICAgICBhd2FpdCBkZWxheSg1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUpO1xuICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUsIGVyciBhcyBFcnJvcik7XG4gICAgICAgICB9XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgR2l0RXhlY3V0b3JSZXN1bHQsIFNpbXBsZUdpdFBsdWdpbkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG50eXBlIFRhc2tSZXN1bHQgPSBPbWl0PEdpdEV4ZWN1dG9yUmVzdWx0LCAncmVqZWN0aW9uJz47XG5cbmZ1bmN0aW9uIGlzVGFza0Vycm9yKHJlc3VsdDogVGFza1Jlc3VsdCkge1xuICAgcmV0dXJuICEhKHJlc3VsdC5leGl0Q29kZSAmJiByZXN1bHQuc3RkRXJyLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShyZXN1bHQ6IFRhc2tSZXN1bHQpIHtcbiAgIHJldHVybiBCdWZmZXIuY29uY2F0KFsuLi5yZXN1bHQuc3RkT3V0LCAuLi5yZXN1bHQuc3RkRXJyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckRldGVjdGlvbkhhbmRsZXIoXG4gICBvdmVyd3JpdGUgPSBmYWxzZSxcbiAgIGlzRXJyb3IgPSBpc1Rhc2tFcnJvcixcbiAgIGVycm9yTWVzc2FnZTogKHJlc3VsdDogVGFza1Jlc3VsdCkgPT4gQnVmZmVyIHwgRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2Vcbikge1xuICAgcmV0dXJuIChlcnJvcjogQnVmZmVyIHwgRXJyb3IgfCB1bmRlZmluZWQsIHJlc3VsdDogVGFza1Jlc3VsdCkgPT4ge1xuICAgICAgaWYgKCghb3ZlcndyaXRlICYmIGVycm9yKSB8fCAhaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvck1lc3NhZ2UocmVzdWx0KTtcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckRldGVjdGlvblBsdWdpbihcbiAgIGNvbmZpZzogU2ltcGxlR2l0UGx1Z2luQ29uZmlnWydlcnJvcnMnXVxuKTogU2ltcGxlR2l0UGx1Z2luPCd0YXNrLmVycm9yJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0YXNrLmVycm9yJyxcbiAgICAgIGFjdGlvbihkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBjb25zdCBlcnJvciA9IGNvbmZpZyhkYXRhLmVycm9yLCB7XG4gICAgICAgICAgICBzdGRFcnI6IGNvbnRleHQuc3RkRXJyLFxuICAgICAgICAgICAgc3RkT3V0OiBjb250ZXh0LnN0ZE91dCxcbiAgICAgICAgICAgIGV4aXRDb2RlOiBjb250ZXh0LmV4aXRDb2RlLFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZXJyb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbmV3IEdpdEVycm9yKHVuZGVmaW5lZCwgZXJyb3IudG9TdHJpbmcoJ3V0Zi04JykpIH07XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4sIFNpbXBsZUdpdFBsdWdpblR5cGUsIFNpbXBsZUdpdFBsdWdpblR5cGVzIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5pbXBvcnQgeyBhcHBlbmQsIGFzQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBQbHVnaW5TdG9yZSB7XG4gICBwcml2YXRlIHBsdWdpbnM6IFNldDxTaW1wbGVHaXRQbHVnaW48U2ltcGxlR2l0UGx1Z2luVHlwZT4+ID0gbmV3IFNldCgpO1xuXG4gICBwdWJsaWMgYWRkPFQgZXh0ZW5kcyBTaW1wbGVHaXRQbHVnaW5UeXBlPihcbiAgICAgIHBsdWdpbjogdm9pZCB8IFNpbXBsZUdpdFBsdWdpbjxUPiB8IFNpbXBsZUdpdFBsdWdpbjxUPltdXG4gICApIHtcbiAgICAgIGNvbnN0IHBsdWdpbnM6IFNpbXBsZUdpdFBsdWdpbjxUPltdID0gW107XG5cbiAgICAgIGFzQXJyYXkocGx1Z2luKS5mb3JFYWNoKChwbHVnaW4pID0+IHBsdWdpbiAmJiB0aGlzLnBsdWdpbnMuYWRkKGFwcGVuZChwbHVnaW5zLCBwbHVnaW4pKSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4gdGhpcy5wbHVnaW5zLmRlbGV0ZShwbHVnaW4pKTtcbiAgICAgIH07XG4gICB9XG5cbiAgIHB1YmxpYyBleGVjPFQgZXh0ZW5kcyBTaW1wbGVHaXRQbHVnaW5UeXBlPihcbiAgICAgIHR5cGU6IFQsXG4gICAgICBkYXRhOiBTaW1wbGVHaXRQbHVnaW5UeXBlc1tUXVsnZGF0YSddLFxuICAgICAgY29udGV4dDogU2ltcGxlR2l0UGx1Z2luVHlwZXNbVF1bJ2NvbnRleHQnXVxuICAgKTogdHlwZW9mIGRhdGEge1xuICAgICAgbGV0IG91dHB1dCA9IGRhdGE7XG4gICAgICBjb25zdCBjb250ZXh0dWFsID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKGNvbnRleHQpKTtcblxuICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICBpZiAocGx1Z2luLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHBsdWdpbi5hY3Rpb24ob3V0cHV0LCBjb250ZXh0dWFsKTtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNOdW1iZXIsIGluY2x1ZGluZyB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9ncmVzc01vbml0b3JQbHVnaW4ocHJvZ3Jlc3M6IEV4Y2x1ZGU8U2ltcGxlR2l0T3B0aW9uc1sncHJvZ3Jlc3MnXSwgdm9pZD4pIHtcbiAgIGNvbnN0IHByb2dyZXNzQ29tbWFuZCA9ICctLXByb2dyZXNzJztcbiAgIGNvbnN0IHByb2dyZXNzTWV0aG9kcyA9IFsnY2hlY2tvdXQnLCAnY2xvbmUnLCAnZmV0Y2gnLCAncHVsbCcsICdwdXNoJ107XG5cbiAgIGNvbnN0IG9uUHJvZ3Jlc3M6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYWZ0ZXInPiA9IHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hZnRlcicsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmICghY29udGV4dC5jb21tYW5kcy5pbmNsdWRlcyhwcm9ncmVzc0NvbW1hbmQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9uKCdkYXRhJywgKGNodW5rOiBCdWZmZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAvXihbXFxzXFxTXSs/KTpcXHMqKFxcZCspJSBcXCgoXFxkKylcXC8oXFxkKylcXCkvLmV4ZWMoY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgIHN0YWdlOiBwcm9ncmVzc0V2ZW50U3RhZ2UobWVzc2FnZVsxXSksXG4gICAgICAgICAgICAgICBwcm9ncmVzczogYXNOdW1iZXIobWVzc2FnZVsyXSksXG4gICAgICAgICAgICAgICBwcm9jZXNzZWQ6IGFzTnVtYmVyKG1lc3NhZ2VbM10pLFxuICAgICAgICAgICAgICAgdG90YWw6IGFzTnVtYmVyKG1lc3NhZ2VbNF0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBjb25zdCBvbkFyZ3M6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYXJncyc+ID0ge1xuICAgICAgdHlwZTogJ3NwYXduLmFyZ3MnLFxuICAgICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmICghcHJvZ3Jlc3NNZXRob2RzLmluY2x1ZGVzKGNvbnRleHQubWV0aG9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBpbmNsdWRpbmcoYXJncywgcHJvZ3Jlc3NDb21tYW5kKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gW29uQXJncywgb25Qcm9ncmVzc107XG59XG5cbmZ1bmN0aW9uIHByb2dyZXNzRXZlbnRTdGFnZShpbnB1dDogc3RyaW5nKSB7XG4gICByZXR1cm4gU3RyaW5nKGlucHV0LnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnLCAxKSkgfHwgJ3Vua25vd24nO1xufVxuIiwgImltcG9ydCB7IFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcGljayB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gc3Bhd25PcHRpb25zUGx1Z2luKFxuICAgc3Bhd25PcHRpb25zOiBQYXJ0aWFsPFNwYXduT3B0aW9ucz5cbik6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24ub3B0aW9ucyc+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwaWNrKHNwYXduT3B0aW9ucywgWyd1aWQnLCAnZ2lkJ10pO1xuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLm9wdGlvbnMnLFxuICAgICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIC4uLmRhdGEgfTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFBsdWdpbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dFBsdWdpbih7XG4gICBibG9jayxcbiAgIHN0ZEVyciA9IHRydWUsXG4gICBzdGRPdXQgPSB0cnVlLFxufTogRXhjbHVkZTxTaW1wbGVHaXRPcHRpb25zWyd0aW1lb3V0J10sIHVuZGVmaW5lZD4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gfCB2b2lkIHtcbiAgIGlmIChibG9jayA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGtpbGwsIGJsb2NrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRvdXQ/Lm9mZignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub2ZmKCdkYXRhJywgd2FpdCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKCdleGl0Jywgc3RvcCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub2ZmKCdjbG9zZScsIHN0b3ApO1xuICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHVuZGVmaW5lZCwgJ3RpbWVvdXQnLCBgYmxvY2sgdGltZW91dCByZWFjaGVkYCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGRPdXQgJiYgY29udGV4dC5zcGF3bmVkLnN0ZG91dD8ub24oJ2RhdGEnLCB3YWl0KTtcbiAgICAgICAgICAgIHN0ZEVyciAmJiBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vbignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKCdleGl0Jywgc3RvcCk7XG4gICAgICAgICAgICBjb250ZXh0LnNwYXduZWQub24oJ2Nsb3NlJywgc3RvcCk7XG5cbiAgICAgICAgICAgIHdhaXQoKTtcbiAgICAgICAgIH0sXG4gICAgICB9O1xuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuaW1wb3J0IHsgaXNQYXRoU3BlYywgdG9QYXRocyB9IGZyb20gJy4uL2FyZ3MvcGF0aHNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3VmZml4UGF0aHNQbHVnaW4oKTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZ1tdID0gW107XG4gICAgICAgICBsZXQgc3VmZml4OiB1bmRlZmluZWQgfCBzdHJpbmdbXTtcbiAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZChhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgICAgICAgKHN1ZmZpeCA9IHN1ZmZpeCB8fCBbXSkucHVzaCguLi5hcmdzKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGRhdGFbaV07XG5cbiAgICAgICAgICAgIGlmIChpc1BhdGhTcGVjKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgYXBwZW5kKHRvUGF0aHMocGFyYW0pKTtcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW0gPT09ICctLScpIHtcbiAgICAgICAgICAgICAgIGFwcGVuZChcbiAgICAgICAgICAgICAgICAgIGRhdGEuc2xpY2UoaSArIDEpLmZsYXRNYXAoKGl0ZW0pID0+IChpc1BhdGhTcGVjKGl0ZW0pICYmIHRvUGF0aHMoaXRlbSkpIHx8IGl0ZW0pXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWZpeC5wdXNoKHBhcmFtKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuICFzdWZmaXggPyBwcmVmaXggOiBbLi4ucHJlZml4LCAnLS0nLCAuLi5zdWZmaXgubWFwKFN0cmluZyldO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0RmFjdG9yeSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xuXG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi9hcGknO1xuaW1wb3J0IHtcbiAgIGFib3J0UGx1Z2luLFxuICAgYmxvY2tVbnNhZmVPcGVyYXRpb25zUGx1Z2luLFxuICAgY29tbWFuZENvbmZpZ1ByZWZpeGluZ1BsdWdpbixcbiAgIGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4sXG4gICBlcnJvckRldGVjdGlvbkhhbmRsZXIsXG4gICBlcnJvckRldGVjdGlvblBsdWdpbixcbiAgIFBsdWdpblN0b3JlLFxuICAgcHJvZ3Jlc3NNb25pdG9yUGx1Z2luLFxuICAgc3Bhd25PcHRpb25zUGx1Z2luLFxuICAgdGltZW91dFBsdWdpbixcbn0gZnJvbSAnLi9wbHVnaW5zJztcbmltcG9ydCB7IHN1ZmZpeFBhdGhzUGx1Z2luIH0gZnJvbSAnLi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4nO1xuaW1wb3J0IHsgY3JlYXRlSW5zdGFuY2VDb25maWcsIGZvbGRlckV4aXN0cyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBHaXQgPSByZXF1aXJlKCcuLi9naXQnKTtcblxuLyoqXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byB0aGUgc3VwcGxpZWQgb2JqZWN0IHRvIGVuYWJsZSBpdCBmb3IgdXNlIGFzXG4gKiB0aGUgZGVmYXVsdCBleHBvcnQgb2YgYSBtb2R1bGUuXG4gKlxuICogRWc6IGBtb2R1bGUuZXhwb3J0cyA9IGVzTW9kdWxlRmFjdG9yeSh7IHNvbWV0aGluZyAoKSB7fSB9KWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzTW9kdWxlRmFjdG9yeTxUPihkZWZhdWx0RXhwb3J0OiBUKSB7XG4gICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVmYXVsdEV4cG9ydCwge1xuICAgICAgX19lc01vZHVsZTogeyB2YWx1ZTogdHJ1ZSB9LFxuICAgICAgZGVmYXVsdDogeyB2YWx1ZTogZGVmYXVsdEV4cG9ydCB9LFxuICAgfSkgYXMgVCAmIHsgX19lc01vZHVsZTogdHJ1ZTsgZGVmYXVsdDogVCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2l0RXhwb3J0RmFjdG9yeShmYWN0b3J5OiBTaW1wbGVHaXRGYWN0b3J5KSB7XG4gICByZXR1cm4gT2JqZWN0LmFzc2lnbihmYWN0b3J5LmJpbmQobnVsbCksIGFwaSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnaXRJbnN0YW5jZUZhY3RvcnkoXG4gICBiYXNlRGlyPzogc3RyaW5nIHwgUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPixcbiAgIG9wdGlvbnM/OiBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XG4pIHtcbiAgIGNvbnN0IHBsdWdpbnMgPSBuZXcgUGx1Z2luU3RvcmUoKTtcbiAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUluc3RhbmNlQ29uZmlnKFxuICAgICAgKGJhc2VEaXIgJiYgKHR5cGVvZiBiYXNlRGlyID09PSAnc3RyaW5nJyA/IHsgYmFzZURpciB9IDogYmFzZURpcikpIHx8IHt9LFxuICAgICAgb3B0aW9uc1xuICAgKTtcblxuICAgaWYgKCFmb2xkZXJFeGlzdHMoY29uZmlnLmJhc2VEaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgYXBpLkdpdENvbnN0cnVjdEVycm9yKFxuICAgICAgICAgY29uZmlnLFxuICAgICAgICAgYENhbm5vdCB1c2Ugc2ltcGxlLWdpdCBvbiBhIGRpcmVjdG9yeSB0aGF0IGRvZXMgbm90IGV4aXN0YFxuICAgICAgKTtcbiAgIH1cblxuICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmNvbmZpZykpIHtcbiAgICAgIHBsdWdpbnMuYWRkKGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlnLmNvbmZpZykpO1xuICAgfVxuXG4gICBwbHVnaW5zLmFkZChibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oY29uZmlnLnVuc2FmZSkpO1xuICAgcGx1Z2lucy5hZGQoc3VmZml4UGF0aHNQbHVnaW4oKSk7XG4gICBwbHVnaW5zLmFkZChjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5jb21wbGV0aW9uKSk7XG4gICBjb25maWcuYWJvcnQgJiYgcGx1Z2lucy5hZGQoYWJvcnRQbHVnaW4oY29uZmlnLmFib3J0KSk7XG4gICBjb25maWcucHJvZ3Jlc3MgJiYgcGx1Z2lucy5hZGQocHJvZ3Jlc3NNb25pdG9yUGx1Z2luKGNvbmZpZy5wcm9ncmVzcykpO1xuICAgY29uZmlnLnRpbWVvdXQgJiYgcGx1Z2lucy5hZGQodGltZW91dFBsdWdpbihjb25maWcudGltZW91dCkpO1xuICAgY29uZmlnLnNwYXduT3B0aW9ucyAmJiBwbHVnaW5zLmFkZChzcGF3bk9wdGlvbnNQbHVnaW4oY29uZmlnLnNwYXduT3B0aW9ucykpO1xuXG4gICBwbHVnaW5zLmFkZChlcnJvckRldGVjdGlvblBsdWdpbihlcnJvckRldGVjdGlvbkhhbmRsZXIodHJ1ZSkpKTtcbiAgIGNvbmZpZy5lcnJvcnMgJiYgcGx1Z2lucy5hZGQoZXJyb3JEZXRlY3Rpb25QbHVnaW4oY29uZmlnLmVycm9ycykpO1xuXG4gICByZXR1cm4gbmV3IEdpdChjb25maWcsIHBsdWdpbnMpO1xufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdCwgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5pbXBvcnQgeyBHaXRSZXNwb25zZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBnaXRJbnN0YW5jZUZhY3RvcnkgfSBmcm9tICcuLi9naXQtZmFjdG9yeSc7XG5pbXBvcnQgeyBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpID0gWydjdXN0b21CaW5hcnknLCAnZW52JywgJ291dHB1dEhhbmRsZXInLCAnc2lsZW50J107XG5cbmNvbnN0IGZ1bmN0aW9uTmFtZXNQcm9taXNlQXBpID0gW1xuICAgJ2FkZCcsXG4gICAnYWRkQW5ub3RhdGVkVGFnJyxcbiAgICdhZGRDb25maWcnLFxuICAgJ2FkZFJlbW90ZScsXG4gICAnYWRkVGFnJyxcbiAgICdhcHBseVBhdGNoJyxcbiAgICdiaW5hcnlDYXRGaWxlJyxcbiAgICdicmFuY2gnLFxuICAgJ2JyYW5jaExvY2FsJyxcbiAgICdjYXRGaWxlJyxcbiAgICdjaGVja0lnbm9yZScsXG4gICAnY2hlY2tJc1JlcG8nLFxuICAgJ2NoZWNrb3V0JyxcbiAgICdjaGVja291dEJyYW5jaCcsXG4gICAnY2hlY2tvdXRMYXRlc3RUYWcnLFxuICAgJ2NoZWNrb3V0TG9jYWxCcmFuY2gnLFxuICAgJ2NsZWFuJyxcbiAgICdjbG9uZScsXG4gICAnY29tbWl0JyxcbiAgICdjd2QnLFxuICAgJ2RlbGV0ZUxvY2FsQnJhbmNoJyxcbiAgICdkZWxldGVMb2NhbEJyYW5jaGVzJyxcbiAgICdkaWZmJyxcbiAgICdkaWZmU3VtbWFyeScsXG4gICAnZXhlYycsXG4gICAnZmV0Y2gnLFxuICAgJ2dldFJlbW90ZXMnLFxuICAgJ2luaXQnLFxuICAgJ2xpc3RDb25maWcnLFxuICAgJ2xpc3RSZW1vdGUnLFxuICAgJ2xvZycsXG4gICAnbWVyZ2UnLFxuICAgJ21lcmdlRnJvbVRvJyxcbiAgICdtaXJyb3InLFxuICAgJ212JyxcbiAgICdwdWxsJyxcbiAgICdwdXNoJyxcbiAgICdwdXNoVGFncycsXG4gICAncmF3JyxcbiAgICdyZWJhc2UnLFxuICAgJ3JlbW90ZScsXG4gICAncmVtb3ZlUmVtb3RlJyxcbiAgICdyZXNldCcsXG4gICAncmV2ZXJ0JyxcbiAgICdyZXZwYXJzZScsXG4gICAncm0nLFxuICAgJ3JtS2VlcExvY2FsJyxcbiAgICdzaG93JyxcbiAgICdzdGFzaCcsXG4gICAnc3Rhc2hMaXN0JyxcbiAgICdzdGF0dXMnLFxuICAgJ3N1Yk1vZHVsZScsXG4gICAnc3VibW9kdWxlQWRkJyxcbiAgICdzdWJtb2R1bGVJbml0JyxcbiAgICdzdWJtb2R1bGVVcGRhdGUnLFxuICAgJ3RhZycsXG4gICAndGFncycsXG4gICAndXBkYXRlU2VydmVySW5mbycsXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2l0UChcbiAgIC4uLmFyZ3M6IFtdIHwgW3N0cmluZ10gfCBbUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPl0gfCBbc3RyaW5nLCBQYXJ0aWFsPFNpbXBsZUdpdE9wdGlvbnM+XVxuKTogU2ltcGxlR2l0IHtcbiAgIGxldCBnaXQ6IGFueTtcblxuICAgbGV0IGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgIHRyeSB7XG4gICAgICBnaXQgPSBnaXRJbnN0YW5jZUZhY3RvcnkoLi4uYXJncyk7XG4gICB9IGNhdGNoIChlKSB7XG4gICAgICBjaGFpbiA9IFByb21pc2UucmVqZWN0KGUpO1xuICAgfVxuXG4gICBmdW5jdGlvbiBidWlsZGVyUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIHByb21pc2VBcGk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGNoYWluUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIGNoYWluO1xuICAgfVxuXG4gICBjb25zdCBwcm9taXNlQXBpID0gWy4uLmZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpLCAuLi5mdW5jdGlvbk5hbWVzUHJvbWlzZUFwaV0ucmVkdWNlKFxuICAgICAgKGFwaTogYW55LCBuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgIGNvbnN0IGlzQXN5bmMgPSBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaS5pbmNsdWRlcyhuYW1lKTtcblxuICAgICAgICAgY29uc3QgdmFsaWQgPSBpc0FzeW5jID8gYXN5bmNXcmFwcGVyKG5hbWUsIGdpdCkgOiBzeW5jV3JhcHBlcihuYW1lLCBnaXQsIGFwaSk7XG4gICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZSA9IGlzQXN5bmMgPyBjaGFpblJldHVybiA6IGJ1aWxkZXJSZXR1cm47XG5cbiAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGksIG5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBnaXQgPyB2YWxpZCA6IGFsdGVybmF0aXZlLFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9LFxuICAgICAge31cbiAgICk7XG5cbiAgIHJldHVybiBwcm9taXNlQXBpIGFzIFNpbXBsZUdpdDtcblxuICAgZnVuY3Rpb24gYXN5bmNXcmFwcGVyKGZuOiBzdHJpbmcsIGdpdDogYW55KTogKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICdQcm9taXNlIGludGVyZmFjZSByZXF1aXJlcyB0aGF0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcGxpZWQgaW5saW5lLCAnICtcbiAgICAgICAgICAgICAgICAgICd0cmFpbGluZyBmdW5jdGlvbiBub3QgYWxsb3dlZCBpbiBjYWxsIHRvICcgK1xuICAgICAgICAgICAgICAgICAgZm5cbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjazogU2ltcGxlR2l0VGFza0NhbGxiYWNrID0gKGVycjogRXJyb3IgfCBudWxsLCByZXN1bHQ/OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QodG9FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgIGdpdFtmbl0uYXBwbHkoZ2l0LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgfVxuXG4gICBmdW5jdGlvbiBzeW5jV3JhcHBlcihmbjogc3RyaW5nLCBnaXQ6IGFueSwgYXBpOiBTaW1wbGVHaXQpIHtcbiAgICAgIHJldHVybiAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgIGdpdFtmbl0oLi4uYXJncyk7XG5cbiAgICAgICAgIHJldHVybiBhcGk7XG4gICAgICB9O1xuICAgfVxufVxuXG5mdW5jdGlvbiB0b0Vycm9yKGVycm9yOiBFcnJvciB8IHN0cmluZyB8IGFueSk6IEVycm9yIHtcbiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICB9XG5cbiAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGVycm9yKTtcbiAgIH1cblxuICAgcmV0dXJuIG5ldyBHaXRSZXNwb25zZUVycm9yKGVycm9yKTtcbn1cbiIsICJpbXBvcnQgeyBnaXRJbnN0YW5jZUZhY3RvcnkgfSBmcm9tICcuL2xpYi9naXQtZmFjdG9yeSc7XG5cbmV4cG9ydCB7IGdpdFAgfSBmcm9tICcuL2xpYi9ydW5uZXJzL3Byb21pc2Utd3JhcHBlZCc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9hcGknO1xuXG5leHBvcnQgY29uc3Qgc2ltcGxlR2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5O1xuXG5leHBvcnQgZGVmYXVsdCBnaXRJbnN0YW5jZUZhY3Rvcnk7XG4iLCAiaW1wb3J0IHsgR2l0U2VydmljZSB9IGZyb20gXCJAL3NlcnZpY2VzL2dpdFNlcnZpY2VcIjtcclxuaW1wb3J0IGxvZ2dlciBmcm9tIFwiQC91dGlscy9sb2dnZXJcIjtcclxuXHJcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tIFwicGF0aFwiO1xyXG5cclxuY29uc3QgR0lUSUdOT1JFX0ZJTEVfTkFNRSA9IFwiLmdpdGlnbm9yZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdpdGlnbm9yZVNlcnZpY2Uge1xyXG5cdHByaXZhdGUgZ2l0aWdub3JlUGF0aDogc3RyaW5nO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihiYXNlUGF0aDogc3RyaW5nLCBwcml2YXRlIGdpdFNlcnZpY2U6IEdpdFNlcnZpY2UpIHtcclxuXHRcdGxvZ2dlci5kZWJ1ZyhcIkluaXRpYWxpemluZyBHaXRpZ25vcmVTZXJ2aWNlLi4uXCIpO1xyXG5cdFx0dGhpcy5naXRpZ25vcmVQYXRoID0gcmVzb2x2ZShiYXNlUGF0aCwgR0lUSUdOT1JFX0ZJTEVfTkFNRSk7XHJcblx0XHRsb2dnZXIuZGVidWcoXCJHaXRpZ25vcmVTZXJ2aWNlIGluaXRpYWxpemVkLlwiKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc3RhZ2VDb21taXRBbmRQdXNoR2l0aWdub3JlKG1lc3NhZ2U6IHN0cmluZykge1xyXG5cdFx0YXdhaXQgdGhpcy5naXRTZXJ2aWNlLmdpdFN0YWdlKEdJVElHTk9SRV9GSUxFX05BTUUpO1xyXG5cdFx0YXdhaXQgdGhpcy5naXRTZXJ2aWNlLmdpdENvbW1pdChtZXNzYWdlKTtcclxuXHRcdGF3YWl0IHRoaXMuZ2l0U2VydmljZS5naXRQdXNoKCk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBHaXRTZXJ2aWNlIH0gZnJvbSBcIkAvc2VydmljZXMvZ2l0U2VydmljZVwiO1xyXG5cclxuaW1wb3J0IHsgQXBwLCBNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5tZXJnZWRGaWxlc1ZpZXcgZXh0ZW5kcyBNb2RhbCB7XHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHByaXZhdGUgZ2l0U2VydmljZT86IEdpdFNlcnZpY2UpIHtcclxuXHRcdHN1cGVyKGFwcCk7XHJcblx0fVxyXG5cclxuXHRvbk9wZW4oKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuXHRcdHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKFwiaDNcIiwge1xyXG5cdFx0XHR0ZXh0OiBcIkxvYWRpbmcuLi5cIixcclxuXHRcdFx0Y2xzOiBcInN5bmMtdGl0bGVcIixcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZ2l0U2VydmljZT8uZ2V0Q29uZmxpY3RpbmdGaWxlcygpLnRoZW4oKGZpbGVzKSA9PiB7XHJcblx0XHRcdHRoaXMuY29udGVudEVsLmVtcHR5KCk7XHJcblxyXG5cdFx0XHRpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKFwiaDNcIiwge1xyXG5cdFx0XHRcdFx0dGV4dDogXCJQbGVhc2UgcmVzb2x2ZSB0aGUgY29uZmxpY3RzIGluIHRoZSBmb2xsb3dpbmcgZmlsZXM6XCIsXHJcblx0XHRcdFx0XHRjbHM6IFwic3luYy10aXRsZVwiLFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRjb25zdCBsaXN0ID0gdGhpcy5jb250ZW50RWwuY3JlYXRlRWwoXCJ1bFwiKTtcclxuXHJcblx0XHRcdFx0ZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT5cclxuXHRcdFx0XHRcdGxpc3RcclxuXHRcdFx0XHRcdFx0LmNyZWF0ZUVsKFwibGlcIilcclxuXHRcdFx0XHRcdFx0LmNyZWF0ZUVsKFwic3Ryb25nXCIsIHtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0OiBmaWxlLFxyXG5cdFx0XHRcdFx0XHRcdGNsczogXCJzeW5jLWNvbmZsaWN0aW5nLWZpbGVzXCIsXHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmNvbnRlbnRFbC5jcmVhdGVFbChcImgzXCIsIHtcclxuXHRcdFx0XHRcdHRleHQ6IFwiTm8gdW5tZXJnZWQgZmlsZXMgdG8gc2hvdyFcIixcclxuXHRcdFx0XHRcdGNsczogXCJzeW5jLXRpdGxlXCIsXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0b25DbG9zZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuY29udGVudEVsLmVtcHR5KCk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgQ2ljYWRhUGx1Z2luIGZyb20gXCJAL21haW5cIjtcclxuXHJcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuaW1wb3J0IG9zIGZyb20gXCJvc1wiO1xyXG5pbXBvcnQgc2ltcGxlR2l0LCB7IFNpbXBsZUdpdCB9IGZyb20gXCJzaW1wbGUtZ2l0XCI7XHJcblxyXG5jb25zdCBHSVRIVUJfSVNTVUVfTElOSyA9XHJcblx0XCJodHRwczovL2dpdGh1Yi5jb20vYWRhcG9sZS9jaWNhZGEtc3luYy9pc3N1ZXMvbmV3L2Nob29zZVwiO1xyXG5jb25zdCBTQU1QTEVfUkVQTyA9IFwiZ2l0QGdpdGh1Yi5jb206YWRhcG9sZS9vYnNpZGlhbi15YW9zLmdpdFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBZYW9zU2V0dGluZ3Mge1xyXG5cdGRldmljZU5hbWU6IHN0cmluZztcclxuXHRyZW1vdGVSZXBvOiBzdHJpbmc7XHJcblx0YmFzZVBhdGg6IHN0cmluZztcclxuXHRicmFuY2hOYW1lOiBzdHJpbmc7XHJcblx0c3luY0ltYWdlczogYm9vbGVhbjtcclxuXHRzeW5jQXVkaW86IGJvb2xlYW47XHJcblx0c3luY1ZpZGVvczogYm9vbGVhbjtcclxuXHRzeW5jUGRmczogYm9vbGVhbjtcclxuXHRzeW5jT3RoZXJGaWxlczogYm9vbGVhbjtcclxuXHRzeW5jTWFpblNldHRpbmdzOiBib29sZWFuO1xyXG5cdHN5bmNBcHBlYXJhbmNlU2V0dGluZ3M6IGJvb2xlYW47XHJcblx0c3luY1RoZW1lc0FuZFNuaXBwZXRzOiBib29sZWFuO1xyXG5cdHN5bmNIb3RrZXlzOiBib29sZWFuO1xyXG5cdHN5bmNDb3JlUGx1Z2luU2V0dGluZ3M6IGJvb2xlYW47XHJcblx0c3luY0NvbW11bml0eVBsdWdpblNldHRpbmdzOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9ZQU9TX1NFVFRJTkdTOiBZYW9zU2V0dGluZ3MgPSB7XHJcblx0ZGV2aWNlTmFtZTogb3MuaG9zdG5hbWUoKSxcclxuXHRyZW1vdGVSZXBvOiBTQU1QTEVfUkVQTyxcclxuXHRiYXNlUGF0aDogX19kaXJuYW1lLFxyXG5cdGJyYW5jaE5hbWU6IFwibWFpblwiLFxyXG5cdHN5bmNJbWFnZXM6IGZhbHNlLFxyXG5cdHN5bmNBdWRpbzogZmFsc2UsXHJcblx0c3luY1ZpZGVvczogZmFsc2UsXHJcblx0c3luY1BkZnM6IGZhbHNlLFxyXG5cdHN5bmNPdGhlckZpbGVzOiBmYWxzZSxcclxuXHRzeW5jTWFpblNldHRpbmdzOiBmYWxzZSxcclxuXHRzeW5jQXBwZWFyYW5jZVNldHRpbmdzOiBmYWxzZSxcclxuXHRzeW5jVGhlbWVzQW5kU25pcHBldHM6IGZhbHNlLFxyXG5cdHN5bmNIb3RrZXlzOiBmYWxzZSxcclxuXHRzeW5jQ29yZVBsdWdpblNldHRpbmdzOiBmYWxzZSxcclxuXHRzeW5jQ29tbXVuaXR5UGx1Z2luU2V0dGluZ3M6IGZhbHNlLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWWFvc1NldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuXHRwbHVnaW46IENpY2FkYVBsdWdpbjtcclxuXHRwcml2YXRlIGdpdFByb3ZpZGVyOiBTaW1wbGVHaXQ7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IENpY2FkYVBsdWdpbikge1xyXG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xyXG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcblx0XHR0aGlzLmdpdFByb3ZpZGVyID0gc2ltcGxlR2l0KCk7XHJcblx0fVxyXG5cclxuXHRkaXNwbGF5KCkge1xyXG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuXHRcdHRoaXMuYWRkR2VuZXJhbFNlY3Rpb24oY29udGFpbmVyRWwpO1xyXG5cdFx0dGhpcy5hZGRHaXRTZXR1cChjb250YWluZXJFbCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFkZEdlbmVyYWxTZWN0aW9uKGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCkge1xyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoXCJHZW5lcmFsXCIpLnNldEhlYWRpbmcoKTtcclxuXHRcdHRoaXMuYWRkRGV2aWNlTmFtZVNldHRpbmcoY29udGFpbmVyRWwpO1xyXG5cdFx0dGhpcy5hZGRDcmVhdGVJc3N1ZVNldHRpbmcoY29udGFpbmVyRWwpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhZGRHaXRTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpIHtcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiU2V0dXAgR2l0XCIpLnNldEhlYWRpbmcoKTtcclxuXHRcdHRoaXMuYWRkQnJhbmNoTmFtZShjb250YWluZXJFbCk7XHJcblx0XHR0aGlzLmFkZFJlbW90ZVJlcG9VUkwoY29udGFpbmVyRWwpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhZGREZXZpY2VOYW1lU2V0dGluZyhlbDogSFRNTEVsZW1lbnQpIHtcclxuXHRcdG5ldyBTZXR0aW5nKGVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkRldmljZSBuYW1lXCIpXHJcblx0XHRcdC5zZXREZXNjKFxyXG5cdFx0XHRcdFwiVGhpcyBuYW1lIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBjb21taXQgbWVzc2FnZXMgdG8gaW5kaWNhdGUgdGhlIHN5bmMgc291cmNlLiBMZWF2ZSBlbXB0eSB0byB1c2UgdGhlIGRlZmF1bHQgbmFtZS5cIlxyXG5cdFx0XHQpXHJcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG5cdFx0XHRcdHRleHRcclxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihERUZBVUxUX1lBT1NfU0VUVElOR1MuZGV2aWNlTmFtZSlcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZXZpY2VOYW1lKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jIChkZXZpY2VOYW1lKSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmRldmljZU5hbWUgPSBkZXZpY2VOYW1lO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFkZENyZWF0ZUlzc3VlU2V0dGluZyhlbDogSFRNTEVsZW1lbnQpIHtcclxuXHRcdG5ldyBTZXR0aW5nKGVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkNvbnRhY3Qgc3VwcG9ydFwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRcIklmIHlvdSBydW4gaW50byBhbnkgaXNzdWVzIHdvcmtpbmcgd2l0aCB0aGlzIHBsdWdpbiwgcGxlYXNlIGxldCB1cyBrbm93IGJ5IGNyZWF0aW5nIGFuIGlzc3VlIG9uIG91ciBHaXRIdWIgcGFnZS5cIlxyXG5cdFx0XHQpXHJcblx0XHRcdC5hZGRCdXR0b24oKGJ1dHRvbikgPT5cclxuXHRcdFx0XHRidXR0b25cclxuXHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQ3JlYXRlIGlzc3VlXCIpXHJcblx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIkNyZWF0ZSBhbiBpc3N1ZSBvbiBHaXRIdWJcIilcclxuXHRcdFx0XHRcdC5zZXRDdGEoKVxyXG5cdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT5cclxuXHRcdFx0XHRcdFx0c2VsZi5vcGVuKEdJVEhVQl9JU1NVRV9MSU5LLCBcIl9ibGFua1wiLCBcIm5vcmVmZmVycmVyXCIpXHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFkZFJlbW90ZVJlcG9VUkwoZWw6IEhUTUxFbGVtZW50KSB7XHJcblx0XHRuZXcgU2V0dGluZyhlbClcclxuXHRcdFx0LnNldE5hbWUoXCJJbXBvcnQgcmVwb3NpdG9yeVwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRcIklmIHlvdSB3YW50IHRvIGltcG9ydCBhIHZhdWx0IGZyb20gYSByZW1vdGUgcmVwb3NpdG9yeSwgYWRkIHRoZSBVUkwgYW5kIEltcG9ydCB0byB0aGUgZGlyZWN0b3J5IHlvdSB3YW50LlwiXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFNBTVBMRV9SRVBPKVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbW90ZVJlcG8pXHJcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHJlbW90ZVJlcG8pID0+IHtcclxuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlUmVwbyA9IHJlbW90ZVJlcG87XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHRcdG5ldyBTZXR0aW5nKGVsKVxyXG5cdFx0XHQuc2V0RGVzYyhcIlRoZSBsb2NhbCB2YXVsdCBkaXJlY3RvcnkgdG8gbGluayB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuXCIpXHJcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG5cdFx0XHRcdHRleHRcclxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIkM6L1VzZXJzL1wiKVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jIChiYXNlUGF0aCkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoZWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PlxyXG5cdFx0XHRidXR0b25cclxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIkltcG9ydFwiKVxyXG5cdFx0XHRcdC5zZXRUb29sdGlwKFwiSW1wb3J0IGEgcmVtb3RlIHJlcG9zaXRvcnlcIilcclxuXHRcdFx0XHQuc2V0Q3RhKClcclxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCByZW1vdGVSZXBvID0gYCR7dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlUmVwb31gO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmdpdFByb3ZpZGVyXHJcblx0XHRcdFx0XHRcdFx0LmNsb25lKFxyXG5cdFx0XHRcdFx0XHRcdFx0cmVtb3RlUmVwbyxcclxuXHRcdFx0XHRcdFx0XHRcdGAke3RoaXMucGx1Z2luLnNldHRpbmdzLmJhc2VQYXRofWBcclxuXHRcdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHRcdFx0LmZldGNoKCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycm9yKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KVxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYWRkQnJhbmNoTmFtZShlbDogSFRNTEVsZW1lbnQpIHtcclxuXHRcdG5ldyBTZXR0aW5nKGVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIlNlbGVjdCBicmFuY2hcIilcclxuXHRcdFx0LnNldERlc2MoXCJTZXQgdGhlIHdvcmtpbmcgYnJhbmNoLlwiKVxyXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cclxuXHRcdFx0XHR0ZXh0XHJcblx0XHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoXCJtYWluXCIpXHJcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoTmFtZSlcclxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAoYnJhbmNoTmFtZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2hOYW1lID0gYnJhbmNoTmFtZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0bmV3IFNldHRpbmcoZWwpLmFkZEJ1dHRvbigoYnV0dG9uKSA9PlxyXG5cdFx0XHRidXR0b25cclxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIlN3aXRjaFwiKVxyXG5cdFx0XHRcdC5zZXRUb29sdGlwKFwiU3dpdGNoIHRvIHRoaXMgYnJhbmNoXCIpXHJcblx0XHRcdFx0LnNldEN0YSgpXHJcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IGdpdCA9IHNpbXBsZUdpdCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCk7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBnaXQuY2hlY2tvdXRCcmFuY2goXHJcblx0XHRcdFx0XHRcdFx0YCR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoTmFtZX1gLFxyXG5cdFx0XHRcdFx0XHRcdFwiSEVBRFwiXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBnaXQuY2hlY2tvdXQoXHJcblx0XHRcdFx0XHRcdFx0YCR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoTmFtZX1gXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdCk7XHJcblx0fVxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDZDQUFBQSxTQUFBO0FBQUEsS0FBQyxTQUFTLEdBQUUsR0FBRTtBQUFDLGtCQUFVLE9BQU8sV0FBUyxlQUFhLE9BQU9BLFVBQU9BLFFBQU8sVUFBUSxFQUFFLElBQUUsY0FBWSxPQUFPLFVBQVEsT0FBTyxNQUFJLE9BQU8sQ0FBQyxLQUFHLElBQUUsZUFBYSxPQUFPLGFBQVcsYUFBVyxLQUFHLE1BQU0sUUFBTSxFQUFFO0FBQUEsSUFBQyxFQUFFLFNBQU0sV0FBVTtBQUFDO0FBQWEsVUFBSSxJQUFFLEtBQUksSUFBRSxLQUFJLElBQUUsTUFBSyxJQUFFLGVBQWMsSUFBRSxVQUFTLElBQUUsVUFBUyxJQUFFLFFBQU8sSUFBRSxPQUFNLElBQUUsUUFBTyxJQUFFLFNBQVEsSUFBRSxXQUFVLElBQUUsUUFBTyxJQUFFLFFBQU8sSUFBRSxnQkFBZSxJQUFFLDhGQUE2RixJQUFFLHVGQUFzRixJQUFFLEVBQUMsTUFBSyxNQUFLLFVBQVMsMkRBQTJELE1BQU0sR0FBRyxHQUFFLFFBQU8sd0ZBQXdGLE1BQU0sR0FBRyxHQUFFLFNBQVEsU0FBU0MsSUFBRTtBQUFDLFlBQUlDLEtBQUUsQ0FBQyxNQUFLLE1BQUssTUFBSyxJQUFJLEdBQUVDLEtBQUVGLEtBQUU7QUFBSSxlQUFNLE1BQUlBLE1BQUdDLElBQUdDLEtBQUUsTUFBSSxFQUFFLEtBQUdELEdBQUVDLEVBQUMsS0FBR0QsR0FBRSxDQUFDLEtBQUc7QUFBQSxNQUFHLEVBQUMsR0FBRSxJQUFFLFNBQVNELElBQUVDLElBQUVDLElBQUU7QUFBQyxZQUFJQyxLQUFFLE9BQU9ILEVBQUM7QUFBRSxlQUFNLENBQUNHLE1BQUdBLEdBQUUsVUFBUUYsS0FBRUQsS0FBRSxLQUFHLE1BQU1DLEtBQUUsSUFBRUUsR0FBRSxNQUFNLEVBQUUsS0FBS0QsRUFBQyxJQUFFRjtBQUFBLE1BQUMsR0FBRSxJQUFFLEVBQUMsR0FBRSxHQUFFLEdBQUUsU0FBU0EsSUFBRTtBQUFDLFlBQUlDLEtBQUUsQ0FBQ0QsR0FBRSxVQUFVLEdBQUVFLEtBQUUsS0FBSyxJQUFJRCxFQUFDLEdBQUVFLEtBQUUsS0FBSyxNQUFNRCxLQUFFLEVBQUUsR0FBRUUsS0FBRUYsS0FBRTtBQUFHLGdCQUFPRCxNQUFHLElBQUUsTUFBSSxPQUFLLEVBQUVFLElBQUUsR0FBRSxHQUFHLElBQUUsTUFBSSxFQUFFQyxJQUFFLEdBQUUsR0FBRztBQUFBLE1BQUMsR0FBRSxHQUFFLFNBQVNKLEdBQUVDLElBQUVDLElBQUU7QUFBQyxZQUFHRCxHQUFFLEtBQUssSUFBRUMsR0FBRSxLQUFLO0FBQUUsaUJBQU0sQ0FBQ0YsR0FBRUUsSUFBRUQsRUFBQztBQUFFLFlBQUlFLEtBQUUsTUFBSUQsR0FBRSxLQUFLLElBQUVELEdBQUUsS0FBSyxNQUFJQyxHQUFFLE1BQU0sSUFBRUQsR0FBRSxNQUFNLElBQUdHLEtBQUVILEdBQUUsTUFBTSxFQUFFLElBQUlFLElBQUUsQ0FBQyxHQUFFRSxLQUFFSCxLQUFFRSxLQUFFLEdBQUVFLEtBQUVMLEdBQUUsTUFBTSxFQUFFLElBQUlFLE1BQUdFLEtBQUUsS0FBRyxJQUFHLENBQUM7QUFBRSxlQUFNLEVBQUUsRUFBRUYsTUFBR0QsS0FBRUUsT0FBSUMsS0FBRUQsS0FBRUUsS0FBRUEsS0FBRUYsUUFBSztBQUFBLE1BQUUsR0FBRSxHQUFFLFNBQVNKLElBQUU7QUFBQyxlQUFPQSxLQUFFLElBQUUsS0FBSyxLQUFLQSxFQUFDLEtBQUcsSUFBRSxLQUFLLE1BQU1BLEVBQUM7QUFBQSxNQUFDLEdBQUUsR0FBRSxTQUFTQSxJQUFFO0FBQUMsZUFBTSxFQUFDLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsSUFBRyxHQUFFLEdBQUUsRUFBQyxFQUFFQSxFQUFDLEtBQUcsT0FBT0EsTUFBRyxFQUFFLEVBQUUsWUFBWSxFQUFFLFFBQVEsTUFBSyxFQUFFO0FBQUEsTUFBQyxHQUFFLEdBQUUsU0FBU0EsSUFBRTtBQUFDLGVBQU8sV0FBU0E7QUFBQSxNQUFDLEVBQUMsR0FBRSxJQUFFLE1BQUssSUFBRSxDQUFDO0FBQUUsUUFBRSxDQUFDLElBQUU7QUFBRSxVQUFJLElBQUUsa0JBQWlCLElBQUUsU0FBU0EsSUFBRTtBQUFDLGVBQU9BLGNBQWEsS0FBRyxFQUFFLENBQUNBLE1BQUcsQ0FBQ0EsR0FBRSxDQUFDO0FBQUEsTUFBRSxHQUFFLElBQUUsU0FBU0EsR0FBRUMsSUFBRUMsSUFBRUMsSUFBRTtBQUFDLFlBQUlDO0FBQUUsWUFBRyxD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QUEsTUFDRDtBQUFBLElBQ0QsR0FBRztBQU1ILFlBQVEsU0FBUztBQUFBLE1BQ2hCO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRDtBQVdBLGFBQVMsWUFBWTtBQUlwQixVQUFJLE9BQU8sV0FBVyxlQUFlLE9BQU8sWUFBWSxPQUFPLFFBQVEsU0FBUyxjQUFjLE9BQU8sUUFBUSxTQUFTO0FBQ3JI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QUEsTUFBQTtFQUFBLGtCQUFBLE1BQUE7RUFBQSxZQUFBLE1BQUE7RUFBQSxNQUFBLE1BQUE7RUFBQSxNQUFBLE1BQUE7RUFBQSxrQkFBQSxNQUFBO0VBQUEsUUFBQSxNQUFBO0VBQUEsbUJBQUEsTUFBQTtFQUFBLFNBQUEsTUFBQTtFQUFBLFlBQUEsTUFBQTtFQUFBLFVBQUEsTUFBQTtFQUFBLGVBQUEsTUFBQTtFQUFBLGdCQUFBLE1BQUE7RUFBQSxnQkFBQSxNQUFBO0VBQUEsc0JBQUEsTUFBQTtFQUFBLE9BQUEsTUFBQTtFQUFBLGFBQUEsTUFBQTtFQUFBLGdCQUFBLE1BQUE7RUFBQSxpQkFBQSxNQUFBO0VBQUEsbUJBQUEsTUFBQTtFQUFBLGtCQUFBLE1BQUE7RUFBQSxjQUFBLE1BQUE7RUFBQSxtQkFBQSxNQUFBO0VBQUEsMkJBQUEsTUFBQTtFQUFBLFlBQUEsTUFBQTtFQUFBLE9BQUEsTUFBQTtFQUFBLGNBQUEsTUFBQTtFQUFBLHdCQUFBLE1BQUE7RUFBQSxvQkFBQSxNQUFBO0VBQUEsV0FBQSxNQUFBO0VBQUEsZ0JBQUEsTUFBQTtFQUFBLE1BQUEsTUFBQTtFQUFBLGdCQUFBLE1BQUE7RUFBQSxRQUFBLE1BQUE7RUFBQSxxQkFBQSxNQUFBO0VBQUEsTUFBQSxNQUFBO0VBQUEsZUFBQSxNQUFBO0VBQUEsUUFBQSxNQUFBO0VBQUEsU0FBQSxNQUFBO0VBQUEsb0JBQUEsTUFBQTtFQUFBLDBCQUFBLE1BQUE7RUFBQSx5QkFBQSxNQUFBO0FBQUEsQ0FBQTtBQUFBLElBQUEsYUFBQSxNQUFBO0VBQUEsMkJBQUE7QUFBQSwwQkFBQTtBQUNBLG9CQUFBO0FBQ0EsNEJBQUE7QUFDQSxxQkFBQTtBQUNBLDRCQUFBO0FBQ0Esc0JBQUE7QUFDQSxxQkFBQTtBQUNBLGNBQUE7RUFBQTtBQUFBLENBQUE7QUNQQSxJQUFBLHdCQUFBLENBQUE7QUFBQUEsVUFBQSx1QkFBQTtFQUFBLGtCQUFBLE1BQUE7RUFBQSxxQkFBQSxNQUFBO0VBQUEscUJBQUEsTUFBQTtFQUFBLGlCQUFBLE1BQUE7QUFBQSxDQUFBO0FB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TUFBTSxhQUFhLFdBQVcsS0FBSyxVQUFVO0FBQzVDLFVBQU0sS0FBSyxTQUFTLFFBQVE7QUFBQSxFQUM3QjtBQUFBLEVBRUEsTUFBYyxVQUFVLE1BQW1CO0FBQzFDLFFBQUksQ0FBQyxLQUFLLGNBQWMsQ0FBQyxLQUFLLGtCQUFrQjtBQUMvQyxxQkFBTyxNQUFNLGdDQUFnQztBQUFBLElBQzlDLFdBQVcsQ0FBQyxLQUFLLGdCQUFnQjtBQUNoQyxxQkFBTyxNQUFNLHNDQUFzQztBQUFBLElBQ3BELE9BQU87QUFDTixVQUFJO0FBQ0gsY0FBTSxLQUFLLGVBQWUsS0FBSztBQUFBLE1BQ2hDLFNBQVMsR0FBUDtBQUNELFlBQUksd0JBQU8saURBQWlEO0FBRTVELHVCQUFPLE1BQU0sa0JBQWtCLENBQUM7QUFBQSxNQUNqQztBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBQ0Q7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJ0IiwgImUiLCAibiIsICJyIiwgImkiLCAicyIsICJ1IiwgImEiLCAiTSIsICJtIiwgImYiLCAibCIsICIkIiwgInkiLCAidiIsICJnIiwgIkQiLCAibyIsICJkIiwgImMiLCAiaCIsICJtb2R1bGUiLCAibW9kdWxlIiwgImRlYnVnIiwgInNlbGYiLCAibW9kdWxlIiwgImV4aXN0cyIsICJfX2V4cG9ydCIsICJkZWZlcnJlZCIsICJjcmVhdGVDb25zb2xhIiwgImltcG9ydF9vYnNpZGlhbiIsICJlIiwgImltcG9ydF9wcm9taXNlX2RlZmVycmVkIiwgIl9fZXhwb3J0IiwgImRlYnVnIiwgImxvZ2dlciIsICJfX2NvbW1vbkpTIiwgIm1vZHVsZSIsICJfX3RvQ29tbW9uSlMiLCAiZGF5anMiLCAiaW1wb3J0X29ic2lkaWFuIiwgIl9hIiwgImltcG9ydF9vYnNpZGlhbiIsICJvcyIsICJpbXBvcnRfb2JzaWRpYW4iXQp9Cg==
